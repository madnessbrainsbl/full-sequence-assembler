<html>
<head>
<title>Diagnostics Command Manual - &sect;eagate Confidential</title>
<!-- ID: SeAgAtE[inspired by roye]|lco-fde|3.13|@Mon Apr 14 10:22:28 2008 -->
<style>
A {color: darkblue;}
A:hover {color: darkred;}
body,table {font-family: courier; font-size: 10pt;}
.title {font-size: 16pt;}
</style>
</head>
<body><a name="Top"></a><pre>

                        <b class="title">F3 Serial Port Diagnostics</b>

This document uses the following conventions:

<font color=red> - Items highlighted in red indicate a command or feature that is not fully functional.  Issuing
   these commands or selecting these features may produce unexpected results. </font>

<!--SECTION--><a name="Serial Port Diagnostic Modes"></a><hr color=black><b><big>  Serial Port Diagnostic Modes</big></b><hr color=black>

The Serial Port interface for platform drives operates in the following three modes:

<!--SUBSECTION--><a name="ESLIP Mode"></a><hr align=left width="75%"><b>(1) ESLIP Mode</b><hr align=left width="75%">

    Power-on default, This mode is enabled by Control-T.

    In this mode, the drive will respond only to ESLIP encoded packets received over the
    serial port interface.  The ASCII diagnostic commands described in this document are
    not available in this mode.  In this mode, the native interface (SATA, SCSI, SAS, FC)
    is alive.  This is the default power on mode for the serial port interface.

        - Entering a Control-T character from YASPP (or any similar host serial port
          program) while the drive serial port is in ASCII Online mode or ASCII
          Diagnostic mode will switch the serial port to ESLIP mode.

        - Entering a Control-R character while the drive serial port is in ESLIP mode
          will switch the serial port to ASCII Online mode.

        - Entering a Control-Z character while the drive serial port is in ESLIP mode
          will switch the serial port to ASCII Diagnostic mode.

<!--SUBSECTION--><a name="ASCII Online Mode"></a><hr align=left width="75%"><b>(2) ASCII Online Mode</b><hr align=left width="75%">

    This mode is enabled by Control-R.

    In this mode, the drive will respond only to the ASCII Online commands described in
    this document.  It will not respond to ESLIP encoded packets received over the serial
    port interface.  In this mode, the native interface (SATA, SCSI, SAS, FC) is alive.

        - Entering a Control-R character from YASPP (or any similar host serial port
          program) while the drive serial port is in ESLIP mode or ASCII Diagnostic
          mode will switch the serial port to ASCII Online mode.

        - Entering a Control-Z character while the drive serial port is in ASCII Online
          mode will switch the serial port to ASCII Diagnostic mode.

        - Entering a Control-T character while the drive serial port is in ASCII Online
          mode will switch the serial port to ESLIP mode.

<!--SUBSECTION--><a name="ASCII Diagnostic Mode"></a><hr align=left width="75%"><b>(3) ASCII Diagnostic Mode</b><hr align=left width="75%">

    This mode is enabled by Control-Z.

    In this mode, the drive will respond to all ASCII commands described in this document.
    It will not respond to ESLIP encoded packets received over the serial port interface.
    In this mode, the native interface (SATA, SCSI, SAS, FC) is not alive. 

        - Entering a Control-Z character from YASPP (or any similar host serial port
          program) while the drive serial port is in ESLIP mode or ASCII Online mode will
          switch the serial port to ASCII Diagnostic mode.

        - Entering a Control-R character while the drive serial port is in ASCII Diagnostic
          mode will switch the serial port to ASCII Online mode.

        - Entering a Control-T character while the drive serial port is in ASCII Diagnostic
          mode will switch the serial port to ESLIP mode.

<!--SECTION--><a name="Serial Port Diagnostic Command Levels"></a><hr color=black><b><big>  Serial Port Diagnostic Command Levels</big></b><hr color=black>
<a name="ALL_LEVEL_DIAG_CMD"></a>
<!--SUBSECTION--><a name="All Level Commands"></a><hr align=left width="75%"><b> All Level Commands</b><hr align=left width="75%">

 Carriage Return Command: <a href="F3Diag_RightFrame.html#Abort">Abort</a>

 '/' Command: <a href="F3Diag_RightFrame.html#Change Diagnostic Command Level">Change Diagnostic Command Level</a>

 '+' Command: <a href="F3Diag_RightFrame.html#Peek Memory Byte">Peek Memory Byte</a>

 '-' Command: <a href="F3Diag_RightFrame.html#Peek Memory Word">Peek Memory Word</a>

 '=' Command: <a href="F3Diag_RightFrame.html#Poke Memory Byte">Poke Memory Byte</a>

 '@' Command: <a href="F3Diag_RightFrame.html#Batch File Label">Batch File Label</a>

 '|' Command: <a href="F3Diag_RightFrame.html#Batch File Terminator">Batch File Terminator</a>

 '*' Command: <a href="F3Diag_RightFrame.html#Special Batch File Function">Special Batch File Function</a>

 'A' Command: <a href="F3Diag_RightFrame.html#Set Test Space">Set Test Space</a>

 'L' Command: <a href="F3Diag_RightFrame.html#Enable Looping">Enable Looping</a>

<a name="LEVEL_1_DIAG_CMD"></a>
<!--SUBSECTION--><a name="Level 1 Commands"></a><hr align=left width="75%"><b> Level 1 Commands</b><hr align=left width="75%">

 'B' Command: <a href="F3Diag_RightFrame.html#Buffer Display">Buffer Display</a>

 'D' Command: <a href="F3Diag_RightFrame.html#Memory Block Display">Memory Block Display</a>

 'G' Command: <a href="F3Diag_RightFrame.html#Generic Read/Write Request">Generic Read/Write Request</a>

 'I' Command: <a href="F3Diag_RightFrame.html#Buffer DLL Tune">Buffer DLL Tune</a>

 'N' Command: <a href="F3Diag_RightFrame.html#SMART Control">SMART Control</a>

 'S' Command: <a href="F3Diag_RightFrame.html#Edit Processor Memory Byte">Edit Processor Memory Byte</a>

 'U' Command: <a href="F3Diag_RightFrame.html#Edit Buffer Memory Byte">Edit Buffer Memory Byte</a>

 'c' Command: <a href="F3Diag_RightFrame.html#Buffer Compare">Buffer Compare</a>

 'e' Command: <a href="F3Diag_RightFrame.html#Spin Down and Reset Drive">Spin Down and Reset Drive</a>

 'm' Command: <a href="F3Diag_RightFrame.html#Edit Processor Memory Word">Edit Processor Memory Word</a>

<a name="LEVEL_2_DIAG_CMD"></a>
<!--SUBSECTION--><a name="Level 2 Commands"></a><hr align=left width="75%"><b> Level 2 Commands</b><hr align=left width="75%">

 'B' Command: <a href="F3Diag_RightFrame.html#Buffer Display">Buffer Display</a>

 'C' Command: <a href="F3Diag_RightFrame.html#Buffer Copy">Buffer Copy</a>

 'E' Command: <a href="F3Diag_RightFrame.html#Display / Edit Log">Display / Edit Log</a>

 'F' Command: <a href="F3Diag_RightFrame.html#Modify Track Defect List">Modify Track Defect List</a>

 'H' Command: <a href="F3Diag_RightFrame.html#Select Logical Head">Select Logical Head</a>

 'I' Command: <a href="F3Diag_RightFrame.html#Display / Modify Adaptive Parameter">Display / Modify Adaptive Parameter</a>

 'I,0' Command: <a href="F3Diag_RightFrame.html#Display / Modify CAP">Display / Modify CAP</a>

 'I,1' Command: <a href="F3Diag_RightFrame.html#Display / Modify RAP revision 02">Display / Modify RAP revision 02</a>

 'I,1' Command: <a href="F3Diag_RightFrame.html#Display / Modify RAP revision 10">Display / Modify RAP revision 10</a>

 'I,1' Command: <a href="F3Diag_RightFrame.html#Display / Modify RAP revision 11">Display / Modify RAP revision 11</a>

 'I,1' Command: <a href="F3Diag_RightFrame.html#Display / Modify RAP revision 14">Display / Modify RAP revision 14</a>

 'I,2' Command: <a href="F3Diag_RightFrame.html#Display / Modify SAP">Display / Modify SAP</a>

 'I,3' Command: <a href="F3Diag_RightFrame.html#Display / Modify RW Working Parameters">Display / Modify RW Working Parameters</a>

 'J' Command: <a href="F3Diag_RightFrame.html#Particle Sweep">Particle Sweep</a>
 
 'K' Command: <a href="F3Diag_RightFrame.html#Set Tracking Offset">Set Tracking Offset</a>

 'M' Command: <a href="F3Diag_RightFrame.html#Set Diag Idle Mode">Set Diag Idle Mode</a>

 'N' Command: <a href="F3Diag_RightFrame.html#Set Direct Write Mode">Set Direct Write Mode</a>

 'O' Command: <a href="F3Diag_RightFrame.html#Seek Repeatedly Between Physical Cylinders">Seek Repeatedly Between Physical Cylinders</a>

 'P' Command: <a href="F3Diag_RightFrame.html#Set Buffer Pattern">Set Buffer Pattern</a>

 'Q' Command: <a href="F3Diag_RightFrame.html#Write, Read, Read CHS">Write, Read, Read CHS</a>

 'R' Command: <a href="F3Diag_RightFrame.html#Read CHS">Read CHS</a>

 'S' Command: <a href="F3Diag_RightFrame.html#Seek to Logical Cylinder and Head">Seek to Logical Cylinder and Head</a>

 'T' Command: <a href="F3Diag_RightFrame.html#Measure Throughput">Measure Throughput</a>

 'U' Command: <a href="F3Diag_RightFrame.html#Spin Up Drive">Spin Up Drive</a>

 'V' Command: <a href="F3Diag_RightFrame.html#Read Verify CHS">Read Verify CHS</a>

 'W' Command: <a href="F3Diag_RightFrame.html#Write CHS">Write CHS</a>

 'X' Command: <a href="F3Diag_RightFrame.html#Display Track Information">Display Track Information</a>

 'Y' Command: <a href="F3Diag_RightFrame.html#Set Retries - Non-DERP">Set Retries - Non-DERP</a>

 'Y' Command: <a href="F3Diag_RightFrame.html#Set Retries - DERP">Set Retries - DERP</a>

 'Z' Command: <a href="F3Diag_RightFrame.html#Spin Down Drive">Spin Down Drive</a>

 'c' Command: <a href="F3Diag_RightFrame.html#Buffer Compare">Buffer Compare</a>

 'h' Command: <a href="F3Diag_RightFrame.html#Translate Physical Sector">Translate Physical Sector</a>

 'i' Command: <a href="F3Diag_RightFrame.html#Display Defects On Current Track">Display Defects On Current Track</a>
 
 'j' Command: <a href="F3Diag_RightFrame.html#Read Wedge">Read Wedge</a>

 'l' Command: <a href="F3Diag_RightFrame.html#Translate Logical Sector">Translate Logical Sector</a>

 'o' Command: <a href="F3Diag_RightFrame.html#Corrupt LBA">Corrupt LBA</a>

 'r' Command: <a href="F3Diag_RightFrame.html#Read Long CHS or Read System CHS">Read Long CHS or Read System CHS</a>

 's' Command: <a href="F3Diag_RightFrame.html#Seek to Physical Cylinder and Head">Seek to Physical Cylinder and Head</a>

 't' Command: <a href="F3Diag_RightFrame.html#Translate Wedge">Translate Wedge</a>

 'u' Command: <a href="F3Diag_RightFrame.html#Enable/Disable Channel/Preamp Register Display">Enable/Disable Channel/Preamp Register Display</a>

 'v' Command: <a href="F3Diag_RightFrame.html#Convert Data Track Percentage To Servo Offset Count">Convert Data Track Percentage To Servo Offset Count</a>

 'w' Command: <a href="F3Diag_RightFrame.html#Write Long CHS or Write System CHS">Write Long CHS or Write System CHS</a>

 'x' Command: <a href="F3Diag_RightFrame.html#Display Zone Information">Display Zone Information</a>

 'y' Command: <a href="F3Diag_RightFrame.html#Set DERP Retry State">Set DERP Retry State</a>

 'z' Command: <a href="F3Diag_RightFrame.html#Write Wedge">Write Wedge</a>

 '7' Command: <a href="F3Diag_RightFrame.html#Write Verify CHS">Write Verify CHS</a>

<a name="LEVEL_3_DIAG_CMD"></a>
<!--SUBSECTION--><a name="Level 3 Commands"></a><hr align=left width="75%"><b> Level 3 Commands</b><hr align=left width="75%">

 'D' Command: <a href="F3Diag_RightFrame.html#Measure Seek Access Time">Measure Seek Access Time</a>

 'E' Command: <a href="F3Diag_RightFrame.html#Display / Edit Log">Display / Edit Log</a>

 'H' Command: <a href="F3Diag_RightFrame.html#Select Logical Head">Select Logical Head</a>

 'O' Command: <a href="F3Diag_RightFrame.html#Seek Repeatedly Between Physical Cylinders">Seek Repeatedly Between Physical Cylinders</a>

 'Q' Command: <a href="F3Diag_RightFrame.html#Write, Read, Write, Read CHS">Write, Read, Write, Read CHS</a>

 'R' Command: <a href="F3Diag_RightFrame.html#Read Current Servo Destination">Read Current Servo Destination</a>

 'S' Command: <a href="F3Diag_RightFrame.html#Seek to Logical Cylinder and Head">Seek to Logical Cylinder and Head</a>

 'U' Command: <a href="F3Diag_RightFrame.html#Spin Up Drive">Spin Up Drive</a>

 'V' Command: <a href="F3Diag_RightFrame.html#Read or Write Power ASIC Register">Read or Write Power ASIC Register</a>

 'Z' Command: <a href="F3Diag_RightFrame.html#Spin Down Drive">Spin Down Drive</a>

 'b' Command: <a href="F3Diag_RightFrame.html#Load/Unload Heads">Load/Unload Heads</a>

 'c' Command: <a href="F3Diag_RightFrame.html#Measure Latch Force">Measure Latch Force</a>

 'f' Command: <a href="F3Diag_RightFrame.html#Real Time Servo Trace">Real Time Servo Trace</a>

 'p' Command: <a href="F3Diag_RightFrame.html#Translate Physical Sector">Translate Physical Sector</a>

 'q' Command: <a href="F3Diag_RightFrame.html#Translate Logical Sector">Translate Logical Sector</a>

 's' Command: <a href="F3Diag_RightFrame.html#Seek to Physical Cylinder and Head">Seek to Physical Cylinder and Head</a>

<a name="LEVEL_4_DIAG_CMD"></a>
<!--SUBSECTION--><a name="Level 4 Commands"></a><hr align=left width="75%"><b> Level 4 Commands</b><hr align=left width="75%">

 'B' Command: <a href="F3Diag_RightFrame.html#Enable / Disable RVFF">Enable / Disable RVFF</a>

 'D' Command: <a href="F3Diag_RightFrame.html#Measure Seek Access Time">Measure Seek Access Time</a>

 'E' Command: <a href="F3Diag_RightFrame.html#Display / Edit Log">Display / Edit Log</a>

 'H' Command: <a href="F3Diag_RightFrame.html#Select Logical Head">Select Logical Head</a>

 'K' Command: <a href="F3Diag_RightFrame.html#Set Tracking Offset">Set Tracking Offset</a>

 'O' Command: <a href="F3Diag_RightFrame.html#Display Micro Jog for Logical Cylinder and Head">Display Micro Jog for Logical Cylinder and Head</a>

 'S' Command: <a href="F3Diag_RightFrame.html#Seek to Logical Cylinder and Head">Seek to Logical Cylinder and Head</a>

 'U' Command: <a href="F3Diag_RightFrame.html#Servo Batch Test sub commands">Servo Batch Test sub commands</a>

 'e' Command: <a href="F3Diag_RightFrame.html#Enable / Disable PES Output">Enable / Disable PES Output</a>

 'l' Command: <a href="F3Diag_RightFrame.html#Scan Track for Servo Defects and ZAP">Scan Track for Servo Defects and ZAP</a>

 't' Command: <a href="F3Diag_RightFrame.html#Display / Modify ZAP Table">Display / Modify ZAP Table</a>

 'u' Command: <a href="F3Diag_RightFrame.html#Set Seek Speed">Set Seek Speed</a>

 'v' Command: <a href="F3Diag_RightFrame.html#Butterfly Seek Test">Butterfly Seek Test</a>

<a name="LEVEL_5_DIAG_CMD"></a>
<!--SUBSECTION--><a name="Level 5 Commands"></a><hr align=left width="75%"><b> Level 5 Commands</b><hr align=left width="75%">

 'B' Command: <a href="F3Diag_RightFrame.html#Servo Bode Plot">Servo Bode Plot</a>

 'C' Command: <a href="F3Diag_RightFrame.html#Generic Servo Command">Generic Servo Command</a>

 'D' Command: <a href="F3Diag_RightFrame.html#Read / Unlock DDR Buffer">Read / Unlock DDR Buffer</a>
 
 'E' Command: <a href="F3Diag_RightFrame.html#Measure Disc Eccentricity">Measure Disc Eccentricity</a>

 'F' Command: <a href="F3Diag_RightFrame.html#Drive Free Fall Protection">Drive Free Fall Protection</a>

 'G' Command: <a href="F3Diag_RightFrame.html#Select Servo Controller">Select Servo Controller</a>

 'R' Command: <a href="F3Diag_RightFrame.html#Read Servo RAM at Address">Read Servo RAM at Address</a>

 'S' Command: <a href="F3Diag_RightFrame.html#Enter Servo Matlab Shell">Enter Servo Matlab Shell</a>

 'U' Command: <a href="F3Diag_RightFrame.html#Enable / Disable Servo Updates">Enable / Disable Servo Updates</a>

 'W' Command: <a href="F3Diag_RightFrame.html#Write Servo RAM at Address">Write Servo RAM at Address</a>

 'Z' Command: <a href="F3Diag_RightFrame.html#Read Zap from Disc to Table">Read Zap from Disc to Table</a>

 'd' Command: <a href="F3Diag_RightFrame.html#Disable / Enable Servo ZAP coefficients and ZAP read">Disable / Enable Servo ZAP coefficients and ZAP read</a>

 'i' Command: <a href="F3Diag_RightFrame.html#Read Servo Symbol Table at Index">Read Servo Symbol Table at Index</a>

 'r' Command: <a href="F3Diag_RightFrame.html#Read Servo RAM at Index">Read Servo RAM at Index</a>

 'w' Command: <a href="F3Diag_RightFrame.html#Write Servo RAM at Index">Write Servo RAM at Index</a>

<a name="LEVEL_6_DIAG_CMD"></a>
<!--SUBSECTION--><a name="Level 6 Commands"></a><hr align=left width="75%"><b> Level 6 Commands</b><hr align=left width="75%">

 'B' Command: <a href="F3Diag_RightFrame.html#Run Batch File">Run Batch File</a>

 'D' Command: <a href="F3Diag_RightFrame.html#Display Batch File">Display Batch File</a>

 'E' Command: <a href="F3Diag_RightFrame.html#Enter Batch File">Enter Batch File</a>

<a name="LEVEL_7_DIAG_CMD"></a>
<!--SUBSECTION--><a name="Level 7 Commands"></a><hr align=left width="75%"><b> Level 7 Commands</b><hr align=left width="75%">

 'B' Command: <a href="F3Diag_RightFrame.html#Buffer Display">Buffer Display</a>

 'C' Command: <a href="F3Diag_RightFrame.html#Buffer Copy">Buffer Copy</a>

 'D' Command: <a href="F3Diag_RightFrame.html#Display Temperature">Display Temperature</a>

 'E' Command: <a href="F3Diag_RightFrame.html#Display / Edit Log">Display / Edit Log</a>

 'H' Command: <a href="F3Diag_RightFrame.html#Select Logical Head">Select Logical Head</a>

 'I' Command: <a href="F3Diag_RightFrame.html#Display / Modify Adaptive Parameter">Display / Modify Adaptive Parameter</a>

 'I,0' Command: <a href="F3Diag_RightFrame.html#Display / Modify CAP">Display / Modify CAP</a>

 'I,1' Command: <a href="F3Diag_RightFrame.html#Display / Modify RAP revision 02">Display / Modify RAP revision 02</a>

 'I,1' Command: <a href="F3Diag_RightFrame.html#Display / Modify RAP revision 10">Display / Modify RAP revision 10</a>

 'I,1' Command: <a href="F3Diag_RightFrame.html#Display / Modify RAP revision 11">Display / Modify RAP revision 11</a>

 'I,1' Command: <a href="F3Diag_RightFrame.html#Display / Modify RAP revision 14">Display / Modify RAP revision 14</a>

 'I,2' Command: <a href="F3Diag_RightFrame.html#Display / Modify SAP">Display / Modify SAP</a>

 'I,3' Command: <a href="F3Diag_RightFrame.html#Display / Modify RW Working Parameters">Display / Modify RW Working Parameters</a>

 'K' Command: <a href="F3Diag_RightFrame.html#Set Track Format">Set Track Format</a>

 'P' Command: <a href="F3Diag_RightFrame.html#Set Buffer Pattern">Set Buffer Pattern</a>

 'Q' Command: <a href="F3Diag_RightFrame.html#Write, Read, Read CHS">Write, Read, Read CHS</a>

 'R' Command: <a href="F3Diag_RightFrame.html#Read CHS">Read CHS</a>

 'S' Command: <a href="F3Diag_RightFrame.html#Seek to Logical Cylinder and Head">Seek to Logical Cylinder and Head</a>

 'U' Command: <a href="F3Diag_RightFrame.html#Channel Temperature Adjustment">Channel Temperature Adjustment</a>

 'W' Command: <a href="F3Diag_RightFrame.html#Write CHS">Write CHS</a>

 'X' Command: <a href="F3Diag_RightFrame.html#Display Preamp Head Resistance">Display Preamp Head Resistance</a>

 'Y' Command: <a href="F3Diag_RightFrame.html#Set Retries - Non-DERP">Set Retries - Non-DERP</a>

 'Y' Command: <a href="F3Diag_RightFrame.html#Set Retries - DERP">Set Retries - DERP</a>

 'Z' Command: <a href="F3Diag_RightFrame.html#Spin Down Drive">Spin Down Drive</a>

 'b' Command: <a href="F3Diag_RightFrame.html#Erase Track">Erase Track</a>

 'c' Command: <a href="F3Diag_RightFrame.html#Off Track Capability">Off Track Capability</a>

 'h' Command: <a href="F3Diag_RightFrame.html#Mark Media Flaw">Mark Media Flaw</a>

 'i' Command: <a href="F3Diag_RightFrame.html#Generic Read/Write Request">Generic Read/Write Request</a>

 'm' Command: <a href="F3Diag_RightFrame.html#Display Directed Offline Scan Information">Display Directed Offline Scan Information</a>

 'r' Command: <a href="F3Diag_RightFrame.html#Read Non-Volatile Adaptive Parameters">Read Non-Volatile Adaptive Parameters</a>

 's' Command: <a href="F3Diag_RightFrame.html#Write Peripheral Register - channel or preamp">Write Peripheral Register - channel or preamp</a>

 't' Command: <a href="F3Diag_RightFrame.html#Read Peripheral Register - channel or preamp">Read Peripheral Register - channel or preamp</a>

 'u' Command: <a href="F3Diag_RightFrame.html#Enable / Disable Write Fault">Enable / Disable Write Fault</a>

 'w' Command: <a href="F3Diag_RightFrame.html#Save Adaptives To Flash">Save Adaptives To Flash</a>

 'x' Command: <a href="F3Diag_RightFrame.html#Display Zone Information">Display Zone Information</a>

 'y' Command: <a href="F3Diag_RightFrame.html#Set DERP Retry State">Set DERP Retry State</a>

<a name="LEVEL_8_DIAG_CMD"></a>
<!--SUBSECTION--><a name="Level 8 Commands"></a><hr align=left width="75%"><b> Level 8 Commands</b><hr align=left width="75%">

 'C' Command: <a href="F3Diag_RightFrame.html#Servo Diagnostic Sub Commands">Servo Diagnostic Sub Commands</a>

 'R' Command: <a href="F3Diag_RightFrame.html#Read Current Servo Destination">Read Current Servo Destination</a>

 'S' Command: <a href="F3Diag_RightFrame.html#Seek to Logical Cylinder and Head">Seek to Logical Cylinder and Head</a>

 'U' Command: <a href="F3Diag_RightFrame.html#Spin Up Drive">Spin Up Drive</a>

 'Z' Command: <a href="F3Diag_RightFrame.html#Spin Down Drive">Spin Down Drive</a>

 'd' Command: <a href="F3Diag_RightFrame.html#Head Smash Test">Head Smash Test</a>

<a name="LEVEL_A_DIAG_CMD"></a>
<!--SUBSECTION--><a name="Level A Commands"></a><hr align=left width="75%"><b> Level A Commands</b><hr align=left width="75%">

 'C' Command: <a href="F3Diag_RightFrame.html#Translate PBA">Translate PBA</a>

 'D' Command: <a href="F3Diag_RightFrame.html#Translate Symbols From Index">Translate Symbols From Index</a>

 'E' Command: <a href="F3Diag_RightFrame.html#Display / Edit Log">Display / Edit Log</a>

 'F' Command: <a href="F3Diag_RightFrame.html#Translate LBA">Translate LBA</a>

 'M' Command: <a href="F3Diag_RightFrame.html#Set Controller Test Port">Set Controller Test Port</a>

 'P' Command: <a href="F3Diag_RightFrame.html#Merge Alternate List into Slip List">Merge Alternate List into Slip List</a>

 'Q' Command: <a href="F3Diag_RightFrame.html#Write, Read, Read LBA">Write, Read, Read LBA</a>

 'R' Command: <a href="F3Diag_RightFrame.html#Read LBA">Read LBA</a>

 'S' Command: <a href="F3Diag_RightFrame.html#Seek to LBA">Seek to LBA</a>

 'W' Command: <a href="F3Diag_RightFrame.html#Write LBA">Write LBA</a>

 'Y' Command: <a href="F3Diag_RightFrame.html#Set Retries - Non-DERP">Set Retries - Non-DERP</a>

 'Y' Command: <a href="F3Diag_RightFrame.html#Set Retries - DERP">Set Retries - DERP</a>

 'c' Command: <a href="F3Diag_RightFrame.html#Translate Logical Cylinder, Logical Head and Logical Sector">Translate Logical Cylinder, Logical Head and Logical Sector</a>

 'd' Command: <a href="F3Diag_RightFrame.html#Translate Physical Cylinder, Logical Head and Physical Sector">Translate Physical Cylinder, Logical Head and Physical Sector</a>

 'e' Command: <a href="F3Diag_RightFrame.html#Translate Nominal Cylinder and Logical Head">Translate Nominal Cylinder and Logical Head</a>

 'f' Command: <a href="F3Diag_RightFrame.html#Translate Physical Cylinder, Logical Head and Physical Wedge">Translate Physical Cylinder, Logical Head and Physical Wedge</a>

 'l' Command: <a href="F3Diag_RightFrame.html#Display Track Information">Display Track Information</a>

 'y' Command: <a href="F3Diag_RightFrame.html#Set DERP Retry State">Set DERP Retry State</a>

<a name="LEVEL_C_DIAG_CMD"></a>
<!--SUBSECTION--><a name="Level C Commands"></a><hr align=left width="75%"><b> Level C Commands</b><hr align=left width="75%">

 'Q' Command: <a href="F3Diag_RightFrame.html#Display ASCII Command Information">Display ASCII Command Information</a>

 'T' Command: <a href="F3Diag_RightFrame.html#Goop Plot">Goop Plot</a>

<a name="LEVEL_E_DIAG_CMD"></a>
<!--SUBSECTION--><a name="Level E Commands"></a><hr align=left width="75%"><b> Level E Commands</b><hr align=left width="75%">

 'B' Command: <a href="F3Diag_RightFrame.html#Write Wedge">Write Wedge</a>

 'C' Command: <a href="F3Diag_RightFrame.html#Read Wedge">Read Wedge</a>

 'm' Command: <a href="F3Diag_RightFrame.html#Fast MSESER Measurement">Fast MSESER Measurement</a>

 'o' Command: <a href="F3Diag_RightFrame.html#Fine RW Offset Measurement">Fine RW Offset Measurement</a>

 'w' Command: <a href="F3Diag_RightFrame.html#Slow Write CHS">Slow Write CHS</a>

<a name="LEVEL_F_DIAG_CMD"></a>
<!--SUBSECTION--><a name="Level F Commands"></a><hr align=left width="75%"><b> Level F Commands</b><hr align=left width="75%">

 'B' Command: <a href="F3Diag_RightFrame.html#Buffer Display">Buffer Display</a>

 'C' Command: <a href="F3Diag_RightFrame.html#Buffer Copy">Buffer Copy</a>

 'D' Command: <a href="F3Diag_RightFrame.html#Memory Block Display">Memory Block Display</a>

 'P' Command: <a href="F3Diag_RightFrame.html#Set Buffer Pattern">Set Buffer Pattern</a>

 'U' Command: <a href="F3Diag_RightFrame.html#Spin Up Drive">Spin Up Drive</a>

 'V' Command: <a href="F3Diag_RightFrame.html#Buffer Compare">Buffer Compare</a>

 'Y' Command: <a href="F3Diag_RightFrame.html#Set Retries - Non-DERP">Set Retries - Non-DERP</a>

 'Y' Command: <a href="F3Diag_RightFrame.html#Set Retries - DERP">Set Retries - DERP</a>

 'Z' Command: <a href="F3Diag_RightFrame.html#Spin Down Drive">Spin Down Drive</a>

 'b' Command: <a href="F3Diag_RightFrame.html#Set Baud Rate">Set Baud Rate</a>

 'r' Command: <a href="F3Diag_RightFrame.html#Read System CHS">Read System CHS</a>

 's' Command: <a href="F3Diag_RightFrame.html#Seek to Physical Cylinder and Head">Seek to Physical Cylinder and Head</a>

 't' Command: <a href="F3Diag_RightFrame.html#Write Peripheral Register - channel or preamp">Write Peripheral Register - channel or preamp</a>

 'y' Command: <a href="F3Diag_RightFrame.html#Set DERP Retry State">Set DERP Retry State</a>

 'z' Command: <a href="F3Diag_RightFrame.html#SATA Debug Athos Shanghai 390">SATA Debug Athos Shanghai 390</a>

 'z' Command: <a href="F3Diag_RightFrame.html#SATA Debug Athos MiPhy 365">SATA Debug Athos MiPhy 365</a>

 'z' Command: <a href="F3Diag_RightFrame.html#SATA Debug SPI SSIP">SATA Debug SPI SSIP</a>

<a name="LEVEL_G_DIAG_CMD"></a>
<!--SUBSECTION--><a name="Level G Commands"></a><hr align=left width="75%"><b> Level G Commands</b><hr align=left width="75%">

 'B' Command: <a href="F3Diag_RightFrame.html#Fill Correction Buffer">Fill Correction Buffer</a>

 'C' Command: <a href="F3Diag_RightFrame.html#Copy Correction Buffer">Copy Correction Buffer</a>

 'D' Command: <a href="F3Diag_RightFrame.html#Display Correction Buffer">Display Correction Buffer</a>

 'F' Command: <a href="F3Diag_RightFrame.html#Fill Super Parity RAM">Fill Super Parity RAM</a>

 'G' Command: <a href="F3Diag_RightFrame.html#Display Super Parity RAM">Display Super Parity RAM</a>

<a name="LEVEL_H_DIAG_CMD"></a>
<!--SUBSECTION--><a name="Level H Commands"></a><hr align=left width="75%"><b> Level H Commands</b><hr align=left width="75%">

 'B' Command: <a href="F3Diag_RightFrame.html#Buffer Display">Buffer Display</a>

 'P' Command: <a href="F3Diag_RightFrame.html#Set Buffer Pattern">Set Buffer Pattern</a>

 'S' Command: <a href="F3Diag_RightFrame.html#Seek to Logical Cylinder and Head">Seek to Logical Cylinder and Head</a>

 'b' Command: <a href="F3Diag_RightFrame.html#Contact Detect">Contact Detect</a>

<a name="LEVEL_L_DIAG_CMD"></a>
<!--SUBSECTION--><a name="Level L Commands"></a><hr align=left width="75%"><b> Level L Commands</b><hr align=left width="75%">

 'C' Command: <a href="F3Diag_RightFrame.html#Copy Log File">Copy Log File</a>

 'D' Command: <a href="F3Diag_RightFrame.html#Display Log File">Display Log File</a>

 'E' Command: <a href="F3Diag_RightFrame.html#Enable / Disable Logging">Enable / Disable Logging</a>

 'I' Command: <a href="F3Diag_RightFrame.html#Display Log File Information">Display Log File Information</a>

 'c' Command: <a href="F3Diag_RightFrame.html#Create Log File">Create Log File</a>

 'd' Command: <a href="F3Diag_RightFrame.html#Delete Log File">Delete Log File</a>

 'i' Command: <a href="F3Diag_RightFrame.html#Initialize Log File">Initialize Log File</a>

<a name="LEVEL_T_DIAG_CMD"></a>
<!--SUBSECTION--><a name="Level T Commands"></a><hr align=left width="75%"><b> Level T Commands</b><hr align=left width="75%">

 'B' Command: <a href="F3Diag_RightFrame.html#Set Baud Rate">Set Baud Rate</a>

 'E' Command: <a href="F3Diag_RightFrame.html#Display / Edit Log">Display / Edit Log</a>

 'F' Command: <a href="F3Diag_RightFrame.html#Set Congen Parameter">Set Congen Parameter</a>

 'O' Command: <a href="F3Diag_RightFrame.html#Select Data Output Mode">Select Data Output Mode</a>

 'P' Command: <a href="F3Diag_RightFrame.html#Download Generic File">Download Generic File</a>

 'R' Command: <a href="F3Diag_RightFrame.html#Read Non-Volatile Adaptive Parameters">Read Non-Volatile Adaptive Parameters</a>

 'T' Command: <a href="F3Diag_RightFrame.html#Odd Even Encroachment Test">Odd Even Encroachment Test</a>

 'V' Command: <a href="F3Diag_RightFrame.html#Display Defect Lists">Display Defect Lists</a>

 'W' Command: <a href="F3Diag_RightFrame.html#Save Adaptives To Flash">Save Adaptives To Flash</a>

 'Z' Command: <a href="F3Diag_RightFrame.html#Erase Seacos Data and Code">Erase Seacos Data and Code</a>

 'i' Command: <a href="F3Diag_RightFrame.html#Initialize Defect List">Initialize Defect List</a>

 'm' Command: <a href="F3Diag_RightFrame.html#Format Partition">Format Partition</a>

 '[' Command: <a href="F3Diag_RightFrame.html#ASCII Log Control">ASCII Log Control</a>

<a name="ONLINE_DIAG_CMD"></a>
<!--SUBSECTION--><a name="Online Commands"></a><hr align=left width="75%"><b> Online Commands</b><hr align=left width="75%">

 Carriage Return Command: <a href="F3Diag_RightFrame.html#Abort">Abort</a>

 ESCAPE Command: <a href="F3Diag_RightFrame.html#Abort Looping Command or Batch File">Abort Looping Command or Batch File</a>

 Space Command: <a href="F3Diag_RightFrame.html#Pause Output">Pause Output</a>

 '!' Command: <a href="F3Diag_RightFrame.html#Display Current Read Channel Settings">Display Current Read Channel Settings</a>

 '$' Command: <a href="F3Diag_RightFrame.html#Display Read/Write Statistics By Zone">Display Read/Write Statistics By Zone</a>

 '.' Command: <a href="F3Diag_RightFrame.html#Display Active Status">Display Active Status</a>

 '`' Command: <a href="F3Diag_RightFrame.html#Display Read/Write Statistics">Display Read/Write Statistics</a>

 '<' Command: <a href="F3Diag_RightFrame.html#Decrement Read/Write Scope Sync">Decrement Read/Write Scope Sync</a>

 '>' Command: <a href="F3Diag_RightFrame.html#Increment Read/Write Scope Sync">Increment Read/Write Scope Sync</a>

 '?' Command: <a href="F3Diag_RightFrame.html#Display Diagnostic Buffer Information">Display Diagnostic Buffer Information</a>

 '{' Command: <a href="F3Diag_RightFrame.html#Toggle EIB-Specific R/W Tracing">Toggle EIB-Specific R/W Tracing</a>

 '~' Command: <a href="F3Diag_RightFrame.html#Display Native Interface Command State">Display Native Interface Command State</a>

 Control A Command: <a href="F3Diag_RightFrame.html#Display Firmware Revision">Display Firmware Revision</a>

 Control B Command: <a href="F3Diag_RightFrame.html#Get Thermistor Temperature">Get Thermistor Temperature</a>

 Control C Command: <a href="F3Diag_RightFrame.html#Firmware Reset">Firmware Reset</a>

 Control D Command: <a href="F3Diag_RightFrame.html#Toggle R/W Tracing">Toggle R/W Tracing</a>

 Control E Command: <a href="F3Diag_RightFrame.html#Display Native Interface Configuration">Display Native Interface Configuration</a>

 Control F Command: <a href="F3Diag_RightFrame.html#Display Native Interface Read Cache Information">Display Native Interface Read Cache Information</a>

 Control I Command: <a href="F3Diag_RightFrame.html#Display Controller Registers">Display Controller Registers</a>

 Control K Command: <a href="F3Diag_RightFrame.html#Display DST Status">Display DST Status</a>

 Control L Command: <a href="F3Diag_RightFrame.html#Display Sign On Message">Display Sign On Message</a>

 Control N Command: <a href="F3Diag_RightFrame.html#Toggle R/W Tracing">Toggle R/W Tracing</a>

 Control P Command: <a href="F3Diag_RightFrame.html#Toggle Diag Idle Mode">Toggle Diag Idle Mode</a>

 Control Q Command: <a href="F3Diag_RightFrame.html#Resume Interface Task">Resume Interface Task</a>

 Control R Command: <a href="F3Diag_RightFrame.html#Enable ASCII Online Serial Port Mode">Enable ASCII Online Serial Port Mode</a>

 Control S Command: <a href="F3Diag_RightFrame.html#Pause Interface Task">Pause Interface Task</a>

 Control T Command: <a href="F3Diag_RightFrame.html#Enable ESLIP Serial Port Mode">Enable ESLIP Serial Port Mode</a>

 Control U Command: <a href="F3Diag_RightFrame.html#Display Congen">Display Congen</a>

 Control V Command: <a href="F3Diag_RightFrame.html#Toggle Interface Command Echo">Toggle Interface Command Echo</a>

 Control W Command: <a href="F3Diag_RightFrame.html#Enable and Init RW Statistics">Enable and Init RW Statistics</a>

 Control X Command: <a href="F3Diag_RightFrame.html#Display Native Interface and Read/Write Command History">Display Native Interface and Read/Write Command History</a>

 Control Y Command: <a href="F3Diag_RightFrame.html#Display DST Status">Display DST Status</a>

 Control Z Command: <a href="F3Diag_RightFrame.html#Enable ASCII Diagnostic Serial Port Mode">Enable ASCII Diagnostic Serial Port Mode</a>

 Control \ Command: <a href="F3Diag_RightFrame.html#Toggle Debug Display Enable">Toggle Debug Display Enable</a>


<!--SECTION--><a name="Serial Port Diagnostic Commands"></a><hr color=black><b><big>  Serial Port Diagnostic Commands</big></b><hr color=black>
<a name="ABORT_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Abort"></a><hr align=left width="75%"><b> Abort (All Levels and Online Carriage Return)</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command terminates any diagnostic command that is in progress and disables looping.

  <b><i><u>Quick Help:</u></i></b>
<a name="ABORT_QUICK_HELP"></a>
    "Abort";

  <b><i><u>Input Parameters:</u></i></b>
    None

  <b><i><u>Output Data:</u></i></b>
    None

  <b><i><u>Revision History:</u></i></b>
<a name="ABORT_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="ABORT_LOOPING_CMD_OR_BATCH_FILE_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Abort Looping Command or Batch File"></a><hr align=left width="75%"><b> Abort Looping Command or Batch File (Online ESCAPE)</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command aborts the looping of a diagnostic command or the execution of a Batch
    File.

  <b><i><u>Quick Help:</u></i></b>
<a name="ABORT_LOOPING_CMD_OR_BATCH_FILE_QUICK_HELP"></a>
    "AbortLoopOrBatchFile";

  <b><i><u>Input Parameters:</u></i></b>
    None

  <b><i><u>Output Data:</u></i></b>
    None

  <b><i><u>Revision History:</u></i></b>
<a name="ABORT_LOOPING_CMD_OR_BATCH_FILE_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="ASCII_LOG_CONTROL_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="ASCII Log Control"></a><hr align=left width="75%"><b> ASCII Log Control (Level T '[')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command performs various functions associated with the ASCII Log.  THe ASCII Log
    is used to capture ASCII data transfered to the host over the Serial Port Interface.

  <b><i><u>Quick Help:</u></i></b>
<a name="ASCII_LOG_CONTROL_QUICK_HELP"></a>
    "AsciiLogControl, [[LogFunction],[Log]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="ASCII_LOG_CONTROL_PARM"></a>
    0 - Select ASCII Log Function.
    
        This parameter selects the following ASCII log functions.
    
           0x09 - Append data to end of ASCII Log.
    
                  If Parameter 0 is equal to 9, ASCII data entered from the serial port
                  will be appended to the end of the ASCII log.  Entering a carriage return
                  terminates the ASCII data to be appended.
    
           0x0A - Enable ASCII Logging.
    
                  If Parameter 0 is equal to 0xA, ASCII Logging will be enabled.  When
                  enabled, ASCII Logging will capture all data transfered to the host
                  over the serial port interface to the ASCII Log.
    
           0x0B - Disable ASCII Logging.
    
                  If Parameter 0 is equal to 0xB, ASCII Logging will be disabled.
    
           0x0C - Save ASCII Log.
    
                  If Parameter 0 is equal to 0xC, the ASCII Log will be copied to the log
                  specified by Parameter 1.
    
           0x0D - Display ASCII Log.
    
                  If Parameter 0 is equal to 0xD, the ASCII Log will be displayed.
    
          Type:    Unsigned 8-bit value
    
          Range:   0 to 0xFF
    
          Default: None
    
    1 - Log Number.
    
        If Parameter 0 is equal to 0xC, this parameter specifies the number of the log
        to which the ASCII Log is to be copied.  If Parameter 0 is not equal to 0xC, this
        parameter will not be used.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: None
    

  <b><i><u>Output Data:</u></i></b>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
    If no error occurred and the contents of an ASCII Log are being displayed,
<a name="ASCII_LOG_DATA"></a>
    
    "Log c Entries d"
    
    (Followed by the ASCII data contained in log)
    
    where
    
       c is the log number
    
       d is the number of valid ASCII characters contained in the log
    

  <b><i><u>Revision History:</u></i></b>
<a name="ASCII_LOG_CONTROL_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="BATCH_FILE_LABEL_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Batch File Label"></a><hr align=left width="75%"><b> Batch File Label (All Levels '@')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command places a label in a Batch File that can be the destination for Batch File
    branch instructions.  See the Special Batch File Function command (All Levels '*') for
    a description of the available branch instructions.

  <b><i><u>Quick Help:</u></i></b>
<a name="BATCH_FILE_LABEL_QUICK_HELP"></a>
    "BatchFileLabel, @[LabelNum]";

  <b><i><u>Input Parameters:</u></i></b>
    0 - Label Number.

        This parameter specifies the Label Number.  The Batch File branch instructions
        specify this value as the branch destination.

          Type:    Unsigned 32-bit value

          Range:   0 to 0xF

          Default: None

  <b><i><u>Output Data:</u></i></b>
    None

  <b><i><u>Revision History:</u></i></b>
<a name="BATCH_FILE_LABEL_REVISION_HISTORY"></a>
    0001.0000   Initial revision.

<a name="BATCH_FILE_TERMINATOR_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Batch File Terminator"></a><hr align=left width="75%"><b> Batch File Terminator (All Levels '|')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
   This command terminates the entry and execution of a Batch File.

  <b><i><u>Quick Help:</u></i></b>
<a name="BATCH_FILE_TERMINATOR_QUICK_HELP"></a>
    "BatchFileTerminator, |";

  <b><i><u>Input Parameters:</u></i></b>
    None

  <b><i><u>Output Data:</u></i></b>
    None

  <b><i><u>Revision History:</u></i></b>
<a name="BATCH_FILE_TERMINATOR_REVISION_HISTORY"></a>
    0001.0000   Initial revision.

<a name="BUFFER_COMPARE_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Buffer Compare"></a><hr align=left width="75%"><b> Buffer Compare (Level 1, 2 'c', Level F 'V')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    The Buffer Compare command compares the contents of the specified source buffer
    block(s) to the specified reference buffer block(s) and returns an error if a
    miscompare is detected.

  <b><i><u>Quick Help:</u></i></b>
<a name="BUFFER_COMPARE_QUICK_HELP"></a>
       Level 1 and 2
    "BufferCompare, c[SrcBlk],[RefBlk],[NumBlks],[ContOnErr]";
       Level F
    "BufferCompare, V[SrcBlk],[RefBlk],[NumBlks],[ContOnErr]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="BUFFER_COMPARE_PARM"></a>
    0 - First Source Buffer Block Number.
    
        If this parameter is entered, it specifies the number of the first buffer block
        that contains the source data to be compared.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to Buffer Size (in blocks) minus 1
    
          Default: If this parameter is not entered, the first block of the Diagnostic
                   Read Buffer will be the first source block.
    
    1 - First Reference Buffer Block Number.
    
        If this parameter is entered, it specifies the number of the first buffer block
        to which the source data is to be compared.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to Buffer Size (in blocks) minus 1
    
          Default: If this parameter is not entered, the first block of the Diagnostic
                   Write Buffer will be the first reference block.
    
    2 - Number of Buffer Blocks to Compare.
    
        This parameter specifies the number of consecutive buffer blocks to be compared.
    
          Type:    Unsigned 16-bit value
    
          Range:   1 to maximum number of buffer blocks
    
          Default: If Parameters 0, 1 and 2 are not entered, the entire Diagnostic Read
                   Buffer will be compared to the Diagnostic Write Buffer.  If Parameter 2
                   is not entered and either Parameter 0 or 1 is entered, a single buffer
                   block will be compared.
    
    3 - Continue on Error option.
    
        If this parameter is entered, the compare operation will compare all of the
        specified bytes and display an error for each miscompare that is detected.
        If this parameter is not entered, the compare operation will stop when the
        first miscompare is detected.
    
          Type:    Unsigned 8-bit value
    
          Range:   0 to 0xFF
    
          Default: None
    

  <b><i><u>Output Data:</u></i></b>
<a name="BUFFER_COMPARE_DATA"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
        If the error is a buffer miscompare, the following additional information will be
        displayed.
    
           "at SrcBlk = cccc Addr = dddddddd Data = ee, RefBlk = ffff Addr = gggggggg Data = hh"
    
           where
    
              cccc is the number of the Source Buffer Block in which the miscompare occurred.
    
              dddddddd is the address of the Source Buffer byte that miscompared.
    
              ee is the value of the Source Buffer byte that miscompared.
    
              ffff is the number of the Reference Buffer Block in which the miscompare occurred.
    
              gggggggg is the address of the Reference Buffer byte that miscompared.
    
              hh is the value of the Reference Buffer byte that miscompared.
    

  <b><i><u>Revision History:</u></i></b>
<a name="BUFFER_COMPARE_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="BUFFER_COPY_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Buffer Copy"></a><hr align=left width="75%"><b> Buffer Copy (Level 2, 7, F 'C')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    The Buffer Copy command copies the contents of the specified source buffer block(s)
    to the specified destination buffer block(s).

  <b><i><u>Quick Help:</u></i></b>
<a name="BUFFER_COPY_QUICK_HELP"></a>
    "BufferCopy, C[SrcBlk],[DestBlk],[NumBlks]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="BUFFER_COPY_PARM"></a>
    0 - First Source Buffer Block Number.
    
        If this parameter is entered, it specifies the number of the first buffer block
        that contains the source data to be copied.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to Buffer Size (in blocks) minus 1
    
          Default: If this parameter is not entered, the first block of the Diagnostic
                   Read Buffer will be the first source block.
    
    1 - First Destination Buffer Block Number.
    
        If this parameter is entered, it specifies the number of the first buffer block
        to which the source data is to be copied.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to Buffer Size (in blocks) minus 1
    
          Default: If this parameter is not entered, the first block of the Diagnostic
                   Write Buffer will be the first destination block.
    
    2 - Number of Buffer Blocks to Copy.
    
        This parameter specifies the number of consecutive buffer blocks to be copied.
    
          Type:    Unsigned 16-bit value
    
          Range:   1 to maximum number of buffer blocks
    
          Default: If Parameters 0, 1 and 2 are not entered, the entire Diagnostic Read
                   Buffer will be copied to the Diagnostic Write Buffer.  If Parameter 2
                   is not entered and either Parameter 0 or 1 is entered, a single buffer
                   block will be copied.
    

  <b><i><u>Output Data:</u></i></b>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    

  <b><i><u>Revision History:</u></i></b>
<a name="BUFFER_COPY_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="BUFFER_DISPLAY_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Buffer Display"></a><hr align=left width="75%"><b> Buffer Display (Levels 1, 2, 7, F, H 'B')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    The Buffer Display command reads and displays the contents of the specified buffer
    blocks.  Optionally, the buffer data being displayed can be compared to a specified
    compare buffer blocks, with miscomparing bytes displayed as highlighted text.

  <b><i><u>Quick Help:</u></i></b>
<a name="BUFFER_DISPLAY_QUICK_HELP"></a>
    "BufferDisplay, B[DisplayBlk],[RefBlk],[NumBlks],[Opts],[SymBits]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="BUFFER_DISPLAY_PARM"></a>
    0 - Display Buffer Block.
    
        This parameter specifies the number of the first buffer block to be displayed.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to last buffer block number
    
          Default: If this parameter is not entered, the First block of Diagnostic Read
                   Buffer will be displayed.
    
    1 - Reference Buffer Block.
    
        This parameter specifies the number of the first buffer block that will be
        compared to the blocks being displayed.  Bytes that miscompare will be
        displayed as highlighted text.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to last buffer block number
    
          Default: If this parameter is not entered and the Display Buffer Block is
                   located in the Diagnostic Read Buffer, the corresponding block in
                   the Diagnostic Write Buffer will be used as the Reference Buffer
                   Block.
    
    2 - Number of Blocks.
    
        This parameter specifies the number of consecutive buffer blocks to be display.
    
          Type:    Unsigned 16-bit value
    
          Range:   1 to the number of buffer blocks
    
          Default: 1
    
    3 - Options.
    
        This parameter is a bit-significant value that selects the following options.
    
          Bits 31-1: not used
    
          Bit 0:     Disable pause after each block displayed.
    
                      If this bit is cleared, the display will pause after each block
                      and wait for the user to enter a character.
    
                      If this bit is set, all of the requested blocks will be displayed
                      without pausing.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: 0 (Enable pause after each block displayed)
    
    4 - Symbol Size.
    
        If this parameter specifies the size, in bits, of the symbols to be displayed.
    
          Type:    Unsigned 8-bit value
    
          Range:   1 to 32
    
          Default: 8
    

  <b><i><u>Output Data:</u></i></b>
<a name="BUFFER_BLOCK_DATA"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
        If no error occurred, the following header will be displayed.
    
              "Buffer Block cccc (eee Bytes/Block)"                                   or
              "Buffer Block cccc compared to Buffer Block dddd (eee Bytes/Block)"
    
           where
    
              cccc is the number of the Buffer Block being displayed.
    
              dddd if the number of the Buffer Block to which the displayed block is
                   being compared.
    
              eee is the number of bytes per block.
    
        If the memory data is being displayed as bytes, the following information will be
        displayed following the header.
    
              "  Addr    0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F"
              "ffffffff  gg gg gg gg gg gg gg gg gg gg gg gg gg gg gg gg"  (repeated)
    
           where
    
              ffffffff is the buffer address of the first byte in the row.
    
              gg is the buffer data byte.
    
        If the memory data is being displayed as non-8-bit symbols, the following information
        will be displayed following the header.
    
              "Symbol Size = hh bits"
              "Sym  0  1  2  ... "
              "iii  jj jj jj ... "             (repeated)
    
           where
    
              hh is the size, in bits, of the symbols being displayed.
    
              iii is the number of the first symbol in the row.
    
              jj is the buffer symbol.  The number of characters displayed for each symbol
                 will vary depending on the symbol size.
    
        If the displayed data is being compared to a reference buffer block, the bytes or
        symbols that are not equal to the reference will be displayed as highlighted text.
    

  <b><i><u>Revision History:</u></i></b>
<a name="BUFFER_DISPLAY_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="BUFFER_DLL_TUNE_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Buffer DLL Tune"></a><hr align=left width="75%"><b> Buffer DLL Tune (Level 1 'I')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command exercises the DRAM read clock DLL tuning routines.

  <b><i><u>Quick Help:</u></i></b>
<a name="BUFFER_DLL_TUNE_QUICK_HELP"></a>
    "BufferDllTune, I[action][DLL]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="BUFFER_DLL_TUNE_INPUT_PARAMETER"></a>
    
    0 - Action Value.
    
        This parameter specifies what action to take.
<a name="BUFFER_DLL_TUNE_INPUT_PARAMETER_CONSTANTS"></a>
        0: Display value currently in bypass register
        1: not used
        2: Enable periodic compensation.
        3: Disable periodic compensation.
        4: Enable display of compensation.
        5: Disable display of compensation.
        9: Set new bypass value to specified value.
    
          Type:    unsigned 32 bit value
    
          Range:   0, 2, 3, 4, 5, 9
    
          Default: 0 ( display current bypass register value )
    
    
    1 - New Value.
    
        This parameter specifies the new DLL value to load.
    
          Type:    unsigned 32 bit value
    
          Range:   0 to 0x1FF
    
          Default: none
    

  <b><i><u>Output Data:</u></i></b>
<a name="BUFFER_DLL_TUNE_OUTPUT_DATA"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
    
    If no error occurred, then the output of this command will be displayed as follows:
    
    Current reg = 92
    

  <b><i><u>Examples:</u></i></b>
    Example #1:
       To display current DLL values:
         F3 1>I

    Example #2:
       To turn on display of DLL values:
         F3 1>I4

    Example #3:
       To turn off periodic DLL updates:
         F3 1>I3

  <b><i><u>Revision History:</u></i></b>
<a name="BUFFER_DLL_TUNE_REVISION_HISTORY"></a>
    0001.0000   Initial revision.

<a name="BUTTERFLY_SEEK_TEST_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Butterfly Seek Test"></a><hr align=left width="75%"><b> Butterfly Seek Test (Level 4 'v')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    The Butterfly Seek Test commmand performs the following seeks on the specified head:

    1) Seek to specified 1st cylinder ( minimum cyl addr , OD ) , then to specified
       2nd cylinder ( maximum cyl addr , ID ) .
    2) Increment 1st cyl, decrement 2nd cyl , seek to 1st , then 2nd .
    3) Repeat 2) until seek has again reached original OD and ID cylinders,
       but in opposite order of original seek.
    4) Decrement 1st cyl, increment 2nd cyl , seek to 1st , then 2nd .
    5) Repeat 4) until seek has again reached original OD and ID cylinders.
    6) Repeat Steps 2) through 5) until test duration or desired number
       seeks is complete.

  <b><i><u>Quick Help:</u></i></b>
<a name="BUTTERFLY_SEEK_TEST_QUICK_HELP"></a>
    "ButterflySeekTest, v[StartPhyCyl0],[StartPhyCyl1],[NumSkPairs],[NumSeconds],[Hd]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="BUTTERFLY_OR_CYL_TO_CYL_SEEK_TEST_PARM"></a>
    
    0 - Starting first Physical cylinder of seek
          Expected to be OD-most bound, but code functions correctly with either OD or ID .
    
          Type:    Signed 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: Minimum ( OD ) physical cylinder for current head
    
    
    1 - Starting Second Physical cylinder of seek
          Expected to be ID-most bound, but code functions correctly with either OD or ID .
    
          Type:    Signed 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: Maximum ( ID ) physical cylinder for current head
    
    
    2 - Number of seek pairs ( a seek to "second" cylinder, then  to "first" ) to do
          for this test if Parameter 3 not entered,
        ELSE time in seconds to run seek test
        ELSE if == 0 , continue test for large arbitrary time .
    
          Type:    Unigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: 5 ( Seconds )
    
    
    
    3 - Select test duration to be time or number of seek pairs. If not entered ,
        perform Parameter 2 seek pairs .  If entered, run seeks for Parameter 2 seconds,
        for "forever", or for number of seconds specified by parameter 2 .
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: 0 ( Perform counted seeks, not timed )
    
    
    4 - Head on which to perform seek test
    
          Type:    Unsigned 8-bit value
    
          Range:   0 to 0xFF
    
          Default: 0
    

  <b><i><u>Output Data:</u></i></b>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    

  <b><i><u>Revision History:</u></i></b>
<a name="BUTTERFLY_SEEK_TEST_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="CHANGE_DIAG_LEVEL_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Change Diagnostic Command Level"></a><hr align=left width="75%"><b> Change Diagnostic Command Level (All Levels '/')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command selects the specified Diagnostic Level.

  <b><i><u>Quick Help:</u></i></b>
<a name="CHANGE_DIAG_LEVEL_QUICK_HELP"></a>
    "ChangeDiagLevel, /[Level]";

  <b><i><u>Input Parameters:</u></i></b>
    0 - New Diagnostic Level.

        This parameter specifies the new Diagnostic Command Level to be selected.  The
        following Diagnostic Command Levels are currently supported:

             1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F, G, H, I, L and T

        Optionally, the new level can be followed by a Diagnostic Command for the specified
        level.  In this case, the new level will be selected and the specified command will
        be executed.  Parameters 1, 2, 3, etc. will specify Parameters 0, 1, 2, etc. of the
        Diagnostic Command.  For example, entering "/2S200,0" at the diagnostic prompt
        "F3 1>"

                                     F3 1>/2S200,0
                                     F3 2>

        will change the diagnostic level from 1 to 2, seek to cylinder 200 head 0 and leave
        the diagnostic level set to 2.

          Type:    ASCII character

          Range:   A single ASCII character

          Default: Level T

  <b><i><u>Output Data:</u></i></b>
    The Diagnostic Level is displayed followed by the command prompt.

  <b><i><u>Revision History:</u></i></b>
<a name="CHANGE_DIAG_LEVEL_REVISION_HISTORY"></a>
    0001.0000   Initial revision.

<a name="CHANNEL_TEMPERATURE_ADJUSTMENT_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Channel Temperature Adjustment"></a><hr align=left width="75%"><b> Channel Temperature Adjustment (Level 7 'U')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command tweaks the write power and fly height values based on the specified
    temperature value.

  <b><i><u>Quick Help:</u></i></b>
<a name="CHANNEL_TEMPERATURE_ADJUSTMENT_QUICK_HELP"></a>
    "ChannelTemperatureAdj, U[TweakTemperature],[Partition],[Hd],[Zone],[Opts]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="CHANNEL_TEMPERATURE_ADJUSTMENT_PARM"></a>
    0 - Tweak Temperature in degrees Celsius.
    
        This parameter specifies the temperature (in degrees Celsius) with which the
        write power and fly height are to be tweaked.
    
          Type:    Signed 8 bit value
    
          Range:   0 to 0xFF
    
          Default: None.  If this parameter is not entered, the current thermistor
                   temperature will be used.
    
    1 - Partition
    
        This parameter specifies the media partition on which the write power and
        fly height will be tweaked with the temperature.
    
             0x00 = User Partition
             0x01 = System Partition
             0x10 = User Partition
             0x20 = System Partition
    
          Type:    Unsigned 8-bit value
    
          Range:   0, 1, 10 hex or 20 hex
    
          Default: 0
    
    2 - Head
    
        This parameter specifies the head or heads to tweak the write power and fly
        height.  If parameter 2 is 0xFF, the write current and fly heigth will be
        tweaked on all heads in the zone or zones specified by parameter 3.  If
        parameter 2 is not entered, the write current and fly height values will be
        tweaked on the current head in the zone or zones specified by parameter 3.
    
          Type:    Unsigned 8-bit value
    
          Range:   Defined by RAP.
    
          Default: None
    
    3 - Zone
    
        This parameter specifies the zone or zones to tweak the write power and fly
        height.  If parameter 3 is 0xFF, the write current and fly height will be
        tweaked in all zones on the head or heads specified by parameter 2.  If
        parameter 3 is not entered, the write current and fly height values will be
        tweaked in the current zone on the head or heads specified by parameter 2.
    
          Type:    Unsigned 8-bit value
    
          Range:   Defined by RAP.
    
          Default: None
    
    4 - Channel Temperature Adjustment Option.
    
        This parameter is a bit significant value that specifies how the channel
        temperature adjustment are to be applied.  The bits are defined as follows:
    
            Bits 15-2: not used
    
            Bit 1: Disable Heater Value Tweak.
    
                   If this bit is equal to 1, the read heat, write heat and preheat
                   will not be tweaked with the temperature.  However the heat values
                   in the working memory will be updated with the value from the RAP
                   in the memory.  If this bit is equal to 0, the heat values will be
                   tweaked with the tmeperature.
    
            Bit 0: Disable Write Power Tweak.
    
                   If this bit is equal to 1, the write current, write current damping
                   and write current damping duration will not be tweaked with the
                   temperature.  However the write power in the working memory will be
                   updated with the value from the RAP in the memory.  If this bit is
                   equal to 0, the write power will be tweaked with the tmeperature.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: 0 (Enable Write Power Tweak)
    

  <b><i><u>Output Data:</u></i></b>
<a name="TWEAK_WRITE_POWER_DATA"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
        If no error occurred, the following will be displayed
    
              "Write Current = a"
              "Write Damping = b"
              "Write Damping Duration = c"
    
           where
    
              a is a hex value of write current
    
              b is a hex value of write damping
    
              c is a hex value of write damping duation
    
<a name="TWEAK_FLY_HEIGHT_VALUES_DATA"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
        If no error occurred, the following will be displayed
    
              "WL = a.bbbbbbsEscc"
              "dCT = d.ffffffsEsgg"
              "Read Fly Height = h.iiiiiisEsjj"
              "Write Fly Height = k.llllllsEsmm"
              "Preheat = hh, Write heat = hh, Read heat = hh"
    
           where
    
              a.bbbbbbsEscc is a floating point value for write loss
    
              d.ffffffsEsgg is a floating point value for delta clearance due to temperature
    
              h.iiiiiisEsjj is a floating point value for read fly height
    
              k.llllllsEsmm is a floating point value for write fly height
    
              hh are heater DAC values for preheat, write heat, and read heat
    

  <b><i><u>Revision History:</u></i></b>
<a name="CHANNEL_TEMPERATURE_ADJUSTMENT_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0001.0001   Added option bit 1 to directly use heat values from RAP without
                any tweaking.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="CONTACT_DETECT_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Contact Detect"></a><hr align=left width="75%"><b> Contact Detect (Level H 'b')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This commmand exercises a simple method of Delta PES contact detection.  The methodology is
    heavily leveraged from Self Test FW Test 35.

  <b><i><u>Quick Help:</u></i></b>
<a name="CONTACT_DETECT_QUICK_HELP"></a>
    "ContactDetect, b[Flags],[Revs],[BaselineRevs],[StartWedge],[A],[B],[C],[D],[E],[StartHt],[HtInc],\n\r"
    "[FixedPESThresh],[FilterDelta]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="CONTACT_DETECT_PARM"></a>
    0 - Flags
    
       Bit 0 Search Mode
          0 = Heater Only
          1 = Write+Heat
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: 0 indicates Heater only search
    
    1 - Number of iterations
    
        If entered, this parameter contains the number of Fast IO iterations (almost analogous to
        revolutions) to measure for contact detect measurement point.
    
          Type:    Unsigned 8-bit value
    
          Range:   0 to 0xFF
    
          Default: 50
    
    2 - Baseline iterations
    
        If entered, this parameter contains the number of Fast IO iterations (almost analogous to
        revolutions) to measure for contact detect baseline measurement.
    
          Type:    Unsigned 8-bit value
    
          Range:   0 to 0xFF
    
          Default: 50
    
    3 - Starting wedge
    
        This number is the starting wedge from Index.
    
          Type:    Unsigned 16-bit value
    
          Range:   0x0000 to 0xFFFF
    
          Default: 0
    
    4 - Fast IO "A" wedges
      
        This parameter specifies the "A" pre write/read number of wedges for Fast IO.
    
          Type:    Unsigned 16-bit value
    
          Range:   0x0000 to 0xFFFE
             Note there is a memory limitation on this value, this # wedges directly
             impacts memory set aside for Fast IO.
    
          Default: Scales with number of Servo wedges/track.
    
    5 - Fast IO "B" wedges
      
        This parameter specifies the "B" write/read number of wedges for Fast IO.
    
          Type:    Unsigned 16-bit value
    
          Range:   0x0000 to 0xFFFE
             Note there is a memory limitation on this value, this # wedges directly
             impacts memory set aside for Fast IO.
    
          Default: Scales with number of Servo wedges/track.
    
    6 - Fast IO "C" wedges
      
        This parameter specifies the "C" post write/read number of wedges for Fast IO.
    
          Type:    Unsigned 16-bit value
    
          Range:   0x0000 to 0xFFFE
             Note there is a memory limitation on this value, this # wedges directly
             impacts memory set aside for Fast IO.
    
          Default: Scales with number of Servo wedges/track.
    
    7 - Fast IO "D" wedges
      
        This parameter specifies the "D" secondary write/read number of wedges for Fast IO.
    
          Type:    Unsigned 16-bit value
    
          Range:   0x0000 to 0xFFFE
             Note there is a memory limitation on this value, this # wedges directly
             impacts memory set aside for Fast IO.
    
          Default: 0
    
    8 - Fast IO "E" wedges
      
        This parameter specifies the "E" post secondary write/read number of wedges for Fast IO.
    
          Type:    Unsigned 16-bit value
    
          Range:   0x0000 to 0xFFFE
             Note there is a memory limitation on this value, this # wedges directly
             impacts memory set aside for Fast IO.
    
          Default: 0
    9 - Starting heater DAC
    
        This number is the starting heater DAC.
    
          Type:    Unsigned 8-bit value
    
          Range:   0x00 to 0xFF
    
          Default: 0
    
    10 - Heater DAC coarse increment
    
        This number is the coarse heater DAC increment.
    
          Type:    Unsigned 8-bit value
    
          Range:   0x00 to 0xFF
    
          Default: 1
    
    11 - Fixed PES Threshold
    
        This number is the fixed PES threshold.
    
          Type:    Decimal float
    
          Range:   14 character entry
    
          Default: 0.05
    
    12 - Filter Delta
    
        This number is the filter delta.
    
          Type:    Unsigned 8-bit value
    
          Range:   0x00 to 0xFF
    
          Default: 70
    

  <b><i><u>Output Data:</u></i></b>
<a name="CONTACT_DETECT_STATUS"></a>
     If an error occurred, the following information will be displayed.
    
           "DiagError aaaaaaaa R/W Status c R/W Error dddddddd"
    
        where
    
           aaaaaaaa is the Diagnostic Error Code
    
           c is the status returned by the R/W subsystem
    
           dddddddd is the error code returned by the R/W subsystem
    
     If the Verbose Formatted ASCII Data Output Mode is selected:
    
        Bit 0:      Displays a legthy list of parameter initialization.
    Bits 31-1:      NA
    
     Standard display:
    
        Parameter setup
    
         Heater Only Search
         Revs aa
         BaselineRevs bb
         APreWrNumSvoWedges cccc
         BWrNumSvoWedges dddd
         CPostWrNumSvoWedges eeee
         DRdNumSvoWedges ffff
         EPostRdNumSvoWedges gggg
         HeaterStart hh
         HeaterIncr ii
         PesThreshold +j.jjjjjjE+j
         FilterDelta kk
    
     where
     
     aa, bb number of iterations of Fast IO measurements.
    
     cccc Fast IO "A" parameter.
    
     dddd Fast IO "B" parameter.
    
     eeee Fast IO "C" parameter.
    
     ffff Fast IO "D" parameter.
    
     gggg Fast IO "E" parameter.
    
     hh Heater Start.
    
     ii Heater Increment.
    
     +j.jjjjjjE+j Fixed PES Threshold.
    
     kk Filter Delta window.
    
        Contact Detect loop
    
         State DAC dPESSigma
         a,    bb, c
         a,    bb, c
         a,    bb, c
         a,    bb, c
         a,    bb, c
         a,    bb, c
         a,    bb, c
    
     where
     
     a Contact Detect loop state, defined as:
        S searching
        DC contact detected
        DV contact verified
    
     bb Current heater DAC.
    
     c dPES variance, displayed as Scientific Notation floating point value.
     
        Test Summary ffff
    
         L,
         Zone aa
         Cyl bbbbbbbb
         Hd cc
         Freq dddd
         IW ee
         Ovs ee
         Dur ee
         ContactVar f
         ContactThresh g
         Clearance h
         Temp ii
    
         M,
         IW ee
         OVS ee
         OSD ee
         Read Heat jj
         Preheat jj
         Write Heat jj
    
     where
    
     aa Target zone.
    
     bbbbbbbb Target cylinder.
    
     cc Target head.
    
     dddd Frequency in MHz.
       
     ee Write powers.
    
     f Variance at contact.
    
     g Threshold of contact.
     
     h Calculated clearance at contact DAC.
    
     ii Current drive temperature.
    
     jj Heater values.
    

  <b><i><u>Revision History:</u></i></b>
<a name="CONTACT_DETECT_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0001.0001   Added new parameters:
                   Starting Heat
                   Coarse Heater Increment
                   Fixed PES Threshold
                   Filter Delta
    0002.0000   Added new parameter Baseline Iterations.
                This addition lines up naturally with the Iterations parameter, hence all
                other parameters shifted down.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="CONVERT_TRACK_PERCENTAGE_TO_OFFSET_COUNT_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Convert Data Track Percentage To Servo Offset Count"></a><hr align=left width="75%"><b> Convert Data Track Percentage To Servo Offset Count (Level 2 'v')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command converts the specified data track percentage to a servo offset count for
    the current target track.

  <b><i><u>Quick Help:</u></i></b>
<a name="CONVERT_TRACK_PERCENTAGE_TO_OFFSET_COUNT_QUICK_HELP"></a>
    "ConvertTrackPercentageToOffsetCount, v[Percentage]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="CONVERT_TRACK_PERCENTAGE_TO_OFFSET_COUNT_PARM"></a>
    0 - Data Track Percentage.
    
        This parameter specifies the data track percentage for which the servo offset
        count is to be displayed.  It is in units of 0.1% of the data track width.  If
        this parameter is not entered, the offset count between track centers will be
        displayed.  For drives that implement V2BAR, this number will vary with radial
        position.
    
          Type:    Signed 16-bit value
    
          Range:   0x8000 to 0x7FFF
    
          Default: 0x3e8 (1000 decimal or 100% offtrack)
    

  <b><i><u>Output Data:</u></i></b>
<a name="SERVO_OFFSET_COUNT_DATA"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
        If no error occurred, the following information will be displayed.
    
              "Phy Cyl cccccccc Log Hd d Data Track Percentage eeee Servo Offset Count ffff Data Track Width wwww"
    
           where
    
              cccccccc is the physical cylinder address
    
              d is the logical head address
    
              eeee is the data track percentage
    
              ffff is the servo offset count that will move the head offtrack by the specified
                   percentage on the specified track.
    
              wwww is the width of a data track, in units of servo position. Q14 scaling,
                 so 0x4000 is the width of a data track at nominal TPI (before VTPI and warping)
    

  <b><i><u>Revision History:</u></i></b>
<a name="CONVERT_TRACK_PERCENTAGE_TO_OFFSET_COUNT_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0002.0000   Changed to use Q14 servo count, instead of old servo offset count.
                Output also changed to include data track width in Q14 servo counts.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="COPY_CORRECTION_BUFFER_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Copy Correction Buffer"></a><hr align=left width="75%"><b> Copy Correction Buffer (Level G 'C')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command copies the specified segment of the Correction Buffer to another
    place in the same buffer.

  <b><i><u>Quick Help:</u></i></b>
<a name="COPY_CORRECTION_BUFFER_QUICK_HELP"></a>
    "CopyCorrectionBuffer, C[SrcAddr],[DestAddr],[NumSyms]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="COPY_CORRECTION_BUFFER_PARM"></a>
    0 - Source Address Offset of Correction Buffer.
    
        This parameter specifies the source address offset of the correction buffer.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xffff,
    
          Default: 0
    
    1 - Destination Address Offset of Correction Buffer.
    
        This parameter specifies the destination address offset of the correction buffer.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xffff
    
          Default: 0
    
    2 - Symbol Count of Correction Buffer Units To Be Copied.
    
        This parameter specifies the count of the symbols in the correction buffer
        to be copied.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xffff
    
          Default: 0
    

  <b><i><u>Output Data:</u></i></b>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    

  <b><i><u>Revision History:</u></i></b>
<a name="COPY_CORRECTION_BUFFER_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="COPY_LOG_FILE_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Copy Log File"></a><hr align=left width="75%"><b> Copy Log File (Level L 'c')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command copies the specified source log file to the specified destination log file.

  <b><i><u>Quick Help:</u></i></b>
<a name="COPY_LOG_FILE_QUICK_HELP"></a>
    "CopyLogFile, C[SrcLog],[DestLog],[AppendOpt]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="COPY_LOG_FILE_PARM"></a>
    0 - Source Log Number.
    
        This parameter specifies the number of the log that is the source of the data to
        be copied.
    
        The following are the default or special log files supported by the diagnostics:
        0x0000: ACTIVE_ERROR_LOG_ID - Indicates the currently active error log.
        0x0001: ACTIVE_ASCII_LOG_ID - Indicates the currently active ASCII log.
        0x0002: ACTIVE_RW_STATISTICS_LOG_ID - Indicates the currently active R/W statistics log.
        0xFFFC: DEFAULT_ERROR_LOG_ID - Indicates the default error log.
        0xFFFD: DEFAULT_RW_STATISTICS_LOG_ID - Indicates the default R/W statistics log.
        0xFFFE: TEMPORARY_LOG_ID - This log is used internally for copy operations.
        0xFFFF: INVALID_LOG_ID - Indicates an invalid log.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: None
    
    1 - Destination Log Number.
    
        This parameter specifies the number of the log that is the destination of the data
        to  be copied.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: None
    
    2 - Append Source Log to Destination Log.
    
        If any value is entered for this parameter, the specified source log will be
        appended to the end of the specified destination log.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: None
    

  <b><i><u>Output Data:</u></i></b>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    

  <b><i><u>Revision History:</u></i></b>
<a name="COPY_LOG_FILE_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="CORRUPT_LBA_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Corrupt LBA"></a><hr align=left width="75%"><b> Corrupt LBA (Level 2 'o')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command corrupts blocks in User Area starting at the specified LBA (Logical
    Block Address) for the specified number of blocks. Each block will be corrupted by
    the specified number of bytes to corrupt. The location within the blocks where the
    corruption should occur is determined by the specified offset and option flag.  This
    Diagnostic command basically does Read Long operation, corrupt the Diag Read buffer
    then does Write Long operation with the corrupted Diag Read buffer.

  <b><i><u>Quick Help:</u></i></b>
<a name="CORRUPT_LBA_QUICK_HELP"></a>
    "CorruptLba, o[Lba],[NumBlocks],[NumBytes],[ByteOffset],[Flags]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="CORRUPT_LBA_INPUT_PARAMETER"></a>
    
    0 - LBA (Logical Block Address) Number.
    
        This parameter specifies the address of the first User Area LBA to corrupt.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to maximum User Area LBA
    
          Default: None
    
    
    1 - Number of Blocks To Corrupt
    
        This parameter specifies the number of consecutive blocks to corrupt.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: 1
    
    
    2 - Number of Bytes To Corrupt.
    
        This parameter specifies the number of bytes to be corrupted for each block.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xffff
    
          Default: None
    
    
    3 - Starting Byte Offset for Consecutive Corruption
    
        This parameter specifies the starting byte offset for consecutive corruption.
        This parameter is valid only when lower 4 bits of the parameter 4 are all 0.
        Consecutive bytes starting from the byte offset specified by this parameter
        for the number of bytes specified by the parameter 2 will be corrupted.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xffff
    
          Default: 0
    
    4 - Options
    
        This parameter is a bit-significant value that specifies the following options
    
          Bits 15-5:  not used.
    
          Bit 4:      Enable ECC Correction for the Read Long operation part of the
                      Corrupt LBA diag command.
      
                      If this bit is set ECC Correction will be enabled for the read
                      long operation, else ECC Correction will be disabled.
    
          Bit 0-3:    Region Selector for Corruption
      
                      If this is 0 then consecutive bytes specified by parameter 2
                      and 3 will be corrupted.
                      
                      If this field is either 0xA, 0xD or 0xE then bytes at random byte
                      offsets will be corrupted by the number of bytes specified by the
                      parameter 2.
                      
                      If this is 0xA then user data region and ECC region will be corrupted.
                      If this is 0xD only data region will be corrupted.
                      If this is 0xE only ECC region will be corrupted.
    
          Type:    Unsigned 8-bit value
    
          Range:   0 to 0xFFFF
    
          Default: 0 (ECC Correction disabled, consecutive corruption selected)
    

  <b><i><u>Output Data:</u></i></b>
<a name="RW_OP_STATUS_OUTPUT_DATA"></a>
        If an error occurred, the following information will be displayed.
    
              "DiagError aaaaaaaa R/W Status c R/W Error dddddddd"
    
           and
    
              "Next User LBA eeeeeeee LLL CHS ffffff.g.hhhh PLP CHS iiiiii.j.kkkk"
              "Remaining Transfer Length llllllll"
    
           or
    
              "Next System LBA eeeeeeee LLL CHS ffffff.g.hhhh PLP CHS iiiiii.j.kkkk"
              "Remaining Transfer Length llllllll"
    
           where
    
              aaaaaaaa is the Diagnostic Error Code
    
              c is the status returned by the R/W subsystem
    
                    0 = R/W request completed successfully with error recovery
                    1 = R/W request completed successfully (no error recovery performed)
                    2 = R/W request failed
    
              dddddddd is the error code returned by the R/W subsystem
    
              eeeeeeee is the Disk Logical Block Address of the sector in error
    
              ffffff is the Logical Cylinder Address of the sector in error
    
              g is the Logical Head Address of the sector in error
    
              hhhh is the Logical Sector Address of the sector in error
    
              iiiiii is the Physical Cylinder Address of the sector in error
    
              j is the Logical Head Address of the sector in error
    
              kkkk is the Physical Sector Address of the sector in error
    
              llllllll is the number of sectors remaining to be read or written
    
        If the Verbose Formatted ASCII Data Output Mode is selected, the Verbose Mode option
        bits will enable the following data to be output when set.
    
           Bit 0:      Enables the R/W Status and R/W Error to be displayed
           Bit 1:      Enable the Next Address to be displayed
           Bit 2:      Enables the Track Position and Track Follow Offset to be displayed
           Bit 3:      Enables the Target Address to be displayed
           Bit 4:      Enables the Recovery Status to be displayed
           Bit 5:      Enables the Fault Status to be displayed
           Bit 6:      Enables the Elapsed Time to be displayed
           Bits 31-7:  NA
    
        If Bit 0 is set, the R/W Status and R/W Error will be displayed even if no error
        occurred.  The data displayed will be formatted as shown above.
    
        If Bit 1 is set, the Next Address will be displayed even if no error occurred.  The
        data displayed will be formatted as shown above.
    
        If Bit 2 is set, the Track Position and Track Follow Offset will be displayed as
        follows.
    
              "Read Position, Persistent Offset m.m% Total Offset n.n%"          or
              "Write Position, Persistent Offset m.m% Total Offset n.n%"         or
              "Write Header Position, Persistent Offset m.m% Total Offset n.n%"
    
           where
    
              m.m is the Persistent Track Follow Offset in units of percentage of track width
    
              n.n is the Total Track Follow Offset in units of percentage of track width
    
        If Bit 3 is set, the Target Address will be displayed as follows.
    
              "Target User LBA pppppppp LLL CHS qqqqqq.r.ssss PLP CHS tttttt.u.vvvv"
              "Starting Transfer Length wwwwwwww"
    
           or
    
              "Target System LBA pppppppp LLL CHS qqqqqq.r.ssss PLP CHS tttttt.u.vvvv"
              "Starting Transfer Length wwwwwwww"
    
           where
    
              pppppppp is the starting Disk Logical Block Address
    
              qqqqqq is the starting Logical Cylinder Address
    
              r is the starting Logical Head Address
    
              ssss is the starting Logical Sector Address
    
              tttttt is the starting Physical Cylinder Address
    
              u is the starting Logical Head Address
    
              vvvv is the starting Physical Sector Address
    
              wwwwwwww is the starting Transfer Length
    
        If Bit 4 is set, the Recovery Status will be displayed as follows.
    
              "Recovered User LBA AAAAAAAA LLL CHS BBBBBB.C.DDDD PLP CHS EEEEEE.F.GGGG"
              "Recovery Flags HHHH Count II"
    
           or
    
              "Recovered System LBA AAAAAAAA LLL CHS BBBBBB.C.DDDD PLP CHS EEEEEE.F.GGGG"
              "Recovery Flags HHHH Count II"
    
           where
    
              AAAAAAAA is the Disk Logical Block Address of the last recovered sector
    
              BBBBBB is the Logical Cylinder Address of the last recovered sector
    
              C is the Logical Head Address of the last recovered sector
    
              DDDD is the Logical Sector Address of the last recovered sector
    
              EEEEEE is the Physical Cylinder Address of the last recovered sector
    
              F is the Logical Head Address of the last recovered sector
    
              GGGG is the Physical Sector Address of the last recovered sector
    
              HHHH are the Recovery Flags reported by the Read/Write code
    
              II is the Recovery Count reported by the Read/Write code
    
        If Bit 5 is set, the Fault Status will be displayed as follows.
    
              "Drive Fault Status JJJJ Preamp Fault Status KKKK"
    
           where
    
              JJJJ is the Drive Fault Status reported by the Read/Write code
    
              KKKK is the Preamp Fault Status reported by the Read/Write code
    
        If Bit 6 is set, the Elapsed Time for the read/write operation will be displayed.
<a name="ELAPSED_TIME"></a>
    
       "Elapsed Time a mins b secs"  or
       "Elapsed Time b.c secs"       or
       "Elapsed Time c.d msecs"
    
    where
    
       a is minutes
       b is seconds
       c is milliseconds
       d is microseconds
    
    

  <b><i><u>Examples:</u></i></b>
    Example #1:
       To corrupt a single LBA at byte offsets from 0 to 0xF
       (in this case LBA at 0x51237)
 
          F3 2>o51237,,10
          or
          F3 2>o51237,1,10,0,0

    Example #2:
       To corrupt multiple LBAs at byte offsets from 0x100 to 0x11F for each block
       (in this case LBAs from 0x51237 to 0x51247)
 
          F3 2>o51237,11,20,100
          or
          F3 2>o51237,11,20,100,0
 
    Example #3:
       To corrupt a single LBA at 16 random byte offsets within data and ECC region
       (in this case LBA at 0x51237)
 
          F3 2>o51237,,10,,A
          or
          F3 2>o51237,1,10,,A
 

    Example #4:
       To corrupt a single LBA at 32 random byte offsets within data region only
       (in this case LBA at 0x51237)
 
          F3 2>o51237,,20,,D
          or
          F3 2>o51237,1,20,,D

    Example #5:
       To corrupt a single LBA at 48 random byte offsets within ECC region only
       (in this case LBA at 0x51237)
 
          F3 2>o51237,,30,,E
          or
          F3 2>o51237,1,30,,E

    To enable ECC correction for the Read Long operation before corrupting the buffer
    add 0x10 to the parameter 4.
 
    Example #6:
       To corrupt a single LBA at byte offsets from 0x30 to 00x37 with ECC correction enabled
       (in this case LBA at 0x51237)
 
          F3 2>o51237,,8,30,10
          or
          F3 2>o51237,1,8,30,10

    Example #7:
       To corrupt a single LBA at 32 random byte offsets within data region only
       with ECC correction enabled
       (in this case LBA at 0x51237)
 
          F3 2>o51237,,20,,1D
          or
          F3 2>o51237,1,20,,1D

  <b><i><u>Revision History:</u></i></b>
<a name="CORRUPT_LBA_REVISION_HISTORY"></a>
    0001.0000   Initial revision.

<a name="CREATE_LOG_FILE_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Create Log File"></a><hr align=left width="75%"><b> Create Log File (Level L 'c')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command creates the specified log file.

  <b><i><u>Quick Help:</u></i></b>
<a name="CREATE_LOG_FILE_QUICK_HELP"></a>
    "CreateLogFile, c[Log],[LogType],[BufferOrDiskOpt],[NumBytes]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="CREATE_LOG_FILE_PARM"></a>
    0 - Log Number.
    
        This parameter specifies the number that will be associated with the log that
        is to be created.
    
        The following are the default or special log files supported by the diagnostics:
        0x0000: ACTIVE_ERROR_LOG_ID - Indicates the currently active error log.
        0x0001: ACTIVE_ASCII_LOG_ID - Indicates the currently active ASCII log.
        0x0002: ACTIVE_RW_STATISTICS_LOG_ID - Indicates the currently active R/W statistics log.
        0xFFFC: DEFAULT_ERROR_LOG_ID - Indicates the default error log.
        0xFFFD: DEFAULT_RW_STATISTICS_LOG_ID - Indicates the default R/W statistics log.
        0xFFFE: TEMPORARY_LOG_ID - This log is used internally for copy operations.
        0xFFFF: INVALID_LOG_ID - Indicates an invalid log.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: None
    
    1 - Log Type.
    
        This parameter specifies the type of log file to be created.
    
             0 = Error Log
             1 = ASCII Log
             2 = Read/Write Statistics Log
    
          Type:    Unsigned 8-bit value
    
          Range:   0 to 2
    
          Default: None
    
    2 - Buffer or Disc Log.
    
        This parameter specifies whether the log file is to be stored in the data buffer
        or on the disc.
    
             0 = Buffer Log
             1 = Disc Log
    
          Type:    Unsigned 8-bit value
    
          Range:   0 to 1
    
          Default: None
    
    3 - Log Size in bytes.
    
        This parameter specifies the size, in bytes, of the log file to be created.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: None
    

  <b><i><u>Output Data:</u></i></b>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    

  <b><i><u>Revision History:</u></i></b>
<a name="CREATE_LOG_FILE_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="DECREMENT_RW_SCOPE_SYNC_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Decrement Read/Write Scope Sync"></a><hr align=left width="75%"><b> Decrement Read/Write Scope Sync (Online '<')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command decrements the number of the Servo Wedge for which the Scope Sync Pulse
    will be generated.

  <b><i><u>Quick Help:</u></i></b>
<a name="DECREMENT_RW_SCOPE_SYNC_QUICK_HELP"></a>
    "DecRwScopeSync";

  <b><i><u>Input Parameters:</u></i></b>
    None

  <b><i><u>Output Data:</u></i></b>
<a name="SCOPE_SYNC_DATA"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
        If no error occurred, the following information will be displayed.
    
              "                  Burst cccc"
    
           where
    
              cccc is the current Scope Sync Wedge number
    

  <b><i><u>Revision History:</u></i></b>
<a name="DECREMENT_RW_SCOPE_SYNC_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="DELETE_LOG_FILE_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Delete Log File"></a><hr align=left width="75%"><b> Delete Log File (Level L 'd')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command deletes the specified log file.

  <b><i><u>Quick Help:</u></i></b>
<a name="DELETE_LOG_FILE_QUICK_HELP"></a>
    "DeleteLogFile, d[Log]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="DELETE_LOG_FILE_PARM"></a>
    0 - Log Number.
    
        This parameter specifies the number of the log to be deleted.
    
        The following are the default or special log files supported by the diagnostics:
        0x0000: ACTIVE_ERROR_LOG_ID - Indicates the currently active error log.
        0x0001: ACTIVE_ASCII_LOG_ID - Indicates the currently active ASCII log.
        0x0002: ACTIVE_RW_STATISTICS_LOG_ID - Indicates the currently active R/W statistics log.
        0xFFFC: DEFAULT_ERROR_LOG_ID - Indicates the default error log.
        0xFFFD: DEFAULT_RW_STATISTICS_LOG_ID - Indicates the default R/W statistics log.
        0xFFFE: TEMPORARY_LOG_ID - This log is used internally for copy operations.
        0xFFFF: INVALID_LOG_ID - Indicates an invalid log.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: None
    

  <b><i><u>Output Data:</u></i></b>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    

  <b><i><u>Revision History:</u></i></b>
<a name="DELETE_LOG_FILE_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="DISABLE_ENABLE_SERVO_ZAP_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Disable / Enable Servo ZAP coefficients and ZAP read"></a><hr align=left width="75%"><b> Disable / Enable Servo ZAP coefficients and ZAP read (Level 5 'd')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command disables / enables the servo from using the coefficients in the ZAP table.

  <b><i><u>Quick Help:</u></i></b>
<a name="DISABLE_ENABLE_SERVO_ZAP_QUICK_HELP"></a>
    "DisableEnableServoZap, d[ZapControlMode]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="DISABLE_ENABLE_SERVO_ZAP_PARM"></a>
    0 - ZAP Control Mode.
    
        If this parameter is not entered, the command will display the current ZAP control
        mode only without changing it.
    
        If this parameter is entered, the ZAP control mode will be set to this value with
        the meaning as the following:
           0: Disable ZAP coefficients
           1: Enable Write ZAP coefficients only with ZAP data from disk
           2: Enable both Read and Write ZAP coefficients with ZAP data from ZAP table
           3: Reserved for future use
           4: Enable Read ZAP coefficients only with ZAP data from disk
           5: Enable both Read and Write ZAP coefficients with ZAP data from disk
    
          Type:    Unsigned 8-bit value
    
          Range:   0 to 5
    
          Default: 0
    

  <b><i><u>Output Data:</u></i></b>
<a name="DISABLE_ENABLE_SERVO_ZAP_DATA"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
        If no error occurred, one of the follwing information will be displayed to indicate
        the current ZAP control mode
    
              ZAP control: No
              ZAP control: Write ZAP from disc
              ZAP control: Read/Write ZAP from table
              ZAP control: Reserved
              ZAP control: Read ZAP from disc
              ZAP control: Read/Write ZAP from disc
    

  <b><i><u>Revision History:</u></i></b>
<a name="DISABLE_ENABLE_SERVO_ZAP_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="DISPLAY_ACTIVE_STATUS_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Display Active Status"></a><hr align=left width="75%"><b> Display Active Status (Online '.')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    The Display Active Status command displays the drives's active status information.

  <b><i><u>Quick Help:</u></i></b>
<a name="DISPLAY_ACTIVE_STATUS_QUICK_HELP"></a>
    "DisplayActiveStatus";

  <b><i><u>Input Parameters:</u></i></b>
    None

  <b><i><u>Output Data:</u></i></b>
<a name="ACTIVE_STATUS"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
        If no error occurred and the current Read/Write Sector Address is in the User Area,
        the following information will be displayed.
    
              "Current User LBA cccccccc LLL CHS dddddd.e.ffff PLP CHS gggggg.h.iiii"
              "R/W Status j R/W Error kkkkkkkk lll...l"
    
        If no error occurred and the current Read/Write Sector Address is in the User Area,
        the following information will be displayed.
    
              "Current System LBA cccccccc LLL CHS dddddd.e.ffff PLP CHS gggggg.h.iiii"
              "R/W Status j R/W Error kkkkkkkk lll...l"
    
           where
    
              cccccccc is the current Read/Write Disk Logical Block Address
    
              dddddd is the current Read/Write Logical Cylinder Address
    
              e is the current Read/Write Logical Head Address
    
              ffff is the current Read/Write Logical Sector Address
    
              gggggg is the current Read/Write Physical Cylinder Address
    
              h is the current Read/Write Logical Head Address
    
              iiii is the current Physical Sector Address
    
              j is the sense status returned by the R/W subsystem for the last operation
    
              kkkkkkkk is the error code returned by the R/W subsystem for the last operation
    
              lll...l is a string that indicates whether or not the drive is currently ready
    

  <b><i><u>Revision History:</u></i></b>
<a name="DISPLAY_ACTIVE_STATUS_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="DISPLAY_ASCII_CMD_INFO_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Display ASCII Command Information"></a><hr align=left width="75%"><b> Display ASCII Command Information (Level C 'Q')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command displays the revision of the specified ASCII serial port diagnostic
    command.

  <b><i><u>Quick Help:</u></i></b>
<a name="DISPLAY_ASCII_CMD_INFO_QUICK_HELP"></a>
    "DisplayAsciiCmdInfo, Q[CmdLevel],[Cmd]";

  <b><i><u>Input Parameters:</u></i></b>
    0 - Diagnostic Command Level.

        This parameter specifies the Diagnostic Command Level of the ASCII Serial Port
        Diagnostic Command for which the revision is to be displayed.  Entering a value
        of '0' selects the All Level commands.  Entering a value of '^' selects the
        Online commands.
     
          Type:    ASCII character

          Range:   Any printable ASCII character

          Default: None.  If this parameter is not entered, the revision of all supported
                   ASCII commands in all supported command levels will be displayed.

    1 - Diagnostic Command.

        This parameter specifies the ASCII Diagnostic Command for which the revision
        is to be displayed.

        If the Online commands are selected by entering a '^' for Parameter 0 and an
        upper or lower case alphabetic character is entered for this parameter, it
        will be interpreted as a control character.  For example, if '^' is entered for
        Parameter 0 and 'C' is entered for Parameter 1, the revision of the online
        Control-C command will be displayed.
     
          Type:    ASCII character

          Range:   Any printable ASCII character

          Default: None.  If this command is not entered, the revision of all supported
                   ASCII commands in the level specified by Parameter 0 will be displayed.

  <b><i><u>Output Data:</u></i></b>
<a name="ASCII_CMD_INFO"></a>
    For each command specified, the following is displayed:
    
       Level LL 'CC': Rev XXXX.YYYY, RRRRRR, SSSSSS
          or
       All Levels LL 'CC': Rev XXXX.YYYY, RRRRRR, SSSSSS
          or
       Online LL 'CC': Rev XXXX.YYYY, RRRRRR, SSSSSS
    
    Where:
       LL     = Command Level
       CC     = Command Character
       XXXX   = Major Revision Number
       YYYY   = Minor Revision Number
       RRRRRR = "Overlay" or "Flash"
       SSSSSS = Command help string
    

  <b><i><u>Revision History:</u></i></b>
<a name="DISPLAY_ASCII_CMD_INFO_REVISION_HISTORY"></a>
    0001.0000   Initial revision.

<a name="DISPLAY_BATCH_FILE_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Display Batch File"></a><hr align=left width="75%"><b> Display Batch File (Level 6 'D')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command displays the contents of the specified Diagnostic Batch File.  A Batch
    File is sequence of ASCII Diagnostic Commands entered by the user via the serial port
    interface.

  <b><i><u>Quick Help:</u></i></b>
<a name="DISPLAY_BATCH_FILE_QUICK_HELP"></a>
    "DisplayBatchFile, D[BatchFileNum]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="DISPLAY_BATCH_FILE_PARM"></a>
    0 - Batch File Number.
    
        This parameter specifies the number of the Batch File to be displayed.
        
          Type:    Unsigned 8-bit value
    
          Range:   0 t0 0xFF
    
          Default: 0
    

  <b><i><u>Output Data:</u></i></b>
    Displays the ASCII Serial Port Command sequence contained in the Batch File.

  <b><i><u>Revision History:</u></i></b>
<a name="DISPLAY_BATCH_FILE_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="DISPLAY_CONGEN_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Display Congen"></a><hr align=left width="75%"><b> Display Congen (Online Control U)</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command displays the Congen information.

  <b><i><u>Quick Help:</u></i></b>
<a name="DISPLAY_CONGEN_QUICK_HELP"></a>
    "DisplayCongen";

  <b><i><u>Input Parameters:</u></i></b>
    None

  <b><i><u>Output Data:</u></i></b>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    

    If no error occurred, the Congen data will be displayed as follows:
<a name="RAW_CONGEN_DATA"></a>
    
    F3 T>
           00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
     0000: A8 5C 00 00 00 08 53 43 68 00 00 00 01 10 01 00
     0010: 00 00 00 00 00 00 0B 00 01 00 0A 00 82 00 00 00
     0020: 03 00 16 00 8E 00 00 00 04 00 16 00 A6 00 00 00
     0030: 07 00 0A 00 BE 00 00 00 08 00 12 00 CA 00 00 00
     0040: 0A 00 0A 00 DE 00 00 00 1A 00 0A 00 EA 00 00 00
     0050: 3A 00 26 00 F6 00 00 00 00 00 16 00 1E 01 00 00
     0060: DC 01 0C 00 38 01 00 00 3E 00 DC 02 48 01 00 00
     0070: B4 03 00 00 01 10 00 00 00 00 00 00 06 00 01 00
     0080: 81 0A C0 08 FF 00 00 00 05 00 FF FF 83 16 0D BE
     0090: 00 00 00 0E 00 00 06 46 02 00 00 01 01 18 01 18
     00A0: 40 00 00 00 84 16 02 44 8A 02 00 00 00 00 00 00
     00B0: 00 00 00 00 00 00 00 00 1C 20 00 00 87 0A 00 08
     00C0: FF 00 00 00 00 00 FF FF 88 12 14 00 FF FF 00 00
     00D0: FF FF FF FF 80 20 00 00 00 00 00 00 8A 0A 02 00
     00E0: 00 00 00 00 00 00 00 00 9A 0A 00 02 00 00 00 05
     00F0: 00 00 00 04 BA 26 00 05 00 00 00 00 00 0A 00 00
     0100: 00 00 00 00 00 00 00 00 00 00 00 02 00 00 00 00
     0110: 00 00 00 00 00 00 00 00 00 00 00 00 80 16 30 32
     0120: 36 46 51 30 32 34 31 00 00 00 00 00 00 00 00 00
     0130: 01 37 03 40 DC 01 0C 00 01 00 00 18 00 02 00 00
     0140: 00 00 00 00 BE 00 DC 02 5A 0C FF 3F 37 C8 10 00
     0150: 00 00 00 00 3F 00 00 00 00 00 00 00 00 00 00 00
     0160: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
     0170: 00 00 00 40 04 00 20 20 20 20 20 20 20 20 53 54
     0180: 45 33 32 34 34 38 31 30 41 53 20 20 20 20 20 20
     0190: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20
     01A0: 20 20 20 20 20 20 10 00 00 00 20 2F 00 40 00 02
     01B0: 00 02 00 00 FF 3F 10 00 3F 00 10 FC FB 00 10 01
     01C0: FF FF FF 0F 00 00 07 04 23 00 78 00 78 00 78 00
     01D0: 78 00 00 00 00 00 00 00 00 00 00 00 00 00 1F 00
     01E0: 26 21 00 00 20 20 20 20 7E 20 1B 00 6B 34 01 7F
     01F0: 03 40 28 34 01 3C 03 40 7F 00 00 00 00 00 FE FE
     0200: FE FF 00 00 00 FE 00 00 00 00 00 00 00 00 00 00
     0210: 99 A9 6B 1C 00 00 00 00 00 00 00 00 00 00 00 00
     0220: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
     0230: 00 00 00 00 00 00 24 20 22 20 00 00 00 00 00 00
     0240: 00 00 00 00 00 00 00 00 21 00 00 00 00 00 00 00
     0250: 00 00 00 00 02 00 00 00 00 00 00 00 00 00 00 00
     0260: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
     0270: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
     0280: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
     0290: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
     02A0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
     02B0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
     02C0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
     02D0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
     02E0: 00 00 00 00 08 10 20 20 00 00 00 00 00 00 00 00
     02F0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
     0300: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
     0310: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
     0320: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
     0330: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
     0340: 00 00 00 00 00 00 00 00 0F 00 06 00 03 00 00 00
     0350: 32 00 14 00 33 00 24 00 0F 00 1E 00 32 00 00 00
     0360: 13 00 61 00 32 00 14 00 32 00 00 00 3A 00 00 00
     0370: 22 00 2D 00 32 00 00 00 32 00 00 00 32 00 00 00
     0380: 22 00 00 00 1A 00 00 00 12 00 00 00 10 00 00 00
     0390: 3E 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
     03A0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
     03B0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
     03C0: 00 00 40 4B 00 00 00 00 00 00 00 00 00 00 00 00
     03D0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
     03E0: 40 04 00 15 20 00 2C 01 00 00 00 00 99 A9 6B 1C
     03F0: 99 A9 6B 1C 00 A0 08 00 00 00 00 00 00 00 00 00
     0400: 00 00 00 00 00 00 00 00 00 00 00 00 D0 07 E8 03
     0410: 54 15 3C 00 00 26 00 00 00 00 08 00 00 00 00 00
     0420: 00 00 00 00 00 00 00
    
               DriveNativeInfo Mode Page
                  DriveNativeInfo Group
    Byte:011E:       PartNumber = 30 32 36 46 51 30 32 34 31
                     '026FQ0241'
    Byte:0127:       PartNumberWhitespacePad = 00 00 00 00 00 00 00 00
                     ''
    Byte:012F:       PartNumberPad = 00
    Byte:0130:       ProcessControlVersion = 01 37
    Byte:0132:       CongenConfigurationState = 03
    Byte:0133:       WrittenCount = 40
    
    Bytes Returned = 0.
    
    F3 T>
    

  <b><i><u>Revision History:</u></i></b>
<a name="DISPLAY_CONGEN_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="DISPLAY_CONTROLLER_REGS_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Display Controller Registers"></a><hr align=left width="75%"><b> Display Controller Registers (Online Control I)</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command displays the controller registers to the serial port.

  <b><i><u>Quick Help:</u></i></b>
<a name="DISPLAY_CONTROLLER_REGS_QUICK_HELP"></a>
    "DisplayControllerRegs";

  <b><i><u>Input Parameters:</u></i></b>
    None

  <b><i><u>Output Data:</u></i></b>
    The controller registers will be output as 16-bit values.  There are eight columns
    per block of registers.  For example:

        SATA Vis Mux Registers
      400a0600: 0000 0000 0000 0000 0000 0000 0000 0000
      400a0610: 0000 0000 0000 0000 0000 0000 0000 0000

    Currently, the register blocks output are as follows:
       SATA Core Registers
       SATA Vis Mux Registers
       SATA Test Mux Registers
       SATA SSIP / Phy Registers
       AT Registers
       Traverser Regs
       Host Data Manager Regs
       Disc Data Manager Registers
       PBM Memory Controller Registers

  <b><i><u>Revision History:</u></i></b>
<a name="DISPLAY_CONTROLLER_REGS_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="DISPLAY_CORRECTION_BUFFER_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Display Correction Buffer"></a><hr align=left width="75%"><b> Display Correction Buffer (Level G 'D')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command displays the specified segment of Correction Buffer with the expected
    data pattern.

  <b><i><u>Quick Help:</u></i></b>
<a name="DISPLAY_CORRECTION_BUFFER_QUICK_HELP"></a>
    "DisplayCorrectionBuffer, D[StartAddr],[EndAddr],[CompareData]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="DISPLAY_CORRECTION_BUFFER_PARM"></a>
    0 - Start Address Offset of Correction Buffer.
    
        This parameter specifies the start address offset of the correction buffer.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xffff,
    
          Default: 0
    
    1 - End Address Offset of Correction Buffer.
    
        This parameter specifies the end address offset of the correction buffer.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xffff
    
          Default: 0
    
    2 - Expected Data Pattern.
    
        This parameter specifies the expected pattern. The specified pattern is
        assumed to be right justified. If the value of the patten is greater than
        0x03FF, the command will take the lower 10 bits of the address as its
        pattern to compare with the data read from the Correction Buffer.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0x03ff
    
          Default: 0
    

  <b><i><u>Output Data:</u></i></b>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    

  <b><i><u>Revision History:</u></i></b>
<a name="DISPLAY_CORRECTION_BUFFER_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="DISPLAY_CURRENT_RD_CHANNEL_SETTINGS_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Display Current Read Channel Settings"></a><hr align=left width="75%"><b> Display Current Read Channel Settings (Online '!')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command displays the current value of the Read Channel, Preamp and Power ASIC
    registers.

  <b><i><u>Quick Help:</u></i></b>
<a name="DISPLAY_CURRENT_RD_CHANNEL_SETTINGS_QUICK_HELP"></a>
    "DisplayRdChannelRegs";

  <b><i><u>Input Parameters:</u></i></b>
    None

  <b><i><u>Output Data:</u></i></b>
<a name="RD_READ_CHANNEL_REG_DATA"></a>
    If a single Read Channel register was read, the following information will be displayed.
    
          "Read Channel Reg cccc = dddd"
    
       where
    
          cccc is the address of the register that was read
    
          dddd is the value that was read from the register
    
    If multiple Read Channel registers were read, the following information will be
    displayed.
    
        "Read Channel"
        "      0    1    2    3    4    5    6    7    8    A    B    C    D    E    F"
        "cccc: dddd dddd dddd dddd dddd dddd dddd dddd dddd dddd dddd dddd dddd dddd dddd"
    
       where
    
          cccc is the address of the first register in the row
    
          dddd is the value that was read from the register
    
<a name="RD_PREAMP_REG_DATA"></a>
    If a single Preamp register was read, the following information will be displayed.
    
          "Preamp Reg cc = dd"
    
       where
    
          cc is the address of the register that was read
    
          dd is the value that was read from the register
    
    If multiple Preamp registers were read, the following information will be displayed.
    
          "Preamp"
          "    0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F"
          "cc: dd dd dd dd dd dd dd dd dd dd dd dd dd dd dd dd"
    
       where
    
          cc is the address of the first register in the row
    
          dd is the value that was read from the register
    
<a name="RD_POWER_ASIC_REG_DATA"></a>
    If a single Power ASIC register was read, the following information will be displayed.
    
       "Power ASIC Reg cc = dddd"
    
       where
    
          cc is the address of the register that was read
    
          dddd is the value that was read from the register
    
    If multiple Power ASIC registers were read, the following information will be displayed.
    
       "Power ASIC"
       "    0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F"
       "cc: dddd dddd dddd dddd dddd dddd dddd dddd dddd dddd dddd dddd dddd dddd dddd dddd"
    
       where
    
          cc is the address of the first register in the row
    
          dddd is the value that was read from the register
    

  <b><i><u>Revision History:</u></i></b>
<a name="DISPLAY_CURRENT_RD_CHANNEL_SETTINGS_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="DISPLAY_DEFECT_LISTS_INFO_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Display Defect Lists"></a><hr align=left width="75%"><b> Display Defect Lists (Level T 'V')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command displays any combination of the user slip list, the system slip list, the
    servo flaws list, and the reassigned sectors table.

  <b><i><u>Quick Help:</u></i></b>
<a name="DISPLAY_DEFECT_LISTS_INFO_QUICK_HELP"></a>
    "DisplayDefectLists, V[DefectListSelect],[Hd],[StartCyl],[NumCyls],[DisplaySummaryOpt]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="DISPLAY_DEFECT_LISTS_INFO_PARM"></a>
    0 - Bit Select.
    
        This input specifies the bit select for the display:
    
          If bit 0 is set, the user track slip list will be displayed.  If bit 15 is also
          set, the entries will be displayed by index instead of cylinder/head.
    
          If bit 1 is set, the reserved track slip list will be displayed. If bit 15 is also
          set, the entries will be displayed by index instead of cylinder/head.
        
          If bit 2 is set (4), the alt list will be displayed.
    
          If bit 3 is set (8), the servo flaws list will be displayed.
    
          If bit 4 is set (10), the primary defect list ( PLIST ) will be displayed.  This
          list holds raw defect position information obtain during drive processing.
    
          If bit 5 is set (20), the primary servo flaws list will be displayed.
    
          If bit 6 is set (40), the nonresident G List will be displayed.  This PBA based list
          combines the previous nonresident G List with the resident G List at the time of the
          last format.
    
          If bit 7 is set (80), the resident G List will be displayed.  This PBA based list
          holds bad spares and defects found since the last format.  This list includes all
          bad PBAs found since format.  It will have more than one entry for a reallocated
          reallocation, for example.
    
          If bit 8 is set (100), the primary DST list will be displayed.  This list holds
          the defect position information from the PLIST (above) expressed as sector
          positions instead of SFI.
    
          If bit 15 is set, the user track slip list and the system track slip list will
          be displayed by entry index and entry count instead of cylinder range.
    
          Note: bits may be combined to display more than one list.
    
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: 0001
    
    1 - Chosen Head.
    
        If this input is entered then defects will display only for the specified head.
        If this input is not entered then defects for all heads will be displayed.
        If bit 15 is set in parameter zero ( Bit Select ), this parameter is ignored.
    
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: None (display all heads)
    
    2 - Start Element
    
       For the user track slip list and reserve track slip list,
         If bit 15 of parameter 0 (above) is set, Start Element is the index of the
         first element to be displayed.
    
         If bit 15 of parameter 0 (above) is clear, Start Element is the first cylinder
         of entries to be displayed.
    
       For the servo flaws list and primary servo flaws list, Start Element is the first
       cylinder of entries to be displayed.
    
       For the P List, Start Element is the first cylinder of entries to be displayed.
    
       For the G List Resident and GList Nonresident, Start Element is the lowest PBA of
       entries to be displayed.
    
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF  This value is not range checked and the user
                                    must use discretion selecting input values.
    
          Default: 0
    
    3 - Element Count
    
       For the user track slip list and reserve track slip list,
         If bit 15 of parameter 0 (above) is set, Element Count is the number of
         list entries to display.
    
         If bit 15 of parameter 0 (above) is clear, Element Count is the number of list
         elements to display.
    
       For the servo flaws list and primary servo flaws list, Element Count is the number
       of cylinders of entries to be displayed.
    
       For the P List, Element Count is the number of cylinders of entries to be displayed.
    
       For the G List Resident and GList Nonresident, Element Count is the number of PBAs of
       entries to be displayed.
    
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: 0
    
    4 - Display Summary
    
        If set to 99, this input causes a parser - friendly list summary to be
        displayed after all other output.  Works with V4 only.
    
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: None
    

  <b><i><u>Output Data:</u></i></b>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
<a name="SLIPS_DATA"></a>
    
    Slips Output Fields:
    
    LBA - LBA of first good sector AFTER slipped section
    
    Span - Length in sectors of slip
    
    Cumm - Cummulative length of all slips up to and including this slip
    
    Log cyl, hd, sctr, zn, phys cyl, phys sctr - These indicate the location of
          the first sector after slip. This address matches the LBA listed
          in the first column.  Note that physical head will equal the logical
          head.
    
    SFI - Symbols from index of the first sector after the slip.  The SFI corresponds
          to the LBA listed in the first column
    
    Slips Sample:
                                                                             
    F3 T>V8001,,10,6
      90EB43      2     11   881  1    D2   0    881    D4     5A52   90EB54
      90FB09      1     12   882  1   7FA   0    882   7FB     590E   90FB1B
      910230      1     13   883  1   682   0    883   683     59C6   910243
      910956      1     14   884  1   509   0    884   50A     5882   91096A
      91107D      1     15   885  1   391   0    885   392     5956   911092
      9117A4      1     16   886  1   219   0    886   21A     5A0E   9117BA
                                                                             
    Head 0: entries    22E        slips     1BBE
    Head 1: entries    187        slips      3B5
      Total Entries    3B5  Total Slips     1F73
                                                                             
    F3 T>V1,,881,6
     User Slip Defect List
                             log log   log     phys   phys
        LBA    span   cumm   cyl  hd  sctr zn   cyl   sctr     SFI      PBA
      90EB43      2     11   881  1    D2   0    881    D4     5A52   90EB54
      90FB09      1     12   882  1   7FA   0    882   7FB     590E   90FB1B
      910230      1     13   883  1   682   0    883   683     59C6   910243
      910956      1     14   884  1   509   0    884   50A     5882   91096A
      91107D      1     15   885  1   391   0    885   392     5956   911092
      9117A4      1     16   886  1   219   0    886   21A     5A0E   9117BA
                                                                             
    Head 0: entries    22E        slips     1BBE
    Head 1: entries    187        slips      3B5
      Total Entries    3B5  Total Slips     1F73
    
    Note that no header is displayed.
    
    F3 T>V2,0
     System Slip Defect List
                            log log   log      phys   phys
        LBA    span   cumm   cyl  hd  sctr zn   cyl   sctr     SFI
           0      0      0     0  0     0   0  24884     0 FFFFFFFF
       16688    268    268    96  0     0   1  2491A     0 FFFFFFFF
    
    Head 0: entries      2        slips      268
      Total Entries      2  Total Slips      268
    
    Note that SFI is not currently supported for the system area.
<a name="REASSIGNED_SECTORS_DATA"></a>
    F3 T>V4
    Reassigned Sectors List
    Original     New    log log   log     phy   phy
        LBA      PBA    cyl  hd  sctr zn  cyl   sctr     SFI
      7CD51F   7CD574    863  1   22C  0   863   22C    51F40     BBM
      7E89B0   7E8A05    87F  1   6E9  0   87F   6E9    14A6C     BBM
      8465B0   84662A    8E0  0   31A  0   8E0   31A    205CE     BBM
     36BA8AC  6B46255  -----  - -----  1  7343   1C5          ALT
     415B13A  6B46257  -----  - -----  1  7343   1C7          ALT
     4682DC6  4690DFC   4BD9  0   382  1  4BD9   382     950E     BBM
     980E2FA  A0911D4  -----  - -----  2  AE46   1E8          ALT
    10EC8C97 1359A486  -----  - -----  7 16368   18E          ALT
    14D8E9CF 1689E9C0  -----  - -----  9 1A9DF   10E          ALT
    159F54DE 1689E9BF  -----  - -----  9 1A9DF   10D          ALT
    16E84BE4 17E41B07  -----  - -----  A 1C9D8   139          ALT
    17DEECCE 196C0D2D  -----  - -----  B 1EFD9   153          ALT
    1858833F 1860FF31  1D5F2  0   20F  B 1D5F2   20F    744C8     BBM
    19E066FC 19E97E01  1FC8F  1   42B  C 1FC8F   42B    2AE93     BBM
    
             Alt   Pending  Total    Alted  Total
           Entries Entries Entries    Alts   Alts
    Head 0              3
    Head 1              3
    Total       8       6       E        3      B
    Checksum = E964
    
     The drive does not keep information about where an alt came from.
     Therefore LLLCHS and SFI are not available for slips, and the
     physical cylinder and physical sector refer to the new location in
     the spares.
    
    
     Possible flags in rightmost columns:
     ALT        sector has been reassigned
     BBM        sector is marked as untrustworthy (bad block mark)
     no write   sector is marked as should not be written
     no read    sector is makred as should not be read
     reported   (only with reallocation time stamping)
                sector has been reported to host
    
     The display summary option works as follows:
    F3 T>V4,,,,99
     Total Alt Entries:    0
     Total Alts of Alts:    0
     Total Alts:    0
     Total Pendings:   52
     Total Entries:   52
<a name="SERVO_FLAWS_DATA"></a>
    F3 T>V8
      Servo Flaws List
      log    log    phy
     head    cyl    cyl   wedge status
        2  8AA0  8AA0   C3   primary + deallocd
        2  A542  A542   C2   primary + deallocd
        2  A542  A542   C4   primary + deallocd
        2  A54A  A54A   2B   primary + deallocd
        3 15B28 15B28   34   primary + deallocd
        3 17057 17057   FD   primary + deallocd
        3 1BBED 1BBED   1C   primary + deallocd
        3 1BBED 1BBED   2F   primary + deallocd
        3 1C6CB 1C6CB   28   primary + deallocd
        3 1C6CB 1C6CB   2A   primary + deallocd
        3 25159 25159   B3   primary + deallocd
     Log head 0: entries        0
     Log head 1: entries        0
     Log head 2: entries        4
     Log head 3: entries        7
           Total Entries        B
<a name="PLIST_DATA"></a>
    F3 T>V10
     P List
      log   log    phy length
     head   cyl    cyl in symb  SFI  flags
       0   1A4D   1A4D   4B    8A2D1  2 TA
       1   1A4E   1A4E   49    8A2D1  1 servo
       0   1A4F   1A4F   4A    8A2D1  0
       1   1A50   1A50   4A    8A2D1  0
       1   1A51   1A51   48    8A2D1  0
       1   1A52   1A52   4B    8A2D1  0
       1   1A53   1A53   4B    8A2D1  0
    Head 0 Entries:   2
    Head 1 Entries:   5
      Total Entries:   7
<a name="PRIMARY_SERVO_FLAWS_DATA"></a>
    F3 T>V20
     Primary Servo Flaws List
      log   log    phy
     head   cyl    cyl wedge
       2   8AA0   8AA0   C3
       2   A542   A542   C2
       2   A542   A542   C4
       2   A54A   A54A   2B
       3  15B28  15B28   34
       3  17057  17057   FD
       3  1BBED  1BBED   1C
       3  1BBED  1BBED   2F
       3  1C6CB  1C6CB   28
       3  1C6CB  1C6CB   2A
       3  25159  25159   B3
    Head 0 Entries: 0
    Head 1 Entries: 0
    Head 2 Entries: 4
    Head 3 Entries: 7
     Total Entries: B
<a name="DEFECTIVE_SECTORS_TABLE_DATA"></a>
    F3 T>V40,0,0,20
    Nonresident GList                   5 entries returned
    Total entries available: 5
        PBA    Len  Flags  Phy Cyl Hd  PhySctr    SFI
           0    1      0        0   0      1      1F7
          3F    1      0        0   0     41     8164
        5290   19      0        9   0    36D   1032CD
       119C2    2      0       20   0     21    83B66
    1D48B830    1      0    201FD   0    591    7B12B
    
    Flags:
      RESERVED                1  This bit is reserved for internal use.
      POST_FORMAT_DEFECT      2  If set, this is a Post Format defect.
      DEFECTIVE_SPARE         4  If set, this is a defective spare.
      GROWN_TO_PRIMARY_LIST   8  If set, this defect came from a Glist to Plist merge.
    

  <b><i><u>Revision History:</u></i></b>
<a name="DISPLAY_DEFECT_LISTS_INFO_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0002.0000   Correct headers to servo flaws list and primary servo flaws list.
    0003.0000   Improve spacing of G List output.
    0004.0000   Make GLists (V40, V80) and primary DST list ( V100) default to displaying
                whole list.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="DISPLAY_DEFECTS_ON_CURRENT_TRACK_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Display Defects On Current Track"></a><hr align=left width="75%"><b> Display Defects On Current Track (Level 2 'i')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command displays the defecive sector information on the current Target Track.

  <b><i><u>Quick Help:</u></i></b>
<a name="DISPLAY_DEFECTS_ON_CURRENT_TRACK_QUICK_HELP"></a>
    "DisplayDefectsOnCurrentTrk, i";

  <b><i><u>Input Parameters:</u></i></b>
    None

  <b><i><u>Output Data:</u></i></b>
<a name="DEFECT_SECTOR_INFO"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
    
    If no error occurred, then the output of this command will be displayed as follows:
    
<a name="TRACK_INFO"></a>
    
       "Track Info:"
       "Partition PhyCyl   LogCyl   NomCyl   Radius_mils LogHd Zn FirstLba FirstPba LogSecs PhySecs WdgSkw SecPerFrm WdgPerFrm"
       "User      cccccccc dddddddd nnnnnnnn o.ooooooEoo ee    ff gggggggg hhhhhhhh iiii    jjjj    kkkk   llll      mmmm"        or
       "System    cccccccc dddddddd nnnnnnnn o.ooooooEoo ee    ff gggggggg hhhhhhhh iiii    jjjj    kkkk   llll      mmmm"
    
    where
    
       cccccccc          is the Logical Cylinder address where Logical Cylinders do not
                         include the cylinders in other partitions.
    
       dddddddd          is the Physical Cylinder address where Physical Cylinders
                         include User Area Cylinders, System Area Cylinders and Spare
                         Cylinders.
    
       ee                is the Logical Head address where Logical Heads do not
                         include heads that have been depopulated.
    
       ff                is the number of the zone that contains the track.
    
       gggggggg          is the first Logical Block Address (LBA) on the track.
    
       hhhhhhhh          is the first Physical Block Address (PBA) on the track.
    
       iiii              is the number of logical sectors on the track.
    
       jjjj              is the number of physical sectors on the track.
    
       kkkk              is the skew in wedges from index to the wedge that contains
                         physical sector 0.
    
       llll              is the number of physical sectors per frame.
    
       mmmm              is the number of wedges per frame.
    
       nnnnnnnn          is the Nominal Cylinder address where Nominal Cylinders
                         remove the VBAR scaling factor.
    
       o.ooooooEoo       is the Radius in milliinches as measured from the hub.
    
    
    "Sector Info:"
    
    "PhySec Wdg     PhySec Wdg    PhySec Wdg    PhySec Wdg"
      cccc  ddd     eeee   fff    gggg   hhh    iiii   jjj
      <The previous line is repeated until all defect sectors on the track are displayed>
    
    As shown above, the sector information is displayed in four columns.  The displayed
    information is defined as follows:
    
       cccc, eeee, gggg and iiii are the Physical Sector Address.
    
       ddd, fff, hhh and jjj are the number of the Servo Burst that preceeds the sector.
    

  <b><i><u>Revision History:</u></i></b>
<a name="DISPLAY_DEFECTS_ON_CURRENT_TRACK_REVISION_HISTORY"></a>
    0011.0000   Initial revision.

<a name="DISPLAY_DIAG_BUFFER_FILE_INFO_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Display Diagnostic Buffer Information"></a><hr align=left width="75%"><b> Display Diagnostic Buffer Information (Online '?')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    The Display Diagnostic Buffer Information command displays information about buffer
    memory used to process diagnostic requests.

  <b><i><u>Quick Help:</u></i></b>
<a name="DISPLAY_DIAG_BUFFER_FILE_INFO_QUICK_HELP"></a>
    "DisplayDiagBufferInfo";

  <b><i><u>Input Parameters:</u></i></b>
    None

  <b><i><u>Output Data:</u></i></b>
<a name="DIAG_BUFFER_FILE_INFO"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
        If no error occurred, the following information will be displayed for each Diagnostic
        Buffer File.
    
              "Blks cccccc-dddddd (eeeeee), BufAddr ffffffff-gggggggg, DBA hhhhhhhh, BytesPerBlk iii jjj...j";
    
           where
    
              cccccc is the number of the file's first buffer block
    
              dddddd is the number of the file's last buffer block
    
              eeeeee is the number of buffer blocks
    
              ffffffff is the buffer address of the file's first byte
    
              gggggggg is the buffer address of the file's last byte
    
              hhhhhhhh is the DBA address of the file's first byte
    
              iii is the number of bytes per block
    
              jjj...j is an ASCII string that is the file's name
    

  <b><i><u>Revision History:</u></i></b>
<a name="DISPLAY_DIAG_BUFFER_FILE_INFO_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="DISPLAY_DST_STATUS_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Display DST Status"></a><hr align=left width="75%"><b> Display DST Status (Online Control K and Online Control Y)</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command displays the status (percent complete, etc) of any current Drive
    Self Test (DST) activity.

  <b><i><u>Quick Help:</u></i></b>
<a name="DISPLAY_DST_STATUS_QUICK_HELP"></a>
    "DisplayDstStatus";

  <b><i><u>Input Parameters:</u></i></b>
    None

  <b><i><u>Output Data:</u></i></b>
<a name="DISPLAY_DST_STATUS_DATA"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
    
     Sample output shown below:
    
     Total process 8% complete
     50% of current test complete    <== NOTE: This line only appears on non-AT drives.
     2 out of 7 steps complete in current test
     Current operation is aborted.
     Current status  0
    

  <b><i><u>Revision History:</u></i></b>
<a name="DISPLAY_DST_STATUS_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="DISPLAY_EDIT_LOG_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Display / Edit Log"></a><hr align=left width="75%"><b> Display / Edit Log (Levels 2,3,4,7,A,T 'E')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command displays or modifies the specified Log File.

  <b><i><u>Quick Help:</u></i></b>
<a name="DISPLAY_EDIT_LOG_QUICK_HELP"></a>
    "DisplayEditLog, E[LogNum],[ErrCodeOrSpecialFuncKey],[SpecialFunc]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="DISPLAY_EDIT_LOG_PARM"></a>
    0 - Log Number.
    
        This parameter specifies the number of the log to be displayed.  If this
        parameter is not entered, the Active Error Log will be displayed.  If this
        parameter is equal to 0, the Active Error Log will be cleared.  If this
        parameter is entered and is not equal to 0, it specifies the number of the
        Log to be displayed.
    
        The following are the default or special log files supported by the diagnostics:
        0x0000: ACTIVE_ERROR_LOG_ID - Indicates the currently active error log.
        0x0001: ACTIVE_ASCII_LOG_ID - Indicates the currently active ASCII log.
        0x0002: ACTIVE_RW_STATISTICS_LOG_ID - Indicates the currently active R/W statistics log.
        0xFFFC: DEFAULT_ERROR_LOG_ID - Indicates the default error log.
        0xFFFD: DEFAULT_RW_STATISTICS_LOG_ID - Indicates the default R/W statistics log.
        0xFFFE: TEMPORARY_LOG_ID - This log is used internally for copy operations.
        0xFFFF: INVALID_LOG_ID - Indicates an invalid log.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: Display Active Error Log
    
    1 - Special Log Function Key or Display Error Code.
    
        If Parameter 2 is equal to 8, 20 hex, 100 hex, 200 hex or 400 hex, this parameter
        must be equal to AA hex to enable the special error log operation specified by
        Parameter 2.  If Parameter 2 is not equal to 8, 20 hex, 100 hex, 200 hex or 400 hex,
        only log entries with the Error Code specified by this parameter will be displayed.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: None
    
    2 - Select Special Log Function.
    
        This parameter selects the following special log functions.
    
          0x0004 - Display Number of Unused Log Bytes.
    
                   If Parameter 2 is equal to 4, the number of unused bytes in the log
                   specified by Parameter 0 will be displayed.
        
          0x0008 - Clear ASCII Log and update with entered data.
    
                   If Parameter 2 is equal to 8, the ASCII log will be cleared and ASCII data
                   entered from the serial port will be stored in the ASCII log.  When a
                   carriage return is entered, the ASCII log will be stored to the log number
                   specified by Parameter 0.
    
                   Note: When selecting this function, Parameter 1 must be equal to AA hex.
    
          0x0010 - Append data to end of ASCII Log.
    
                   If Parameter 2 is equal to 10 hex, ASCII data entered from the serial port
                   will be appended to the end of the ASCII log.  Entering a carriage return
                   terminates the ASCII data to be appended.
    
          0x0020 - Write Active Error Log to specified Log.
    
                   If Parameter 2 is equal to 20 hex, the Active Error Log will be written
                   to the log number specified by Parameter 0.
    
                   Note: When selecting this function, Parameter 1 must be equal to AA hex.
    
          0x0040 - Enable Fast Log Dump.
    
                   If Parameter 2 is equal to 40 hex, the Fast Log Dump will be enabled.
                   When Fast Log Dump is enabled, unformatted log data will be output and
                   the delay between log dumps will be disabled.
    
          0x0080 - Display Log Address.
    
                   If Parameter 2 is equal to 80 hex, the address of the specified log will
                   be displayed.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: None
    

  <b><i><u>Output Data:</u></i></b>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
    If no error occurred and the contents of an Error Log are being displayed,
<a name="ERROR_LOG_DATA"></a>
    
    "Log c Entries d"
    "Count DIAGERR  RWERR    LBA      LLL CHS         PLP CHS         Partition"
    "----- -------- -------- -------- --------------- --------------- ---------"
    "eeee  ffffffff hhhhhhhh iiiiiiii jjjjjjjj.k.llll mmmmmmmm.n.pppp q        "
    
    where
    
       c is the log number
    
       d is the number of valid log entries
    
       eeee is the number of times the error repeated
    
       ffffffff is the Diagnostic Error Code
    
       hhhhhhhh is the Read/Write Subsystem Error Code
    
       iiiiiiii is the LBA at which the error occurred
    
       jjjjjjjj is the Logical Cylinder Address at which the error occurred
    
       k is the Logical Head Address at which the error occurred
    
       llll is the Logical Sector Address at which the error occurred
    
       mmmmmmmm is the Physical Cylinder Address at which the error occurred
    
       n is the Logical Head Address at which the error occurred
    
       pppp is the Physical Sector Address at which the error occurred
    
       q is an ASCII String that indicates the  partition ( "System" or " User" )
         in which the error occurred
    
    If no error occurred and the contents of an ASCII Log are being displayed,
<a name="ASCII_LOG_DATA"></a>
    
    "Log c Entries d"
    
    (Followed by the ASCII data contained in log)
    
    where
    
       c is the log number
    
       d is the number of valid ASCII characters contained in the log
    
    If no error occurred and the contents of a Read/Write Statistics Log are
    being displayed,

       TBD

    If no error occurred and the number of unused log bytes is being displayed,
<a name="LOG_UNUSED_BYTES_DATA"></a>
    
    "Log e Number of Unused Bytes = ffffffff"
    
    where
    
       e is the number of the log whose starting address is being displayed
    
       ffffffff is the number of log bytes that are currently unused
    
    If no error occurred and the log address is being displayed,
<a name="LOG_ADDR_DATA"></a>
    
    "Log e Starting System Area LBA = ffffffff"      (for a Disc Log or)
    "Log e Starting Buffer Addr = gggggggg"          (for a Buffer Log)
    
    where
    
       e is the number of the log whose starting address is being displayed
    
       ffffffff is the starting System Area LBA of a disc log
    
       gggggggg is the starting Buffer Address of a buffer log
    

  <b><i><u>Revision History:</u></i></b>
<a name="DISPLAY_EDIT_LOG_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="DISPLAY_FIRMWARE_REV_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Display Firmware Revision"></a><hr align=left width="75%"><b> Display Firmware Revision (Online Control A)</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command displays the Firmware Revision of the drive.

  <b><i><u>Quick Help:</u></i></b>
<a name="DISPLAY_FIRMWARE_REV_QUICK_HELP"></a>
    "DisplayFirmwareRev";

  <b><i><u>Input Parameters:</u></i></b>
    None

  <b><i><u>Output Data:</u></i></b>
<a name="FIRMWARE_REV"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
        If no error occurred, the following information will be displayed.
    
<a name="FIRMWARE_PACKAGE_INFO_OUTPUT_DATA"></a>
    
    "Package Version: CCCCCC.CCCC.CCCCCC.CCCCCCCC, Package P/N: DDDDDDDDD, Package Builder ID: EE,...
     Package Build Date: MM-DD-YYYY, Package Build Time: HH:MM:SS, Package CFW Version: GGGG.GGGG.GGGGGG.GGGG,...
        Package SFW1 Version: IIII, Package SFW2 Version: JJJJ, Package SFW3 Version: KKKK, Package SFW4 Version: LLLL"
    
    where
    
       CCCCCC.CCCC.CCCCCC.CCCCCCCC is the Package Version Field.
    
       DDDDDDDDD is the Package Part Number Field.
    
       EE is the Package Builder ID Field.
    
       MM/DD/YYYY is the Package Build Date Field.
    
       HH:MM:SS is the Package Build Time Field.
    
       GGGG.GGGG.GGGGGG.GGGG is the Package CFW Component Version Field.
    
       IIII Package SFW Component 1 Version Field.
    
       JJJJ Package SFW Component 2 Version Field.
    
       KKKK Package SFW Component 3 Version Field.
    
       LLLL Package SFW Component 4 Version Field.
    
    example output:
        Package Version: MS1240.STD1.AA0502.STD10013, Package P/N: 100421943, Package Builder ID: C4,
        Package Build Date: 03/08/2007, Package Build Time: 151452, Package CFW Version: MS12.STD1.123456.B600,
        Package SFW 1 Version: B413, Package SFW 2 Version: C415, Package SFW 3 Version: ----, Package SFW 4 Version: ----
    
    A warning message may be printed which indicates that some of the Firmware Package information
    has been truncated. The most likely causes of this warning would be that Package information is
    invalid or that this diagnostic does not support the Firmware Package format returned by the drive.
    
    example output:
       Warning: Package Info truncation occurred.
       
    
<a name="CONTROLLER_FIRMWARE_REV_INFO"></a>
    
    "Controller FwRev CCCCCCCC, CustomerRel DDDDDD, Changelist EEEE, ProdType FFFF, Date GG/GG/GGGG, Time HHHHHH, UserId IIIIIIII";
    
    where
    
       CCCCCCCC is the Controller Firmware Revision.
    
       DDDD is the Customer Release number.
    
       EEEEEEEE is the Perforce Changelist Number.
    
       FFFF is the Product Type.
    
       GG/GG/GGGG is the date the code was built.
    
       HHHHHH is the time the code was built.
    
       IIIIIIII is the global ID of the person that built the code.
    
<a name="SERVO_FIRMWARE_REV"></a>
    
    "Servo FwRev CCCC
    
    where
    
       CCCC is the Servo Firmware Revision.
    
<a name="RAP_REV_INFO_OUTPUT_DATA"></a>
    
    "RAP FW Implementation Key: CC, RAP FormatRev DD, ContentsRev EE";
    
    where
    
       CC is the RAP FW Implemenation Key.
    
       DD is the RAP Format Revision.
    
       EE is the RAP Contents Revision.
    
    

  <b><i><u>Revision History:</u></i></b>
<a name="DISPLAY_FIRMWARE_REV_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0002.0000   Added Firmware Package Information to the DSB.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).
    0012.0000   Added RAP FW Implementation Key.

<a name="DISPLAY_LOG_FILE_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Display Log File"></a><hr align=left width="75%"><b> Display Log File (Level L 'D')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command displays the specified log file.

  <b><i><u>Quick Help:</u></i></b>
<a name="DISPLAY_LOG_FILE_QUICK_HELP"></a>
    "DisplayLogFile, D[Log],[ErrCode]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="DISPLAY_LOG_FILE_PARM"></a>
    0 - Log Number.
    
        This parameter specifies the number of the log to be displayed.  If a Log Number
        is not entered, the Active Error Log will be displayed.
    
        The following are the default or special log files supported by the diagnostics:
        0x0000: ACTIVE_ERROR_LOG_ID - Indicates the currently active error log.
        0x0001: ACTIVE_ASCII_LOG_ID - Indicates the currently active ASCII log.
        0x0002: ACTIVE_RW_STATISTICS_LOG_ID - Indicates the currently active R/W statistics log.
        0xFFFC: DEFAULT_ERROR_LOG_ID - Indicates the default error log.
        0xFFFD: DEFAULT_RW_STATISTICS_LOG_ID - Indicates the default R/W statistics log.
        0xFFFE: TEMPORARY_LOG_ID - This log is used internally for copy operations.
        0xFFFF: INVALID_LOG_ID - Indicates an invalid log.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: Active Error Log
    
    1 - Display Error Code.
    
        This parameter specifies the Diagnostic Error Code to be displayed.  Only log
        entries containing this error code will be displayed.  This parameter is only
        valid when displaying error log files.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: None
    

  <b><i><u>Output Data:</u></i></b>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    

  <b><i><u>Revision History:</u></i></b>
<a name="DISPLAY_LOG_FILE_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="DISPLAY_LOG_FILE_INFO_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Display Log File Information"></a><hr align=left width="75%"><b> Display Log File Information (Level L 'I')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command displays information about the specified log file.

  <b><i><u>Quick Help:</u></i></b>
<a name="DISPLAY_LOG_FILE_INFO_QUICK_HELP"></a>
    "DisplayLogFileInfo, I[Log]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="DISPLAY_LOG_FILE_INFO_PARM"></a>
    0 - Log Number.
    
        This parameter specifies the number of the log whose information is to be displayed.
        If a Log Number is not entered, the Active Error Log will be displayed.
    
        The following are the default or special log files supported by the diagnostics:
        0x0000: ACTIVE_ERROR_LOG_ID - Indicates the currently active error log.
        0x0001: ACTIVE_ASCII_LOG_ID - Indicates the currently active ASCII log.
        0x0002: ACTIVE_RW_STATISTICS_LOG_ID - Indicates the currently active R/W statistics log.
        0xFFFC: DEFAULT_ERROR_LOG_ID - Indicates the default error log.
        0xFFFD: DEFAULT_RW_STATISTICS_LOG_ID - Indicates the default R/W statistics log.
        0xFFFE: TEMPORARY_LOG_ID - This log is used internally for copy operations.
        0xFFFF: INVALID_LOG_ID - Indicates an invalid log.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: Active Error Log
    

  <b><i><u>Output Data:</u></i></b>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
    If no error occurred, the following information will be displayed.
<a name="LOG_FILE_INFO"></a>
    
    "Log c d"
    "e Log
    
    "Starting System Area LBA = ffffffff"      (for a Disc Log or)
    "Starting Buffer Addr = gggggggg"          (for a Buffer Log)
    
    "Log Bytes = h, Log Entry Bytes = i, Max Entries = j, Valid Entries = k"
    
    where
    
       c is the log number
    
       d is an ASCII string that specifies the log name
    
       e is an ASCII string that specifies the log location and type
    
       ffffffff is the starting System Area LBA of a disc log
    
       gggggggg is the starting Buffer Address of a buffer log
    
       h is the total size of the log file in bytes (including unused entries)
    
       i is the size of a log file entry, in bytes
    
       j is the maximum number of log entries
    
       k is the number of log entries that are currently valid
    

  <b><i><u>Revision History:</u></i></b>
<a name="DISPLAY_LOG_FILE_INFO_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="DISPLAY_MICRO_JOG_FOR_LOGICAL_CHS_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Display Micro Jog for Logical Cylinder and Head"></a><hr align=left width="75%"><b> Display Micro Jog for Logical Cylinder and Head (Level 4 'O')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    The Display Micro Jog Value for Logical CHS commmand seeks to the specified logical
    track, gets the track's micro jog value and displays it.  If no address is specified,
    this command will seek to the next logical track in the Test Space and display its
    micro jog value.

  <b><i><u>Quick Help:</u></i></b>
<a name="DISPLAY_MICRO_JOG_FOR_LOGICAL_CHS_QUICK_HELP"></a>
    "DisplayMicroJogForLogChs, O[LogCyl],[Hd],[Opts],[SysAreaOpt]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="DISPLAY_MICRO_JOG_AT_LOGICAL_CHS_PARM"></a>
    0 - Logical Cylinder Address.
    
        If Parameter 3 is entered, Parameter 0 is the address of the System Area logical
        cylinder for which the micro jog value is to be displayed.  If Parameter 3 is not
        entered, Parameter 0 is the address of the User Area logical cylinder for which the
        micro jog value is to be displayed.  If both Parameter 0 and 1 are not entered,
        the micro jog value will be displayed for the next logical track in the Test Space.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: None
    
    1 - Logical Head Address.
    
        This parameter is the address of the Logical Head for which the micro jog value
        is to be displayed.  If both Parameter 0 and 1 are not entered, the micro jog
        value will be displayed for the next logical track in the Test Space.
    
          Type:    Unsigned 8-bit value
    
          Range:   0 to 0xFF
    
          Default: None
    
    2 - Display Micro Jog options.
    
        This parameter is a bit-significant value that specifies various options for
        displaying the micro jog value.  The bits are defined as follows:
    
          bit 0: Disable Micro Jog Display
                   0 enables the micro jog value to be displayed
                   1 disables the micro jog value from being displayed
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: 0 (Micro Jog Display enabled)
    
    3 - System Area Flag.
    
        If any value is entered then Parameter 0 specifies a System Area logical cylinder,
        else it specifies a User Area logical cylinder.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: None
    

  <b><i><u>Output Data:</u></i></b>
<a name="MICRO_JOG_DATA"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
        If no error occurred and the track is in the User Area, the following information
        will be displayed.
    
              "User LBA cccccccc LLL CHS dddddd.e.ffff PLP CHS gggggg.h.iiii"
              "MR Offset = jjjj"
    
        If no error occurred and the track is in the System Area, the following information
        will be displayed.
    
              "System LBA cccccccc LLL CHS dddddd.e.ffff PLP CHS gggggg.h.iiii"
              "MR Offset = jjjj"
    
           where
    
              cccccccc is the Disk Logical Block Address
    
              dddddd is the Logical Cylinder Address
    
              e is the Logical Head Address
    
              ffff is the Logical Sector Address
    
              gggggg is the Physical Cylinder Address
    
              h is the Logical Head Address
    
              iiii is the Physical Sector Address
    
              jjjj is the MR Offset value for the track
    

  <b><i><u>Revision History:</u></i></b>
<a name="DISPLAY_MICRO_JOG_FOR_LOGICAL_CHS_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="DISPLAY_MODIFY_ADAPTIVE_PARM_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Display / Modify Adaptive Parameter"></a><hr align=left width="75%"><b> Display / Modify Adaptive Parameter (Level 2, 7 'I')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command is used to invoke the Read/Modify Adaptive Parameter subcommands.

  <b><i><u>Quick Help:</u></i></b>
<a name="DISPLAY_MODIFY_ADAPTIVE_PARM_QUICK_HELP"></a>
    "DisplayModifyAdaptiveParm, I,[GroupId]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="DISPLAY_MODIFY_ADAPTIVE_PARM_PARM"></a>
    0 - Not Used.
    
        Please see the other Read/Modify Adaptive Parameters commands for details regarding
        the use of this parameter.
    
          Type:    N/A
    
          Range:   N/A
    
          Default: None
    
    1 - P1 (Adaptive Parameter Group ID).
    
        This parameter specifies the ID of the Adaptive Parameter Group that contains
        the value to be displayed or modified.
    
<a name="ADAPTIVE_PARM_GROUP_IDS"></a>
          
          00 = CAP (Controller Adaptive Parameters)
          01 = RAP (Read / Write Adaptive Parameters)
          02 = SAP (Servo Adaptive Parameters)
          03 = RW Working Parameters (Read / Write Working Parameters)
          FF = Table of Contents (All allowable Group IDs)
          
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: 0
    

  <b><i><u>Output Data:</u></i></b>
    Please see each individual Read/Modify Adaptive Parameter subcommand for more details
    regarding its output data format.

  <b><i><u>Examples:</u></i></b>

    The following will present the Display/Modify Adaptives command's Table of Contents:

       F3 2>I,FF

  <b><i><u>Revision History:</u></i></b>
<a name="DISPLAY_MODIFY_ADAPTIVE_PARM_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0002.0000   Corrected Working Parameters display for Maintenance Heat.
    0002.0001   Added separate command and diagnostic files to handle the different adaptive
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).
                parameters.
    0011.0001   Added support for modifying/reading SAP Flex Bias Table and SAP Bias Hysteresis Table

<a name="DISPLAY_MODIFY_CAP_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Display / Modify CAP"></a><hr align=left width="75%"><b> Display / Modify CAP (Level 2, 7 'I,0')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command displays the values of the specified controller adaptive parameters.  (It
    does not currently support the modification of controller adaptive parameters.)

  <b><i><u>Quick Help:</u></i></b>
<a name="DISPLAY_MODIFY_CAP_QUICK_HELP"></a>
    "DisplayModifyCap, I[ParmValue],0,[ParmId]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="DISPLAY_MODIFY_CAP_INPUT_PARAMETER"></a>
    <font color=red>
     0 - P0 (New CAP Value).
    
         If this parameter is entered, the adaptive value specified by command
         parameter 2 will be set equal to the value of this parameter.
    
           Type:    Quote-delimited string or hex value
    
           Range:   1 to 255 character string or 0000 to FFFF (if hex value)
    
           Default: None
    
    </font>
     1 - P1 (CAP Group ID = 0).
    
         This parameter specifies the Group ID of the CAP, which is 0.
    
           Type:    Unsigned 32-bit value
    
           Range:   0 is the only valid value.
    
           Default: 0
    
    <font color=red>
     2 - P2 (CAP Value ID).
    
         This parameter specifies the ID of the CAP value to be displayed or modified.
         If Parameter 0 is not entered, entering a value of zero for  this parameter
         will display all of the parameters in the group CAP.
    
           Type:    Unsigned 32-bit value
    
           Range:   0 to 0xFFFFFFFF
    
           Default: 0
    
    </font>

  <b><i><u>Output Data:</u></i></b>
<a name="DISPLAY_MODIFY_CAP_OUTPUT_DATA"></a>
    If no error occurred and the CAP data is being displayed, the following is an example
    of the CAP data that will be displayed.
    
       (P1=00) CAP:
    
         Validation Key: FFFFFFFF
         HDA Serial Number: Invalid
         PCBA Serial Number: Invalid
         PCBA Part Number: Invalid
         Head Count: 01
         Node Name Validation Key: FF
         Node Name: FF FF FF FF FF FF FF FF
         Product Family ID: FF
         Product Family Member ID: 01
         PCBA Build Code: Invalid
         ASIC Info:
           00: FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
               FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
               FF FF FF
    
           01: FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
               FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
               FF FF FF
    
           02: FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
               FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
               FF FF FF
    
           03: FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
               FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
               FF FF FF
    
         Firmware Key: FF FF FF FF FF FF FF FF FF FF FF FF FF FF
         Firmware Key Checksum: FFFF
         Date of Manufacture: 10122002
         Destroked Buffer Size: FF
         Final Mfg Op: Invalid
         Final Mfg Erc: Undefined
         System Area Prep State: FF
         Checksum: FFFF
    

  <b><i><u>Examples:</u></i></b>

    To display the CAP:
       F3 2>I,0
       F3 2>I    <-- CAP is displayed by default for the "I" command.

  <b><i><u>Revision History:</u></i></b>
<a name="DISPLAY_MODIFY_CAP_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="DISPLAY_MODIFY_RAP_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Display / Modify RAP revision 02"></a><hr align=left width="75%"><b> Display / Modify RAP revision 02 (Level 2, 7 'I,1')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command displays and optionally modifies the value of the specified read adaptive
    parameter.

  <b><i><u>Quick Help:</u></i></b>
<a name="DISPLAY_MODIFY_RAP_QUICK_HELP"></a>
    "DisplayModifyRap, I[ParmValue],1,[ParmId],[P3],[P4],[P5],[P6],[UpdateOpts]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="DISPLAY_MODIFY_RAP_PARM"></a>
    0 - P0 (New RAP Value).
    
        If this parameter is entered, the adaptive value specified by command
        parameters 1 though 7 will be set equal to the value of this parameter.
        If this parameter is not entered, the RAP values specified by command
        parameters 1 and 2 will be displayed.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: None
    
    1 - P1 (RAP Group ID = 1).
    
        This parameter specifies the RAP ID (1).
    
          Type:    Unsigned 32-bit value
    
          Range:   1 is the only valid value.
    
          Default: NA
    
    2 - P2 (RAP Value ID).
    
        This parameter specifies the ID of the RAP value to be displayed or modified.
        If Parameter 0 is not entered, entering a value of zero for  this parameter
        will display all of the parameters in the group RAP.
    
<a name="RAP_PARM_IDS"></a>
          
          The Adaptive Parameter IDs and the values of parameters 3-6
          are defined as follows:
          
            0x00 = All RAP Parameters
          
                     Parameters 3-6 are not used
          
            0x01 = Drive Configuration
          
                     Parameters 3-6 are not used
          
            0x02 = Temperature Sensor Configuration
          
                     Parameters 3-6 are not used
          
            0x03 = Zone Configuration
          
                     Parameters 3-6 are not used
          
            0x04 = Tuned Drive parameters
          
                     Parameter 3 = Register Group
                     Parameter 4 = Register Index
                     Parameter 5 = not used
                     Parameter 6 = not used
          
            0x05 = Tuned Zone parameters
          
                     Parameter 3 = Register Group
                     Parameter 4 = Register Index
          
                     Parameter 5 = Zone Number
          
                         0x00 = User Zone 0
                         0x01 = User Zone 1
                                 .
                                 .
                                 .
                         0x80 = System Zone
          
                     Parameter 6 = not used
          
            0x06 = Tuned Head parameters
          
                     Parameter 3 = Head
                     Parameter 4 = Register Group
                     Parameter 5 = Register Index
          
                     Parameter 6 = Zone Number
          
                         0x00 = User Zone 0
                         0x01 = User Zone 1
                                 .
                                 .
                                 .
                         0x80 = System Zone
          
            0x07 = Zone Format Budget parameters
          
                     Parameter 3 = Zone Format Budget Parameter Index
          
                     Parameter 4 = Zone Number
          
                         0x00 = User Zone 0
                         0x01 = User Zone 1
                                 .
                                 .
                                 .
                         0x80 = System Zone
          
                     Parameter 5 = not used
                     Parameter 6 = not used
          
            0x08 = Head Format Budget parameters
          
                     Parameter 3 = Head
          
                     Parameter 4 = Zone Number
          
                         0x00 = User Zone 0
                         0x01 = User Zone 1
                                 .
                                 .
                                 .
                         0x80 = System Zone
          
                     Parameter 5 = not used
                     Parameter 6 = not used
          
            0x09 = TCC Preamp Temperature Point parameters
          
                     Parameters 3-6 are not used
          
            0x0A = TCC Preamp parameters
          
                     Parameter 3 = Head
                     Parameter 4 = TCC Preamp Parameter Index
          
                     Parameter 5 = Zone Number
          
                         0x00 = User Zone 0
                         0x01 = User Zone 1
                                 .
                                 .
                                 .
                         0x80 = System Zone
          
                     Parameter 6 = not used
          
            0x0B = TCC Preamp Offset parameters
          
                     Parameter 3 = Set Number
                     Parameter 4 = Head
                     Parameter 5 = TCC Preamp Parameter Index
          
                     Parameter 6 = Zone Number
          
                         0x00 = User Zone 0
                         0x01 = User Zone 1
                                 .
                                 .
                                 .
                         0x80 = System Zone
          
            0x0C = RAP CRC
          
                     Parameters 3-6 are not used
          
            0x0D = AFH drive parameters
                     Parameter 3 = AFH drive parameter index
                        NOTE: Enter value in IEEE 754 float 32 bit representation!
          
                     Parameters 4-6 are not used
          
            0x0E = AFH head parameters
          
                     Parameter 3 = Head
                     Parameter 4 = AFH head parameter index
                        NOTE: Enter value in IEEE 754 float 32 bit representation!
          
                     Parameter 5-6 = not used
          
            0x0F = AFH head/zone parameters
          
                     Parameter 3 = Head
                     Parameter 4 = AFH head/zone parameter index
                     Parameter 5 = Zone Number
          
                         0x00 = User Zone 0
                         0x01 = User Zone 1
                                 .
                                 .
                                 .
                         0x80 = System Zone
          
                     Parameter 6 = not used
          
            0x10 = Shared registers
          
                     Parameter 3 = Set
                     Parameter 4 = Head
                     Parameter 5 = Parameter index
                     Parameter 6 = Zone Number
          
                         0x00 = User Zone 0
                         0x01 = User Zone 1
                                 .
                                 .
                                 .
                         0x80 = System Zone
          
            0x11 = VBAR Configuration
          
                     Parameters 3-6 are not used
          
            0x12 = Channel Parameters Information Table
          
                     Parameter 0 = Index
                     Parameter 3 = Table
                     Parameter 4 = Table offset
          
            0xFF = RAP Table of Contents
          
                     Parameters 3-6 are not used
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: 0
    
    3 - P3 (select value to be modified).
    
        If Parameter 0 is entered, this parameter is used to select the value to be
        modified.  The definition of this parameter depends on the value entered for
        Parameter 2.  See the Parameter 2 description for more information.
      
        If Parameter 0 is not entered and Parameter 1 is set to display RAP, this
        parameter will specifies the heads to display their adaptive value based on
        the display mode that is set by Level T O comamnd.  With Verbose Formatted
        ASCII Output Mode, the adaptive value on all heads will be displayed.  With
        Formatted ASCII Output Mode, if Parameter3 is not entered only the adaptive
        value on the existing heads will be displayed; if Parameter3 is entered only
        the adaptive value on the requested head will be displayed. Otherwise this
        parameter is not used.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: 0
    
    4 - P4 (select value to be modified).
    
        If Parameter 0 is entered, this parameter is used to select the value to be
        modified.  The definition of this parameter depends on the value entered for
        Parameter 2.  See the Parameter 2 description for more information.
      
        If Parameter 0 is not entered, this parameter is not used.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: 0
    
    5 - P5 (select value to be modified).
    
        If Parameter 0 is entered, this parameter is used to select the value to be
        modified.  The definition of this parameter depends on the value entered for
        Parameter 2.  See the Parameter 2 description for more information.
      
        If Parameter 0 is not entered, this parameter is not used.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: 0
    
    6 - P6 (select value to be modified).
    
        If Parameter 0 is entered, this parameter is used to select the value to be
        modified.  The definition of this parameter depends on the value entered for
        Parameter 2.  See the Parameter 2 description for more information.
      
        If Parameter 0 is not entered, this parameter is not used.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: 0
    
    7 - RAP Update Option.
    
        This parameter is a bit significant value that specifies how the modified
        RAP values are to be applied.  The bits are defined as follows:
    
            Bits 31-2: not used
    
            Bit 1: Enable Track Format update.
    
                   If this bit is equal to 1, the Track Format will be updated based on the
                   RAP values that were modified.  If this bit is equal to 0, the
                   Track Format will not be modified.
    
            Bit 0: Enable Channel Parameter Reload.
    
                   If this bit is equal to 1, the Channel Registers will be updated based
                   on the RAP values that were modified.  If this bit is equal
                   to 0, the Channel Registers will not be modified.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: 0 (Disable Track Format Update and Channel Parameter Reload)
    

  <b><i><u>Output Data:</u></i></b>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
<a name="RAP_DATA_02"></a>
    If no error occurred and the RAP data is being displayed ...
    
<a name="RAP_DRIVE_CONFIG_DATA_02"></a>
       The following is an example of the RAP Drive Configuration information that will
       be displayed.
       
          (P1=01) RAP:
       
             (P2=01) RAP Drive Config:
       
                Format Rev: 0010
                Contents Rev: 0D00
                Drive Serial Number: Invalid
       
<a name="RAP_TEMP_SENSOR_CONFIG_DATA"></a>
       The following is an example of the RAP Temperature Sensor Configuration information
       that will be displayed.
       
          (P1=01) RAP:
       
            (P2=02) RAP Temp Sensor Config:
       
              Thermistor Temp Sensor Offset: 00
              Thermistor Temp Sensor Scale: 64
              Thermistor Temp Table Elements: 1E
       
              Thermistor Temp Lookup Table:
                                 0    1    2    3    4    5    6    7
                Temperature:  FFD0 FFDA FFE3 FFEC FFFE 000F 001F 002F
                A to D Value: FF91 FF8D FF89 FF86 FF7E FF76 FF6E FF67
       
                                 8    9    A    B    C    D    E    F
                Temperature:  003E 004D 005B 0076 0090 00A9 00D9 0107
                A to D Value: FF5F FF57 FF50 FF40 FF31 FF21 FF02 FEE3
       
                                10   11   12   13   14   15   16   17
                Temperature:  0138 016D 01A9 01CA 01EE 0214 023E 0254
                A to D Value: FEC5 FEA6 FE87 FE77 FE68 FE58 FE49 FE41
       
                                18   19   1A   1B   1C   1D
                Temperature:  026B 0283 029C 02B6 02D2 02EE
                A to D Value: FE3A FE32 FE2A FE22 FE1B FE13
       
<a name="RAP_ZONE_CONFIG_DATA_02"></a>
       The following is an example of the RAP Zone Configuration information that will be
       displayed.
       
          (P1=01) RAP:
       
            (P2=03) RAP Zone Config:
       
              Min Alt Tracks Per Zone: 00
       
                              StartCyl   NumCyls  SpareCyls
              User Zone   00: 00000000   002BD1   000011
              User Zone   01: 00002BD1   002940   000010
              User Zone   02: 00005511   0026E4   00000F
              System Zone 00: 00007BF5   00012C   00000E
       
<a name="RAP_TUNED_DRIVE_PARMS_DATA_02"></a>
       The following is an example of the RAP Tuned Drive Parameters information that will be
       displayed.
       
          (P1=01) RAP:
       
            (P2=04) Tuned Drive Parms:
       
              (P3=00) Reg Group 00:
       
                      P4=    0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F
                Reg Addr: 0000 0001 0055 0084 0085 0086 008C 008E 0090 0092 0095 0099 009B 009C 009D 009E
                Reg Data: 0390 000B 01C7 8078 11D2 0092 4100 8A00 0073 0003 0021 01E9 0000 000F 0000 0000
       
                      P4=   10   11   12   13   14   15   16   17   18   19   1A   1B   1C   1D   1E   1F
                Reg Addr: 009F 00A0 00A1 00A3 00A4 00A5 00A6 00A7 00B7 00B8 00BC 00BD 00BE 00BF 00D6 00D7
                Reg Data: 0000 2000 0000 0000 38DA 14D1 0048 7880 FA00 1986 0000 1525 00F0 7F00 004C 00A5
       
                      P4=   20   21   22   23   24   25   26   27   28   29   2A   2B   2C   2D   2E   2F
                Reg Addr: 00DA 00DC 00DD 00DE 00E0 00E2 00E5 00E9 00EB 00EC 00ED 00EE 00EF 00F0 00F1 00F2
                Reg Data: 2100 00D4 0000 0000 6817 0000 0000 0000 0000 0000 0000 0000 0000 001C 004A 7000
       
                      P4=   30   31   32   33   34   35   36   37   38   39   3A
                Reg Addr: 00F3 00F5 00F6 00F7 00F8 00F9 00FA 00FB 00FC 00FD 00FE
                Reg Data: 0000 0088 0020 0020 0000 0FFF 0000 0000 0000 0040 0000
       
              (P3=01) Reg Group 01:
       
                      P4=    0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F
                Reg Addr: 0061 0062 0063 0064 0075 0076 00E4 00E5 00E6 00EA 00EB 00EC 00ED 00EE 00F0 00F1
                Reg Data: 204F 0044 2630 0000 0520 0000 F20B 0000 0000 0000 0000 0D07 0000 4020 0000 0003
       
                      P4=   10   11   12   13   14   15   16   17   18   19
                Reg Addr: 00F4 00F5 00F6 00F7 00F8 00F9 00FB 00FD 00FE 00FF
                Reg Data: 0004 0002 0024 0000 0000 0000 015A 1847 0000 0400
       
<a name="RAP_TUNED_ZONE_PARMS_DATA_02"></a>
       The following is an example of the RAP Tuned Zone Parameters information that will be
       displayed.
       
          (P1=01) RAP:
       
            (P2=05) RAP Tuned Zone Parms:
       
              (P3=00) Reg Group 00:
       
                                    P4=    0
                              Reg Addr: 0086
                (P5=00) User Zone 00:   006A
                (P5=01) User Zone 01:   0067
                (P5=02) User Zone 02:   0065
                (P5=80) System Zone 00: 0062
       
              (P3=01) Reg Group 01:
       
                                    P4=    0    1    2
                              Reg Addr: 0060 0061 0063
                (P5=00) User Zone 00:   E1D3 204F 2630
                (P5=01) User Zone 01:   E1D3 204F 262B
                (P5=02) User Zone 02:   E1D3 204F 2633
                (P5=80) System Zone 00: E1D3 204F 262F
       
<a name="RAP_TUNED_HEAD_PARMS_DATA_02"></a>
       The following is an example of the RAP Tuned Head Parameters information that will be
       displayed.
       
          (P1=01) RAP:
       
            (P2=06) RAP Tuned Head Parms:
       
              (P3=00) Head 00:
       
                (P4=00) Reg Group 00:
       
                                               P5=    0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F
                                         Reg Addr: 0089 008A 008B 0093 0094 0096 0098 0097 0098 00B0 00B1 00B2 00B3 00B4 00B5 00B6
                  (P6=00) User Zone 00 Reg Data:   3DF4 3DF4 A1EF 0804 0CB8 0004 0500 C900 0100 9886 2868 E306 B053 8077 0080 00EE
                  (P6=01) User Zone 01 Reg Data:   3DF4 3DF4 A1EF 0804 0C60 0004 0500 C900 0100 AA78 1051 E902 B169 8075 0080 00EE
                  (P6=02) User Zone 02 Reg Data:   3DF4 3DF4 A1EF 0804 0C20 0004 0500 C900 0100 A37A 1657 DE02 AE78 807C 0080 00EE
                  (P6=80) System Zone 00 Reg Data: 3DF4 3DF4 A1EF 0804 0BC0 0004 0500 C900 0100 A47C 1253 E402 AB80 807A 0080 00EE
       
                                               P5=   10   11   12   13   14   15   16   17   18   19   1A   1B   1C   1D   1E   1F
                                         Reg Addr: 00B9 00BB 00C0 00C1 00C2 00C3 00C4 00C5 00C6 00C7 00C8 00C9 00CA 00CB 00CC 00CD
                  (P6=00) User Zone 00 Reg Data:   4026 0800 0000 0000 0000 0000 2828 2828 2828 2828 4444 4444 4444 4444 7C7C 7C7C
                  (P6=01) User Zone 01 Reg Data:   4026 0800 0000 0000 0000 0000 2828 2828 2828 2828 4444 4444 4444 4444 7C7C 7C7C
                  (P6=02) User Zone 02 Reg Data:   4026 0800 0000 0000 0000 0000 2828 2828 2828 2828 4444 4444 4444 4444 7C7C 7C7C
                  (P6=80) System Zone 00 Reg Data: 4026 0800 0000 0000 0000 0000 2828 2828 2828 2828 4444 4444 4444 4444 7C7C 7C7C
       
                                               P5=   20   21   22   23   24   25   26
                                         Reg Addr: 00CE 00CF 00D0 00D1 00D2 00D3 00D4
                  (P6=00) User Zone 00 Reg Data:   7C7C 7C00 0000 0000 0000 0000 0000
                  (P6=01) User Zone 01 Reg Data:   7C7C 7C00 0000 0000 0000 0000 0000
                  (P6=02) User Zone 02 Reg Data:   7C7C 7C00 0000 0000 0000 0000 0000
                  (P6=80) System Zone 00 Reg Data: 7C7C 7C00 0000 0000 0000 0000 0000
       
<a name="RAP_ZONE_FORMAT_BUDGET_PARMS_DATA_02"></a>
       The following is an example of the RAP Zone Format Budget Parameters information that
       will be displayed.
       
          (P1=01) RAP:
       
            (P2=07) RAP Zone Format Budget Parms:
       
              Format Budget Rev: 01
       
                                      InitialPlo  Plo    Isg   PreSrvGap PostSrvGap SeqPlo1 SeqPlo
                                        (P3=0)   (P3=1) (P3=2)  (P3=3)     (P3=4)   (P3=5)  (P3=6)
              (P4=00) User Zone 00:       1C       26     0D      20         04       14      1E
              (P4=01) User Zone 01:       1B       25     0C      20         05       13      1D
              (P4=02) User Zone 02:       1C       26     0B      20         05       13      1D
              (P4=03) User Zone 03:       1D       26     0B      20         05       14      1D
              (P4=04) User Zone 04:       1C       26     0B      21         05       13      1D
              (P4=05) User Zone 05:       1D       25     0B      21         05       14      1C
              (P4=06) User Zone 06:       1C       24     0C      21         05       14      1C
              (P4=07) User Zone 07:       1B       24     0C      21         05       13      1C
              (P4=08) User Zone 08:       1C       25     0A      21         04       13      1C
              (P4=09) User Zone 09:       1D       24     0A      20         04       14      1B
              (P4=0A) User Zone 0A:       1C       23     0A      20         04       13      1A
              (P4=0B) User Zone 0B:       1C       23     0A      20         05       13      1A
              (P4=0C) User Zone 0C:       1C       23     0A      1F         04       13      1A
              (P4=0D) User Zone 0D:       1B       22     0A      1F         04       13      1A
              (P4=0E) User Zone 0E:       1B       21     09      1F         04       12      18
              (P4=0F) User Zone 0F:       1B       20     09      1D         04       12      17
              (P4=80) System Zone 00:     1A       20     09      1D         04       11      17
       
                                      SeqPad SeqIsgWr SeqIsgRd SeqSgToRg SeqSkipRdDelay SeqSyncTo
                                      (P3=7)  (P3=8)   (P3=9)   (P3=A)       (P3=B)      (P3=C)
              (P4=00) User Zone 00:     02      13       19       08           34          34
              (P4=01) User Zone 01:     02      12       18       08           33          34
              (P4=02) User Zone 02:     02      12       18       09           34          34
              (P4=03) User Zone 03:     02      12       18       09           34          34
              (P4=04) User Zone 04:     02      12       18       09           34          34
              (P4=05) User Zone 05:     02      12       17       09           35          32
              (P4=06) User Zone 06:     02      12       17       09           35          32
              (P4=07) User Zone 07:     02      12       17       08           33          32
              (P4=08) User Zone 08:     02      11       16       08           33          32
              (P4=09) User Zone 09:     02      11       16       08           34          32
              (P4=0A) User Zone 0A:     02      11       15       08           33          31
              (P4=0B) User Zone 0B:     02      11       15       08           33          2F
              (P4=0C) User Zone 0C:     02      11       15       08           33          2F
              (P4=0D) User Zone 0D:     02      10       14       07           32          2E
              (P4=0E) User Zone 0E:     02      10       13       07           32          2D
              (P4=0F) User Zone 0F:     02      10       12       07           32          2A
              (P4=80) System Zone 00:   02      10       12       06           31          2A
       
<a name="RAP_HEAD_FORMAT_BUDGET_PARMS_DATA_02"></a>
       The following is an example of the RAP Head Format Budget Parameters information that
       will be displayed.
       
       
       
       
          (P1=01) RAP:
       
             (P2=08) RAP Head Format Budget Parms:
       
                Format Budget Rev: 01
       
                (P3=00) Head 00:
       
                                          SeqSgToWg
                  (P4=00) User Zone 00:      0F
                  (P4=01) User Zone 01:      10
                  (P4=02) User Zone 02:      11
                  (P4=03) User Zone 03:      11
                  (P4=04) User Zone 04:      12
                  (P4=05) User Zone 05:      12
                  (P4=06) User Zone 06:      12
                  (P4=07) User Zone 07:      12
                  (P4=08) User Zone 08:      12
                  (P4=09) User Zone 09:      12
                  (P4=0A) User Zone 0A:      12
                  (P4=0B) User Zone 0B:      12
                  (P4=0C) User Zone 0C:      12
                  (P4=0D) User Zone 0D:      12
                  (P4=0E) User Zone 0E:      12
                  (P4=0F) User Zone 0F:      11
                  (P4=80) System Zone 00:    11
       
<a name="RAP_TCC_TEMP_POINT_PARMS_DATA_02"></a>
       The following is an example of the RAP TCC Temperature Point Parameters information
       that will be displayed.
       
          (P1=01) RAP:
       
            (P2=09) RAP TCC Temp Point Parms: 19 37 FFFFFFF6
       
<a name="RAP_TCC_PREAMP_PARMS_DATA_02"></a>
       The following is an example of the RAP TCC Preamp Parameters information that will be
       displayed.
       
          (P1=01) RAP:
       
            (P2=0A) RAP TCC Preamp Parms:
       
              (P3=00) Head 00:
       
                                        WrCur   WrDamp  WrDampDur  WrPreHt   WrHt    RdHt
                                        (P4=0)  (P4=1)   (P4=2)    (P4=3)   (P4=4)  (P4=5)
                (P5=00) User Zone 00:     0F      08       0E        20       1E      1F
                (P5=01) User Zone 01:     0F      08       0E        20       1E      1F
                (P5=02) User Zone 02:     0F      08       0E        28       26      27
                (P5=80) System Zone 00:   0F      08       0E        28       26      27
       
<a name="RAP_TCC_PREAMP_OFFSET_PARMS_DATA_02"></a>
       The following is an example of the RAP TCC Preamp Offset Parameters information that
       will be displayed.
       
          (P1=01) RAP:
       
            (P2=0B) RAP TCC Preamp Offset Parms:
       
              (P3=00) Set 00:
       
                (P4=00) Head 00:
       
                                          WrCurOff  WrDampOff  WrDampDurOff  WrPreHtOff   WrHtOff    RdHtOff
                                           (P5=0)    (P5=1)       (P5=2)       (P5=3)      (P5=4)     (P5=5)
                  (P6=00) User Zone 00:      00        00           00           00          00         00
                  (P6=01) User Zone 01:      00        00           00           00          00         00
                  (P6=02) User Zone 02:      00        00           00           00          00         00
                  (P6=80) System Zone 00:    00        00           00           00          00         00
       
              (P3=01) Set 01:
       
                (P4=00) Head 00:
       
                                          WrCurOff  WrDampOff  WrDampDurOff  WrPreHtOff   WrHtOff    RdHtOff
                                           (P5=0)    (P5=1)       (P5=2)       (P5=3)      (P5=4)     (P5=5)
                  (P6=00) User Zone 00:      00        00           00           00          00         00
                  (P6=01) User Zone 01:      00        00           00           00          00         00
                  (P6=02) User Zone 02:      00        00           00           00          00         00
                  (P6=80) System Zone 00:    00        00           00           00          00         00
       
              (P3=02) Set 02:
       
                (P4=00) Head 00:
       
                                          WrCurOff  WrDampOff  WrDampDurOff  WrPreHtOff   WrHtOff    RdHtOff
                                           (P5=0)    (P5=1)       (P5=2)       (P5=3)      (P5=4)     (P5=5)
                  (P6=00) User Zone 00:      00        00           00           00          00         00
                  (P6=01) User Zone 01:      00        00           00           00          00         00
                  (P6=02) User Zone 02:      00        00           00           00          00         00
                  (P6=80) System Zone 00:    00        00           00           00          00         00
       
<a name="RAP_CRC_DATA"></a>
       The following is an example of the RAP CRC display.
       
          (P1=01) RAP:
       
            (P2=0C) RAP CRC: 00000000
       
    

  <b><i><u>Revision History:</u></i></b>
<a name="DISPLAY_MODIFY_RAP_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).
    
    if RAP_FORMAT_14_REV_2
    0012.0000   Changed Gamma values.  Added new TCS values.
    endif

<!--SUBSECTION--><a name="Display / Modify RAP revision 10"></a><hr align=left width="75%"><b> Display / Modify RAP revision 10 (Level 2, 7 'I,1')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command displays and optionally modifies the value of the specified read adaptive
    parameter.

  <b><i><u>Quick Help:</u></i></b>
<a name="DISPLAY_MODIFY_RAP_QUICK_HELP"></a>
    "DisplayModifyRap, I[ParmValue],1,[ParmId],[P3],[P4],[P5],[P6],[UpdateOpts]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="DISPLAY_MODIFY_RAP_PARM"></a>
    0 - P0 (New RAP Value).
    
        If this parameter is entered, the adaptive value specified by command
        parameters 1 though 7 will be set equal to the value of this parameter.
        If this parameter is not entered, the RAP values specified by command
        parameters 1 and 2 will be displayed.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: None
    
    1 - P1 (RAP Group ID = 1).
    
        This parameter specifies the RAP ID (1).
    
          Type:    Unsigned 32-bit value
    
          Range:   1 is the only valid value.
    
          Default: NA
    
    2 - P2 (RAP Value ID).
    
        This parameter specifies the ID of the RAP value to be displayed or modified.
        If Parameter 0 is not entered, entering a value of zero for  this parameter
        will display all of the parameters in the group RAP.
    
<a name="RAP_PARM_IDS"></a>
          
          The Adaptive Parameter IDs and the values of parameters 3-6
          are defined as follows:
          
            0x00 = All RAP Parameters
          
                     Parameters 3-6 are not used
          
            0x01 = Drive Configuration
          
                     Parameters 3-6 are not used
          
            0x02 = Temperature Sensor Configuration
          
                     Parameters 3-6 are not used
          
            0x03 = Zone Configuration
          
                     Parameters 3-6 are not used
          
            0x04 = Tuned Drive parameters
          
                     Parameter 3 = Register Group
                     Parameter 4 = Register Index
                     Parameter 5 = not used
                     Parameter 6 = not used
          
            0x05 = Tuned Zone parameters
          
                     Parameter 3 = Register Group
                     Parameter 4 = Register Index
          
                     Parameter 5 = Zone Number
          
                         0x00 = User Zone 0
                         0x01 = User Zone 1
                                 .
                                 .
                                 .
                         0x80 = System Zone
          
                     Parameter 6 = not used
          
            0x06 = Tuned Head parameters
          
                     Parameter 3 = Head
                     Parameter 4 = Register Group
                     Parameter 5 = Register Index
          
                     Parameter 6 = Zone Number
          
                         0x00 = User Zone 0
                         0x01 = User Zone 1
                                 .
                                 .
                                 .
                         0x80 = System Zone
          
            0x07 = Zone Format Budget parameters
          
                     Parameter 3 = Zone Format Budget Parameter Index
          
                     Parameter 4 = Zone Number
          
                         0x00 = User Zone 0
                         0x01 = User Zone 1
                                 .
                                 .
                                 .
                         0x80 = System Zone
          
                     Parameter 5 = not used
                     Parameter 6 = not used
          
            0x08 = Head Format Budget parameters
          
                     Parameter 3 = Head
          
                     Parameter 4 = Zone Number
          
                         0x00 = User Zone 0
                         0x01 = User Zone 1
                                 .
                                 .
                                 .
                         0x80 = System Zone
          
                     Parameter 5 = not used
                     Parameter 6 = not used
          
            0x09 = TCC Preamp Temperature Point parameters
          
                     Parameters 3-6 are not used
          
            0x0A = TCC Preamp parameters
          
                     Parameter 3 = Head
                     Parameter 4 = TCC Preamp Parameter Index
          
                     Parameter 5 = Zone Number
          
                         0x00 = User Zone 0
                         0x01 = User Zone 1
                                 .
                                 .
                                 .
                         0x80 = System Zone
          
                     Parameter 6 = not used
          
            0x0B = TCC Preamp Offset parameters
          
                     Parameter 3 = Set Number
                     Parameter 4 = Head
                     Parameter 5 = TCC Preamp Parameter Index
          
                     Parameter 6 = Zone Number
          
                         0x00 = User Zone 0
                         0x01 = User Zone 1
                                 .
                                 .
                                 .
                         0x80 = System Zone
          
            0x0C = RAP CRC
          
                     Parameters 3-6 are not used
          
            0x0D = AFH drive parameters
                     Parameter 3 = AFH drive parameter index
                        NOTE: Enter value in IEEE 754 float 32 bit representation!
          
                     Parameters 4-6 are not used
          
            0x0E = AFH head parameters
          
                     Parameter 3 = Head
                     Parameter 4 = AFH head parameter index
                        NOTE: Enter value in IEEE 754 float 32 bit representation!
          
                     Parameter 5-6 = not used
          
            0x0F = AFH head/zone parameters
          
                     Parameter 3 = Head
                     Parameter 4 = AFH head/zone parameter index
                     Parameter 5 = Zone Number
          
                         0x00 = User Zone 0
                         0x01 = User Zone 1
                                 .
                                 .
                                 .
                         0x80 = System Zone
          
                     Parameter 6 = not used
          
            0x10 = Shared registers
          
                     Parameter 3 = Set
                     Parameter 4 = Head
                     Parameter 5 = Parameter index
                     Parameter 6 = Zone Number
          
                         0x00 = User Zone 0
                         0x01 = User Zone 1
                                 .
                                 .
                                 .
                         0x80 = System Zone
          
            0x11 = VBAR Configuration
          
                     Parameters 3-6 are not used
          
            0x12 = Channel Parameters Information Table
          
                     Parameter 0 = Index
                     Parameter 3 = Table
                     Parameter 4 = Table offset
          
            0xFF = RAP Table of Contents
          
                     Parameters 3-6 are not used
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: 0
    
    3 - P3 (select value to be modified).
    
        If Parameter 0 is entered, this parameter is used to select the value to be
        modified.  The definition of this parameter depends on the value entered for
        Parameter 2.  See the Parameter 2 description for more information.
      
        If Parameter 0 is not entered and Parameter 1 is set to display RAP, this
        parameter will specifies the heads to display their adaptive value based on
        the display mode that is set by Level T O comamnd.  With Verbose Formatted
        ASCII Output Mode, the adaptive value on all heads will be displayed.  With
        Formatted ASCII Output Mode, if Parameter3 is not entered only the adaptive
        value on the existing heads will be displayed; if Parameter3 is entered only
        the adaptive value on the requested head will be displayed. Otherwise this
        parameter is not used.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: 0
    
    4 - P4 (select value to be modified).
    
        If Parameter 0 is entered, this parameter is used to select the value to be
        modified.  The definition of this parameter depends on the value entered for
        Parameter 2.  See the Parameter 2 description for more information.
      
        If Parameter 0 is not entered, this parameter is not used.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: 0
    
    5 - P5 (select value to be modified).
    
        If Parameter 0 is entered, this parameter is used to select the value to be
        modified.  The definition of this parameter depends on the value entered for
        Parameter 2.  See the Parameter 2 description for more information.
      
        If Parameter 0 is not entered, this parameter is not used.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: 0
    
    6 - P6 (select value to be modified).
    
        If Parameter 0 is entered, this parameter is used to select the value to be
        modified.  The definition of this parameter depends on the value entered for
        Parameter 2.  See the Parameter 2 description for more information.
      
        If Parameter 0 is not entered, this parameter is not used.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: 0
    
    7 - RAP Update Option.
    
        This parameter is a bit significant value that specifies how the modified
        RAP values are to be applied.  The bits are defined as follows:
    
            Bits 31-2: not used
    
            Bit 1: Enable Track Format update.
    
                   If this bit is equal to 1, the Track Format will be updated based on the
                   RAP values that were modified.  If this bit is equal to 0, the
                   Track Format will not be modified.
    
            Bit 0: Enable Channel Parameter Reload.
    
                   If this bit is equal to 1, the Channel Registers will be updated based
                   on the RAP values that were modified.  If this bit is equal
                   to 0, the Channel Registers will not be modified.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: 0 (Disable Track Format Update and Channel Parameter Reload)
    

  <b><i><u>Output Data:</u></i></b>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
<a name="RAP_DATA_10"></a>
    If no error occurred and the RAP data is being displayed ...
    
<a name="RAP_DRIVE_CONFIG_DATA_10"></a>
       The following is an example of the RAP Drive Configuration information that will
       be displayed.
       
          (P1=01) RAP:
       
             (P2=01) RAP Drive Config:
       
                Format Rev: 0010
                Contents Rev: 0D00
                Drive Serial Number: Invalid
                RAP Heads: 0001
                RAP User Zones: 0010
                RAP System Zones: 0001
       
<a name="RAP_TEMP_SENSOR_CONFIG_DATA"></a>
       The following is an example of the RAP Temperature Sensor Configuration information
       that will be displayed.
       
          (P1=01) RAP:
       
            (P2=02) RAP Temp Sensor Config:
       
              Thermistor Temp Sensor Offset: 00
              Thermistor Temp Sensor Scale: 64
              Thermistor Temp Table Elements: 1E
       
              Thermistor Temp Lookup Table:
                                 0    1    2    3    4    5    6    7
                Temperature:  FFD0 FFDA FFE3 FFEC FFFE 000F 001F 002F
                A to D Value: FF91 FF8D FF89 FF86 FF7E FF76 FF6E FF67
       
                                 8    9    A    B    C    D    E    F
                Temperature:  003E 004D 005B 0076 0090 00A9 00D9 0107
                A to D Value: FF5F FF57 FF50 FF40 FF31 FF21 FF02 FEE3
       
                                10   11   12   13   14   15   16   17
                Temperature:  0138 016D 01A9 01CA 01EE 0214 023E 0254
                A to D Value: FEC5 FEA6 FE87 FE77 FE68 FE58 FE49 FE41
       
                                18   19   1A   1B   1C   1D
                Temperature:  026B 0283 029C 02B6 02D2 02EE
                A to D Value: FE3A FE32 FE2A FE22 FE1B FE13
       
<a name="RAP_ZONE_CONFIG_DATA_10"></a>
       The following is an example of the RAP Zone Configuration information that will be
       displayed.
       
          (P1=01) RAP:
       
            (P2=03) RAP Zone Config:
       
              Min Alt Tracks Per Zone: 00
       
                              StartCyl   NumCyls  SpareCyls
              User Zone   00: 00000000   002BD1   000011
              User Zone   01: 00002BD1   002940   000010
              User Zone   02: 00005511   0026E4   00000F
              System Zone 00: 00007BF5   00012C   00000E
       
<a name="RAP_TUNED_DRIVE_PARMS_DATA_10"></a>
       The following is an example of the RAP Tuned Drive Parameters information that will be
       displayed.
       
          (P1=01) RAP:
       
            (P2=04) Tuned Drive Parms:
       
              (P3=00) Reg Group 00:
       
                      P4=    0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F
                Reg Addr: 0000 0001 0055 0084 0085 0086 008C 008E 0090 0092 0095 0099 009B 009C 009D 009E
                Reg Data: 0390 000B 01C7 8078 11D2 0092 4100 8A00 0073 0003 0021 01E9 0000 000F 0000 0000
       
                      P4=   10   11   12   13   14   15   16   17   18   19   1A   1B   1C   1D   1E   1F
                Reg Addr: 009F 00A0 00A1 00A3 00A4 00A5 00A6 00A7 00B7 00B8 00BC 00BD 00BE 00BF 00D6 00D7
                Reg Data: 0000 2000 0000 0000 38DA 14D1 0048 7880 FA00 1986 0000 1525 00F0 7F00 004C 00A5
       
                      P4=   20   21   22   23   24   25   26   27   28   29   2A   2B   2C   2D   2E   2F
                Reg Addr: 00DA 00DC 00DD 00DE 00E0 00E2 00E5 00E9 00EB 00EC 00ED 00EE 00EF 00F0 00F1 00F2
                Reg Data: 2100 00D4 0000 0000 6817 0000 0000 0000 0000 0000 0000 0000 0000 001C 004A 7000
       
                      P4=   30   31   32   33   34   35   36   37   38   39   3A
                Reg Addr: 00F3 00F5 00F6 00F7 00F8 00F9 00FA 00FB 00FC 00FD 00FE
                Reg Data: 0000 0088 0020 0020 0000 0FFF 0000 0000 0000 0040 0000
       
              (P3=01) Reg Group 01:
       
                      P4=    0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F
                Reg Addr: 0061 0062 0063 0064 0075 0076 00E4 00E5 00E6 00EA 00EB 00EC 00ED 00EE 00F0 00F1
                Reg Data: 204F 0044 2630 0000 0520 0000 F20B 0000 0000 0000 0000 0D07 0000 4020 0000 0003
       
                      P4=   10   11   12   13   14   15   16   17   18   19
                Reg Addr: 00F4 00F5 00F6 00F7 00F8 00F9 00FB 00FD 00FE 00FF
                Reg Data: 0004 0002 0024 0000 0000 0000 015A 1847 0000 0400
       
<a name="RAP_TUNED_ZONE_PARMS_DATA_10"></a>
       The following is an example of the RAP Tuned Zone Parameters information that will be
       displayed.
       
          (P1=01) RAP:
       
            (P2=05) RAP Tuned Zone Parms:
       
              (P3=00) Reg Group 00:
       
                                    P4=    0
                              Reg Addr: 0086
                (P5=00) User Zone 00:   006A
                (P5=01) User Zone 01:   0067
                (P5=02) User Zone 02:   0065
                (P5=80) System Zone 00: 0062
       
              (P3=01) Reg Group 01:
       
                                    P4=    0    1    2
                              Reg Addr: 0060 0061 0063
                (P5=00) User Zone 00:   E1D3 204F 2630
                (P5=01) User Zone 01:   E1D3 204F 262B
                (P5=02) User Zone 02:   E1D3 204F 2633
                (P5=80) System Zone 00: E1D3 204F 262F
       
<a name="RAP_TUNED_HEAD_PARMS_DATA_10"></a>
       The following is an example of the RAP Tuned Head Parameters information that will be
       displayed.
       
          (P1=01) RAP:
       
            (P2=06) RAP Tuned Head Parms:
       
              (P3=00) Head 00:
       
                (P4=00) Reg Group 00:
       
                                               P5=    0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F
                                         Reg Addr: 0089 008A 008B 0093 0094 0096 0098 0097 0098 00B0 00B1 00B2 00B3 00B4 00B5 00B6
                  (P6=00) User Zone 00 Reg Data:   3DF4 3DF4 A1EF 0804 0CB8 0004 0500 C900 0100 9886 2868 E306 B053 8077 0080 00EE
                  (P6=01) User Zone 01 Reg Data:   3DF4 3DF4 A1EF 0804 0C60 0004 0500 C900 0100 AA78 1051 E902 B169 8075 0080 00EE
                  (P6=02) User Zone 02 Reg Data:   3DF4 3DF4 A1EF 0804 0C20 0004 0500 C900 0100 A37A 1657 DE02 AE78 807C 0080 00EE
                  (P6=80) System Zone 00 Reg Data: 3DF4 3DF4 A1EF 0804 0BC0 0004 0500 C900 0100 A47C 1253 E402 AB80 807A 0080 00EE
       
                                               P5=   10   11   12   13   14   15   16   17   18   19   1A   1B   1C   1D   1E   1F
                                         Reg Addr: 00B9 00BB 00C0 00C1 00C2 00C3 00C4 00C5 00C6 00C7 00C8 00C9 00CA 00CB 00CC 00CD
                  (P6=00) User Zone 00 Reg Data:   4026 0800 0000 0000 0000 0000 2828 2828 2828 2828 4444 4444 4444 4444 7C7C 7C7C
                  (P6=01) User Zone 01 Reg Data:   4026 0800 0000 0000 0000 0000 2828 2828 2828 2828 4444 4444 4444 4444 7C7C 7C7C
                  (P6=02) User Zone 02 Reg Data:   4026 0800 0000 0000 0000 0000 2828 2828 2828 2828 4444 4444 4444 4444 7C7C 7C7C
                  (P6=80) System Zone 00 Reg Data: 4026 0800 0000 0000 0000 0000 2828 2828 2828 2828 4444 4444 4444 4444 7C7C 7C7C
       
                                               P5=   20   21   22   23   24   25   26
                                         Reg Addr: 00CE 00CF 00D0 00D1 00D2 00D3 00D4
                  (P6=00) User Zone 00 Reg Data:   7C7C 7C00 0000 0000 0000 0000 0000
                  (P6=01) User Zone 01 Reg Data:   7C7C 7C00 0000 0000 0000 0000 0000
                  (P6=02) User Zone 02 Reg Data:   7C7C 7C00 0000 0000 0000 0000 0000
                  (P6=80) System Zone 00 Reg Data: 7C7C 7C00 0000 0000 0000 0000 0000
       
<a name="RAP_ZONE_FORMAT_BUDGET_PARMS_DATA_10"></a>
       The following is an example of the RAP Zone Format Budget Parameters information that
       will be displayed.
       
          (P1=01) RAP:
       
            (P2=07) RAP Zone Format Budget Parms:
       
              Format Budget Rev: 01
       
                                      InitialPlo  Plo    Isg   PreSrvGap PostSrvGap SeqPlo1 SeqPlo
                                        (P3=0)   (P3=1) (P3=2)  (P3=3)     (P3=4)   (P3=5)  (P3=6)
              (P4=00) User Zone 00:       1C       26     0D      20         04       14      1E
              (P4=01) User Zone 01:       1B       25     0C      20         05       13      1D
              (P4=02) User Zone 02:       1C       26     0B      20         05       13      1D
              (P4=03) User Zone 03:       1D       26     0B      20         05       14      1D
              (P4=04) User Zone 04:       1C       26     0B      21         05       13      1D
              (P4=05) User Zone 05:       1D       25     0B      21         05       14      1C
              (P4=06) User Zone 06:       1C       24     0C      21         05       14      1C
              (P4=07) User Zone 07:       1B       24     0C      21         05       13      1C
              (P4=08) User Zone 08:       1C       25     0A      21         04       13      1C
              (P4=09) User Zone 09:       1D       24     0A      20         04       14      1B
              (P4=0A) User Zone 0A:       1C       23     0A      20         04       13      1A
              (P4=0B) User Zone 0B:       1C       23     0A      20         05       13      1A
              (P4=0C) User Zone 0C:       1C       23     0A      1F         04       13      1A
              (P4=0D) User Zone 0D:       1B       22     0A      1F         04       13      1A
              (P4=0E) User Zone 0E:       1B       21     09      1F         04       12      18
              (P4=0F) User Zone 0F:       1B       20     09      1D         04       12      17
              (P4=80) System Zone 00:     1A       20     09      1D         04       11      17
       
                                      SeqPad SeqIsgWr SeqIsgRd SeqSgToRg SeqSkipRdDelay SeqSyncTo
                                      (P3=7)  (P3=8)   (P3=9)   (P3=A)       (P3=B)      (P3=C)
              (P4=00) User Zone 00:     02      13       19       08           34          34
              (P4=01) User Zone 01:     02      12       18       08           33          34
              (P4=02) User Zone 02:     02      12       18       09           34          34
              (P4=03) User Zone 03:     02      12       18       09           34          34
              (P4=04) User Zone 04:     02      12       18       09           34          34
              (P4=05) User Zone 05:     02      12       17       09           35          32
              (P4=06) User Zone 06:     02      12       17       09           35          32
              (P4=07) User Zone 07:     02      12       17       08           33          32
              (P4=08) User Zone 08:     02      11       16       08           33          32
              (P4=09) User Zone 09:     02      11       16       08           34          32
              (P4=0A) User Zone 0A:     02      11       15       08           33          31
              (P4=0B) User Zone 0B:     02      11       15       08           33          2F
              (P4=0C) User Zone 0C:     02      11       15       08           33          2F
              (P4=0D) User Zone 0D:     02      10       14       07           32          2E
              (P4=0E) User Zone 0E:     02      10       13       07           32          2D
              (P4=0F) User Zone 0F:     02      10       12       07           32          2A
              (P4=80) System Zone 00:   02      10       12       06           31          2A
       
<a name="RAP_HEAD_FORMAT_BUDGET_PARMS_DATA_10"></a>
       The following is an example of the RAP Head Format Budget Parameters information that
       will be displayed.
       
          (P1=01) RAP:
       
             (P2=08) RAP Head Format Budget Parms:
       
                Format Budget Rev: 01
       
                (P3=00) Head 00:
       
                                          SeqSgToWg
                  (P4=00) User Zone 00:      0F
                  (P4=01) User Zone 01:      10
                  (P4=02) User Zone 02:      11
                  (P4=03) User Zone 03:      11
                  (P4=04) User Zone 04:      12
                  (P4=05) User Zone 05:      12
                  (P4=06) User Zone 06:      12
                  (P4=07) User Zone 07:      12
                  (P4=08) User Zone 08:      12
                  (P4=09) User Zone 09:      12
                  (P4=0A) User Zone 0A:      12
                  (P4=0B) User Zone 0B:      12
                  (P4=0C) User Zone 0C:      12
                  (P4=0D) User Zone 0D:      12
                  (P4=0E) User Zone 0E:      12
                  (P4=0F) User Zone 0F:      11
                  (P4=80) System Zone 00:    11
       
<a name="RAP_TCC_TEMP_POINT_PARMS_DATA_10"></a>
       The following is an example of the RAP TCC Temperature Point Parameters information
       that will be displayed.
       
          (P1=01) RAP:
       
            (P2=09) RAP TCC Temp Point Parms: 19 37 FFFFFFF6
       
<a name="RAP_TCC_PREAMP_PARMS_DATA_10"></a>
       The following is an example of the RAP TCC Preamp Parameters information that will be
       displayed.
       
          (P1=01) RAP:
       
            (P2=0A) RAP TCC Preamp Parms:
       
              (P3=00) Head 00:
       
                                        WrCur   WrDamp  WrDampDur
                                        (P4=0)  (P4=1)   (P4=2)
                (P5=00) User Zone 00:     0F      08       0E
                (P5=01) User Zone 01:     0F      08       0E
                (P5=02) User Zone 02:     0F      08       0E
                (P5=80) System Zone 00:   0F      08       0E
       
<a name="RAP_TCC_PREAMP_OFFSET_PARMS_DATA_10"></a>
       The following is an example of the RAP TCC Preamp Offset Parameters information that
       will be displayed.
       
          (P1=01) RAP:
       
            (P2=0B) RAP TCC Preamp Offset Parms:
       
              (P3=00) Set 00:
       
                (P4=00) Head 00:
       
                                          WrCurOff  WrDampOff  WrDampDurOff
                                           (P5=0)    (P5=1)       (P5=2)
                  (P6=00) User Zone 00:      00        00           00
                  (P6=01) User Zone 01:      00        00           00
                  (P6=02) User Zone 02:      00        00           00
                  (P6=80) System Zone 00:    00        00           00
       
              (P3=01) Set 01:
       
                (P4=00) Head 00:
       
                                          WrCurOff  WrDampOff  WrDampDurOff
                                           (P5=0)    (P5=1)       (P5=2)
                  (P6=00) User Zone 00:      00        00           00
                  (P6=01) User Zone 01:      00        00           00
                  (P6=02) User Zone 02:      00        00           00
                  (P6=80) System Zone 00:    00        00           00
       
              (P3=02) Set 02:
       
                (P4=00) Head 00:
       
                                          WrCurOff  WrDampOff  WrDampDurOff
                                           (P5=0)    (P5=1)       (P5=2)
                  (P6=00) User Zone 00:      00        00           00
                  (P6=01) User Zone 01:      00        00           00
                  (P6=02) User Zone 02:      00        00           00
                  (P6=80) System Zone 00:    00        00           00
       
<a name="RAP_CRC_DATA"></a>
       The following is an example of the RAP CRC display.
       
          (P1=01) RAP:
       
            (P2=0C) RAP CRC: 00000000
       
    

  <b><i><u>Revision History:</u></i></b>
<a name="DISPLAY_MODIFY_RAP_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).
    
    if RAP_FORMAT_14_REV_2
    0012.0000   Changed Gamma values.  Added new TCS values.
    endif

<!--SUBSECTION--><a name="Display / Modify RAP revision 11"></a><hr align=left width="75%"><b> Display / Modify RAP revision 11 (Level 2, 7 'I,1')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command displays and optionally modifies the value of the specified read adaptive
    parameter.

  <b><i><u>Quick Help:</u></i></b>
<a name="DISPLAY_MODIFY_RAP_QUICK_HELP"></a>
    "DisplayModifyRap, I[ParmValue],1,[ParmId],[P3],[P4],[P5],[P6],[UpdateOpts]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="DISPLAY_MODIFY_RAP_PARM"></a>
    0 - P0 (New RAP Value).
    
        If this parameter is entered, the adaptive value specified by command
        parameters 1 though 7 will be set equal to the value of this parameter.
        If this parameter is not entered, the RAP values specified by command
        parameters 1 and 2 will be displayed.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: None
    
    1 - P1 (RAP Group ID = 1).
    
        This parameter specifies the RAP ID (1).
    
          Type:    Unsigned 32-bit value
    
          Range:   1 is the only valid value.
    
          Default: NA
    
    2 - P2 (RAP Value ID).
    
        This parameter specifies the ID of the RAP value to be displayed or modified.
        If Parameter 0 is not entered, entering a value of zero for  this parameter
        will display all of the parameters in the group RAP.
    
<a name="RAP_PARM_IDS"></a>
          
          The Adaptive Parameter IDs and the values of parameters 3-6
          are defined as follows:
          
            0x00 = All RAP Parameters
          
                     Parameters 3-6 are not used
          
            0x01 = Drive Configuration
          
                     Parameters 3-6 are not used
          
            0x02 = Temperature Sensor Configuration
          
                     Parameters 3-6 are not used
          
            0x03 = Zone Configuration
          
                     Parameters 3-6 are not used
          
            0x04 = Tuned Drive parameters
          
                     Parameter 3 = Register Group
                     Parameter 4 = Register Index
                     Parameter 5 = not used
                     Parameter 6 = not used
          
            0x05 = Tuned Zone parameters
          
                     Parameter 3 = Register Group
                     Parameter 4 = Register Index
          
                     Parameter 5 = Zone Number
          
                         0x00 = User Zone 0
                         0x01 = User Zone 1
                                 .
                                 .
                                 .
                         0x80 = System Zone
          
                     Parameter 6 = not used
          
            0x06 = Tuned Head parameters
          
                     Parameter 3 = Head
                     Parameter 4 = Register Group
                     Parameter 5 = Register Index
          
                     Parameter 6 = Zone Number
          
                         0x00 = User Zone 0
                         0x01 = User Zone 1
                                 .
                                 .
                                 .
                         0x80 = System Zone
          
            0x07 = Zone Format Budget parameters
          
                     Parameter 3 = Zone Format Budget Parameter Index
          
                     Parameter 4 = Zone Number
          
                         0x00 = User Zone 0
                         0x01 = User Zone 1
                                 .
                                 .
                                 .
                         0x80 = System Zone
          
                     Parameter 5 = not used
                     Parameter 6 = not used
          
            0x08 = Head Format Budget parameters
          
                     Parameter 3 = Head
          
                     Parameter 4 = Zone Number
          
                         0x00 = User Zone 0
                         0x01 = User Zone 1
                                 .
                                 .
                                 .
                         0x80 = System Zone
          
                     Parameter 5 = not used
                     Parameter 6 = not used
          
            0x09 = TCC Preamp Temperature Point parameters
          
                     Parameters 3-6 are not used
          
            0x0A = TCC Preamp parameters
          
                     Parameter 3 = Head
                     Parameter 4 = TCC Preamp Parameter Index
          
                     Parameter 5 = Zone Number
          
                         0x00 = User Zone 0
                         0x01 = User Zone 1
                                 .
                                 .
                                 .
                         0x80 = System Zone
          
                     Parameter 6 = not used
          
            0x0B = TCC Preamp Offset parameters
          
                     Parameter 3 = Set Number
                     Parameter 4 = Head
                     Parameter 5 = TCC Preamp Parameter Index
          
                     Parameter 6 = Zone Number
          
                         0x00 = User Zone 0
                         0x01 = User Zone 1
                                 .
                                 .
                                 .
                         0x80 = System Zone
          
            0x0C = RAP CRC
          
                     Parameters 3-6 are not used
          
            0x0D = AFH drive parameters
                     Parameter 3 = AFH drive parameter index
                        NOTE: Enter value in IEEE 754 float 32 bit representation!
          
                     Parameters 4-6 are not used
          
            0x0E = AFH head parameters
          
                     Parameter 3 = Head
                     Parameter 4 = AFH head parameter index
                        NOTE: Enter value in IEEE 754 float 32 bit representation!
          
                     Parameter 5-6 = not used
          
            0x0F = AFH head/zone parameters
          
                     Parameter 3 = Head
                     Parameter 4 = AFH head/zone parameter index
                     Parameter 5 = Zone Number
          
                         0x00 = User Zone 0
                         0x01 = User Zone 1
                                 .
                                 .
                                 .
                         0x80 = System Zone
          
                     Parameter 6 = not used
          
            0x10 = Shared registers
          
                     Parameter 3 = Set
                     Parameter 4 = Head
                     Parameter 5 = Parameter index
                     Parameter 6 = Zone Number
          
                         0x00 = User Zone 0
                         0x01 = User Zone 1
                                 .
                                 .
                                 .
                         0x80 = System Zone
          
            0x11 = VBAR Configuration
          
                     Parameters 3-6 are not used
          
            0x12 = Channel Parameters Information Table
          
                     Parameter 0 = Index
                     Parameter 3 = Table
                     Parameter 4 = Table offset
          
            0xFF = RAP Table of Contents
          
                     Parameters 3-6 are not used
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: 0
    
    3 - P3 (select value to be modified).
    
        If Parameter 0 is entered, this parameter is used to select the value to be
        modified.  The definition of this parameter depends on the value entered for
        Parameter 2.  See the Parameter 2 description for more information.
      
        If Parameter 0 is not entered and Parameter 1 is set to display RAP, this
        parameter will specifies the heads to display their adaptive value based on
        the display mode that is set by Level T O comamnd.  With Verbose Formatted
        ASCII Output Mode, the adaptive value on all heads will be displayed.  With
        Formatted ASCII Output Mode, if Parameter3 is not entered only the adaptive
        value on the existing heads will be displayed; if Parameter3 is entered only
        the adaptive value on the requested head will be displayed. Otherwise this
        parameter is not used.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: 0
    
    4 - P4 (select value to be modified).
    
        If Parameter 0 is entered, this parameter is used to select the value to be
        modified.  The definition of this parameter depends on the value entered for
        Parameter 2.  See the Parameter 2 description for more information.
      
        If Parameter 0 is not entered, this parameter is not used.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: 0
    
    5 - P5 (select value to be modified).
    
        If Parameter 0 is entered, this parameter is used to select the value to be
        modified.  The definition of this parameter depends on the value entered for
        Parameter 2.  See the Parameter 2 description for more information.
      
        If Parameter 0 is not entered, this parameter is not used.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: 0
    
    6 - P6 (select value to be modified).
    
        If Parameter 0 is entered, this parameter is used to select the value to be
        modified.  The definition of this parameter depends on the value entered for
        Parameter 2.  See the Parameter 2 description for more information.
      
        If Parameter 0 is not entered, this parameter is not used.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: 0
    
    7 - RAP Update Option.
    
        This parameter is a bit significant value that specifies how the modified
        RAP values are to be applied.  The bits are defined as follows:
    
            Bits 31-2: not used
    
            Bit 1: Enable Track Format update.
    
                   If this bit is equal to 1, the Track Format will be updated based on the
                   RAP values that were modified.  If this bit is equal to 0, the
                   Track Format will not be modified.
    
            Bit 0: Enable Channel Parameter Reload.
    
                   If this bit is equal to 1, the Channel Registers will be updated based
                   on the RAP values that were modified.  If this bit is equal
                   to 0, the Channel Registers will not be modified.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: 0 (Disable Track Format Update and Channel Parameter Reload)
    

  <b><i><u>Output Data:</u></i></b>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
<a name="RAP_DATA_11"></a>
    If no error occurred and the RAP data is being displayed ...
    
<a name="RAP_DRIVE_CONFIG_DATA_11"></a>
       The following is an example of the RAP Drive Configuration information that will
       be displayed.
       
          (P1=01) RAP:
       
             (P2=01) RAP Drive Config:
       
                Format Rev: 0010
                Contents Rev: 0D00
                Drive Serial Number: Invalid
                RAP Heads: 0001
                RAP User Zones: 0010
                RAP System Zones: 0001
                Tracks/zone:
                Alts/volume:
                Sec/track:
                Total Cyls:
       
<a name="RAP_TEMP_SENSOR_CONFIG_DATA"></a>
       The following is an example of the RAP Temperature Sensor Configuration information
       that will be displayed.
       
          (P1=01) RAP:
       
            (P2=02) RAP Temp Sensor Config:
       
              Thermistor Temp Sensor Offset: 00
              Thermistor Temp Sensor Scale: 64
              Thermistor Temp Table Elements: 1E
       
              Thermistor Temp Lookup Table:
                                 0    1    2    3    4    5    6    7
                Temperature:  FFD0 FFDA FFE3 FFEC FFFE 000F 001F 002F
                A to D Value: FF91 FF8D FF89 FF86 FF7E FF76 FF6E FF67
       
                                 8    9    A    B    C    D    E    F
                Temperature:  003E 004D 005B 0076 0090 00A9 00D9 0107
                A to D Value: FF5F FF57 FF50 FF40 FF31 FF21 FF02 FEE3
       
                                10   11   12   13   14   15   16   17
                Temperature:  0138 016D 01A9 01CA 01EE 0214 023E 0254
                A to D Value: FEC5 FEA6 FE87 FE77 FE68 FE58 FE49 FE41
       
                                18   19   1A   1B   1C   1D
                Temperature:  026B 0283 029C 02B6 02D2 02EE
                A to D Value: FE3A FE32 FE2A FE22 FE1B FE13
       
<a name="RAP_VBAR_ZONE_CONFIG_DATA_11"></a>
       The following is an example of the RAP Zone Configuration information that will be
       displayed.
       
          (P1=01) RAP:
       
            (P2=03) RAP VBAR Zone Config:
       
             If firmware supports ID System Partition Location:
                NominalFirstSysTrack: 0002448A
                NumSysTracks: 0000012C
                SysSpareTracksPerHd: 0F
                ActiveSerpentsPerZoneGroup: 00
       
             If firmware supports MD System Partition Location (or a location enveloped
             by the User Partition):
                SysStartMinizoneIndex: 02D6
                SysNumMinizones: 0002
                LBAsPerSysZoneCopy: 000132EA
                ActiveSerpentsPerZoneGroup: 00
       
       
                Head 0
                                     Minizones
                   User Zone   00:    127
                   User Zone   01:    127
                   User Zone   02:    12E
                   User Zone   03:    A1
                   User Zone   04:    8A
                   User Zone   05:    A5
                   User Zone   06:    CC
                   User Zone   07:    103
                   User Zone   08:    9B
       
<a name="RAP_TUNED_DRIVE_PARMS_DATA_11"></a>
       The following is an example of the RAP Tuned Drive Parameters information that will be
       displayed.
       
          (P1=01) RAP:
       
            (P2=04) Tuned Drive Parms:
       
              (P3=00) Reg Group 00:
       
                      P4=    0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F
                Reg Addr: 0000 0001 0055 0084 0085 0086 008C 008E 0090 0092 0095 0099 009B 009C 009D 009E
                Reg Data: 0390 000B 01C7 8078 11D2 0092 4100 8A00 0073 0003 0021 01E9 0000 000F 0000 0000
       
                      P4=   10   11   12   13   14   15   16   17   18   19   1A   1B   1C   1D   1E   1F
                Reg Addr: 009F 00A0 00A1 00A3 00A4 00A5 00A6 00A7 00B7 00B8 00BC 00BD 00BE 00BF 00D6 00D7
                Reg Data: 0000 2000 0000 0000 38DA 14D1 0048 7880 FA00 1986 0000 1525 00F0 7F00 004C 00A5
       
                      P4=   20   21   22   23   24   25   26   27   28   29   2A   2B   2C   2D   2E   2F
                Reg Addr: 00DA 00DC 00DD 00DE 00E0 00E2 00E5 00E9 00EB 00EC 00ED 00EE 00EF 00F0 00F1 00F2
                Reg Data: 2100 00D4 0000 0000 6817 0000 0000 0000 0000 0000 0000 0000 0000 001C 004A 7000
       
                      P4=   30   31   32   33   34   35   36   37   38   39   3A
                Reg Addr: 00F3 00F5 00F6 00F7 00F8 00F9 00FA 00FB 00FC 00FD 00FE
                Reg Data: 0000 0088 0020 0020 0000 0FFF 0000 0000 0000 0040 0000
       
              (P3=01) Reg Group 01:
       
                      P4=    0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F
                Reg Addr: 0061 0062 0063 0064 0075 0076 00E4 00E5 00E6 00EA 00EB 00EC 00ED 00EE 00F0 00F1
                Reg Data: 204F 0044 2630 0000 0520 0000 F20B 0000 0000 0000 0000 0D07 0000 4020 0000 0003
       
                      P4=   10   11   12   13   14   15   16   17   18   19
                Reg Addr: 00F4 00F5 00F6 00F7 00F8 00F9 00FB 00FD 00FE 00FF
                Reg Data: 0004 0002 0024 0000 0000 0000 015A 1847 0000 0400
       
<a name="RAP_TUNED_HEAD_ZONE_PARMS_DATA_11"></a>
       The following is an example of the RAP Tuned Head Parameters information that will be
       displayed.
       
          (P1=01) RAP:
       
            (P2=06) RAP Tuned Head/Zone Parms:
       
              (P3=00) Head 00:
       
                (P4=00) Reg Group 00:
       
                                               P5=    0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F
                                         Reg Addr: 0089 008A 008B 0093 0094 0096 0098 0097 0098 00B0 00B1 00B2 00B3 00B4 00B5 00B6
                  (P6=00) User Zone 00 Reg Data:   3DF4 3DF4 A1EF 0804 0CB8 0004 0500 C900 0100 9886 2868 E306 B053 8077 0080 00EE
                  (P6=01) User Zone 01 Reg Data:   3DF4 3DF4 A1EF 0804 0C60 0004 0500 C900 0100 AA78 1051 E902 B169 8075 0080 00EE
                  (P6=02) User Zone 02 Reg Data:   3DF4 3DF4 A1EF 0804 0C20 0004 0500 C900 0100 A37A 1657 DE02 AE78 807C 0080 00EE
                  (P6=80) System Zone 00 Reg Data: 3DF4 3DF4 A1EF 0804 0BC0 0004 0500 C900 0100 A47C 1253 E402 AB80 807A 0080 00EE
       
                                               P5=   10   11   12   13   14   15   16   17   18   19   1A   1B   1C   1D   1E   1F
                                         Reg Addr: 00B9 00BB 00C0 00C1 00C2 00C3 00C4 00C5 00C6 00C7 00C8 00C9 00CA 00CB 00CC 00CD
                  (P6=00) User Zone 00 Reg Data:   4026 0800 0000 0000 0000 0000 2828 2828 2828 2828 4444 4444 4444 4444 7C7C 7C7C
                  (P6=01) User Zone 01 Reg Data:   4026 0800 0000 0000 0000 0000 2828 2828 2828 2828 4444 4444 4444 4444 7C7C 7C7C
                  (P6=02) User Zone 02 Reg Data:   4026 0800 0000 0000 0000 0000 2828 2828 2828 2828 4444 4444 4444 4444 7C7C 7C7C
                  (P6=80) System Zone 00 Reg Data: 4026 0800 0000 0000 0000 0000 2828 2828 2828 2828 4444 4444 4444 4444 7C7C 7C7C
       
                                               P5=   20   21   22   23   24   25   26
                                         Reg Addr: 00CE 00CF 00D0 00D1 00D2 00D3 00D4
                  (P6=00) User Zone 00 Reg Data:   7C7C 7C00 0000 0000 0000 0000 0000
                  (P6=01) User Zone 01 Reg Data:   7C7C 7C00 0000 0000 0000 0000 0000
                  (P6=02) User Zone 02 Reg Data:   7C7C 7C00 0000 0000 0000 0000 0000
                  (P6=80) System Zone 00 Reg Data: 7C7C 7C00 0000 0000 0000 0000 0000
       
<a name="RAP_ZONE_FORMAT_BUDGET_PARMS_DATA_11"></a>
       The following is an example of the RAP Zone Format Budget Parameters information that
       will be displayed.
       
          (P1=01) RAP:
       
            (P2=07) RAP Zone Format Budget Parms:
       
              Format Budget Rev: 01
       
                                      InitialPlo  Plo    Isg   PreSrvGap PostSrvGap SeqPlo1 SeqPlo
                                        (P3=0)   (P3=1) (P3=2)  (P3=3)     (P3=4)   (P3=5)  (P3=6)
              (P4=00) User Zone 00:       1C       26     0D      20         04       14      1E
              (P4=01) User Zone 01:       1B       25     0C      20         05       13      1D
              (P4=02) User Zone 02:       1C       26     0B      20         05       13      1D
              (P4=03) User Zone 03:       1D       26     0B      20         05       14      1D
              (P4=04) User Zone 04:       1C       26     0B      21         05       13      1D
              (P4=05) User Zone 05:       1D       25     0B      21         05       14      1C
              (P4=06) User Zone 06:       1C       24     0C      21         05       14      1C
              (P4=07) User Zone 07:       1B       24     0C      21         05       13      1C
              (P4=08) User Zone 08:       1C       25     0A      21         04       13      1C
              (P4=09) User Zone 09:       1D       24     0A      20         04       14      1B
              (P4=0A) User Zone 0A:       1C       23     0A      20         04       13      1A
              (P4=0B) User Zone 0B:       1C       23     0A      20         05       13      1A
              (P4=0C) User Zone 0C:       1C       23     0A      1F         04       13      1A
              (P4=0D) User Zone 0D:       1B       22     0A      1F         04       13      1A
              (P4=0E) User Zone 0E:       1B       21     09      1F         04       12      18
              (P4=0F) User Zone 0F:       1B       20     09      1D         04       12      17
              (P4=80) System Zone 00:     1A       20     09      1D         04       11      17
       
                                      SeqPad SeqIsgWr SeqIsgRd SeqSgToRg SeqSkipRdDelay SeqSyncTo
                                      (P3=7)  (P3=8)   (P3=9)   (P3=A)       (P3=B)      (P3=C)
              (P4=00) User Zone 00:     02      13       19       08           34          34
              (P4=01) User Zone 01:     02      12       18       08           33          34
              (P4=02) User Zone 02:     02      12       18       09           34          34
              (P4=03) User Zone 03:     02      12       18       09           34          34
              (P4=04) User Zone 04:     02      12       18       09           34          34
              (P4=05) User Zone 05:     02      12       17       09           35          32
              (P4=06) User Zone 06:     02      12       17       09           35          32
              (P4=07) User Zone 07:     02      12       17       08           33          32
              (P4=08) User Zone 08:     02      11       16       08           33          32
              (P4=09) User Zone 09:     02      11       16       08           34          32
              (P4=0A) User Zone 0A:     02      11       15       08           33          31
              (P4=0B) User Zone 0B:     02      11       15       08           33          2F
              (P4=0C) User Zone 0C:     02      11       15       08           33          2F
              (P4=0D) User Zone 0D:     02      10       14       07           32          2E
              (P4=0E) User Zone 0E:     02      10       13       07           32          2D
              (P4=0F) User Zone 0F:     02      10       12       07           32          2A
              (P4=80) System Zone 00:   02      10       12       06           31          2A
       
<a name="RAP_TCC_TEMP_POINT_PARMS_DATA_11"></a>
       The following is an example of the RAP TCC Temperature Point Parameters information
       that will be displayed.
       
          (P1=01) RAP:
       
            (P2=09) RAP TCC Temp Point Parms: 19 37 FFFFFFF6
       
<a name="RAP_TUNED_PREAMP_PARMS_DATA_11"></a>
       The following is an example of the RAP Preamp Parameters information that will be
       displayed.
       
          (P1=01) RAP:
       
            (P2=0A) RAP Tuned Preamp Parms:
       
              (P3=00) Head 00:
       
                                        WrCur   WrDamp  WrDampDur
                                        (P4=0)  (P4=1)   (P4=2)
                (P5=00) User Zone 00:     0F      08       0E
                (P5=01) User Zone 01:     0F      08       0E
                (P5=02) User Zone 02:     0F      08       0E
                (P5=80) System Zone 00:   0F      08       0E
       
<a name="RAP_TCC_PREAMP_OFFSET_PARMS_DATA_11"></a>
       The following is an example of the RAP TCC Preamp Offset Parameters information that
       will be displayed.
       
          (P1=01) RAP:
       
            (P2=0B) RAP TCC Preamp Offset Parms:
       
              (P3=00) Set 00:
       
                (P4=00) Head 00:
       
                                          WrCurOff  WrDampOff  WrDampDurOff
                                           (P5=0)    (P5=1)       (P5=2)
                  (P6=00) User Zone 00:      00        00           00
                  (P6=01) User Zone 01:      00        00           00
                  (P6=02) User Zone 02:      00        00           00
                  (P6=80) System Zone 00:    00        00           00
       
              (P3=01) Set 01:
       
                (P4=00) Head 00:
       
                                          WrCurOff  WrDampOff  WrDampDurOff
                                           (P5=0)    (P5=1)       (P5=2)
                  (P6=00) User Zone 00:      00        00           00
                  (P6=01) User Zone 01:      00        00           00
                  (P6=02) User Zone 02:      00        00           00
                  (P6=80) System Zone 00:    00        00           00
       
              (P3=02) Set 02:
       
                (P4=00) Head 00:
       
                                          WrCurOff  WrDampOff  WrDampDurOff
                                           (P5=0)    (P5=1)       (P5=2)
                  (P6=00) User Zone 00:      00        00           00
                  (P6=01) User Zone 01:      00        00           00
                  (P6=02) User Zone 02:      00        00           00
                  (P6=80) System Zone 00:    00        00           00
       
<a name="RAP_CRC_DATA"></a>
       The following is an example of the RAP CRC display.
       
          (P1=01) RAP:
       
            (P2=0C) RAP CRC: 00000000
       
<a name="RAP_AFH_DRIVE_PARMS_DATA_11"></a>
       
       The following is an example of the RAP AFH drive parameters information that will be
       displayed.
       
          (P1=01) RAP:
       
            (P2=0D) RAP AFH Drive Parms:
       
               C1 (P3=x)      C2             C3             C4             C5             C6             C7
               +0.000000E-0   +0.000000E-0   +0.000000E-0   +0.000000E-0   +0.000000E-0   +0.000000E-0   +0.000000E-0
       
               C8             C9             C10            C11            C12            C13            C14
               +0.000000E-0   +0.000000E-0   +0.000000E-0   +0.000000E-0   +0.000000E-0   +0.000000E-0   +0.000000E-0
       
               C15            C16            C17            C18            C19            C20            C21
               +0.000000E-0   +0.000000E-0   +0.000000E-0   +0.000000E-0   +0.000000E-0   +0.000000E-0   +0.000000E-0
       
               RC1            RC2            RC3            RC4            RC5            RC6
               +0.000000E-0   +0.000000E-0   +0.000000E-0   +0.000000E-0   +0.000000E-0   +0.000000E-0
       
               WC1            WC2            WC3            WC4            WC5            WC6            WC7
               +0.000000E-0   +0.000000E-0   +0.000000E-0   +0.000000E-0   +0.000000E-0   +0.000000E-0   +0.000000E-0
       
               WC8            WC9            WC10
               +0.000000E-0   +0.000000E-0   +0.000000E-0
       
               Preheat Time (P3=25) = 03E8
               TargIdleClr (P3=26) =  00
               CertTemp (P3=27) = 35
       
<a name="RAP_AFH_HEAD_PARMS_DATA_11"></a>
       The following is an example of the RAP AFH head parameters information that will be
       displayed.
       
          (P1=01) RAP:
       
            (P2=0E) RAP AFH Head Parms:
       
                                      TC1 (P4=x)     TC2
              (P3=00) Head 00:        +0.000016E-3   +0.000000E-0
              (P3=01) Head 01:        +0.000016E-3   +0.000000E-0
       
<a name="RAP_AFH_HEAD_ZONE_PARMS_DATA_11"></a>
       The following is an example of the RAP AFH head/zone parameters information that will be
       displayed:
       
          (P1=01) RAP:
       
            (P2=0F) RAP AFH Head Zone Parms:
       
              Heater DAC
       
                (P3=00) Head 00:
       
                                        WrPreHt   WrHt    RdHt
                                        (P4=0)    (P4=1)  (P4=2)
                (P5=00) User Zone 00:     20       1E      1F
                (P5=01) User Zone 01:     20       1E      1F
                (P5=02) User Zone 02:     28       26      27
                (P5=80) System Zone 00:   28       26      27
       
              Clearance
       
                (P3=00) Head 00:
       
                                        W+HtClr   RHtClr  TargWrClr TargPreClr TargRdClr   TargMaintClr
                                        (P4=3)    (P4=4)  (P4=5)    (P4=6)     (P4=7)      (P4=8)
                (P5=00) User Zone 00:     20       1E      1F         20        1E         1F
                (P5=01) User Zone 01:     20       1E      1F         20        1E         1F
                (P5=02) User Zone 02:     28       26      27         28        26         27
                (P5=80) System Zone 00:   28       26      27         28        26         27
       
              SWD
       
                (P3=00) Head 00:
                                        SWDAvg   SWDDelta SWDFilt
                                        (P4=9)    (P4=A)  (P4=B)
                (P5=00) User Zone 00:     20       1E      1F
                (P5=01) User Zone 01:     20       1E      1F
                (P5=02) User Zone 02:     28       26      27
                (P5=80) System Zone 00:   28       26      27
       
<a name="RAP_VBAR_CONFIG_DATA_11"></a>
       The following is an example of the RAP Drive Configuration information that will
       be displayed.
       
          (P1=01) RAP:
       
             (P2=11) RAP VBAR Config:
       
                 Nominal Serpent Width: 32
       
                 Serpent Width  Cyl Skew Adj
          Head 0    32             0000
          Head 1    32             0000
          Head 2    32             0000
          Head 3    32             0000
          Head 4    32             0000
          Head 5    32             0000
          Head 6    32             0000
          Head 7    32             0000
       
          Num Sector Size Configs: 0C
       
          Sector Size: 0200
          Max LBA: 1C6BA999
       
          Sector Size: 0202
          Max LBA: 0000B000
       
          Sector Size: 0204
          Max LBA: 0000A000
       
       
<a name="RAP_CHANNEL_PARMS_INFO_DATA_11"></a>
       The following is an example of the RAP Tuned Head Parameters information that will be
       displayed.
       
          (P1=01) RAP:
       
            (P2=12) RAP Channel Parms Info:
       
                  Idx      Tbl [Drive=0; Zone=1]  Offset
                  (P3=xx)         (P4=xx)         (P5=xx)
                  0               0                 0
                  1               0                 2
                  2               1                 0
                  3               1                 3
       
    

  <b><i><u>Revision History:</u></i></b>
<a name="DISPLAY_MODIFY_RAP_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).
    
    if RAP_FORMAT_14_REV_2
    0012.0000   Changed Gamma values.  Added new TCS values.
    endif

<!--SUBSECTION--><a name="Display / Modify RAP revision 14"></a><hr align=left width="75%"><b> Display / Modify RAP revision 14 (Level 2, 7 'I,1')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command displays and optionally modifies the value of the specified read adaptive
    parameter.

  <b><i><u>Quick Help:</u></i></b>
<a name="DISPLAY_MODIFY_RAP_QUICK_HELP"></a>
    "DisplayModifyRap, I[ParmValue],1,[ParmId],[P3],[P4],[P5],[P6],[UpdateOpts]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="DISPLAY_MODIFY_RAP_PARM"></a>
    0 - P0 (New RAP Value).
    
        If this parameter is entered, the adaptive value specified by command
        parameters 1 though 7 will be set equal to the value of this parameter.
        If this parameter is not entered, the RAP values specified by command
        parameters 1 and 2 will be displayed.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: None
    
    1 - P1 (RAP Group ID = 1).
    
        This parameter specifies the RAP ID (1).
    
          Type:    Unsigned 32-bit value
    
          Range:   1 is the only valid value.
    
          Default: NA
    
    2 - P2 (RAP Value ID).
    
        This parameter specifies the ID of the RAP value to be displayed or modified.
        If Parameter 0 is not entered, entering a value of zero for  this parameter
        will display all of the parameters in the group RAP.
    
<a name="RAP_PARM_IDS"></a>
          
          The Adaptive Parameter IDs and the values of parameters 3-6
          are defined as follows:
          
            0x00 = All RAP Parameters
          
                     Parameters 3-6 are not used
          
            0x01 = Drive Configuration
          
                     Parameters 3-6 are not used
          
            0x02 = Temperature Sensor Configuration
          
                     Parameters 3-6 are not used
          
            0x03 = Zone Configuration
          
                     Parameters 3-6 are not used
          
            0x04 = Tuned Drive parameters
          
                     Parameter 3 = Register Group
                     Parameter 4 = Register Index
                     Parameter 5 = not used
                     Parameter 6 = not used
          
            0x05 = Tuned Zone parameters
          
                     Parameter 3 = Register Group
                     Parameter 4 = Register Index
          
                     Parameter 5 = Zone Number
          
                         0x00 = User Zone 0
                         0x01 = User Zone 1
                                 .
                                 .
                                 .
                         0x80 = System Zone
          
                     Parameter 6 = not used
          
            0x06 = Tuned Head parameters
          
                     Parameter 3 = Head
                     Parameter 4 = Register Group
                     Parameter 5 = Register Index
          
                     Parameter 6 = Zone Number
          
                         0x00 = User Zone 0
                         0x01 = User Zone 1
                                 .
                                 .
                                 .
                         0x80 = System Zone
          
            0x07 = Zone Format Budget parameters
          
                     Parameter 3 = Zone Format Budget Parameter Index
          
                     Parameter 4 = Zone Number
          
                         0x00 = User Zone 0
                         0x01 = User Zone 1
                                 .
                                 .
                                 .
                         0x80 = System Zone
          
                     Parameter 5 = not used
                     Parameter 6 = not used
          
            0x08 = Head Format Budget parameters
          
                     Parameter 3 = Head
          
                     Parameter 4 = Zone Number
          
                         0x00 = User Zone 0
                         0x01 = User Zone 1
                                 .
                                 .
                                 .
                         0x80 = System Zone
          
                     Parameter 5 = not used
                     Parameter 6 = not used
          
            0x09 = TCC Preamp Temperature Point parameters
          
                     Parameters 3-6 are not used
          
            0x0A = TCC Preamp parameters
          
                     Parameter 3 = Head
                     Parameter 4 = TCC Preamp Parameter Index
          
                     Parameter 5 = Zone Number
          
                         0x00 = User Zone 0
                         0x01 = User Zone 1
                                 .
                                 .
                                 .
                         0x80 = System Zone
          
                     Parameter 6 = not used
          
            0x0B = TCC Preamp Offset parameters
          
                     Parameter 3 = Set Number
                     Parameter 4 = Head
                     Parameter 5 = TCC Preamp Parameter Index
          
                     Parameter 6 = Zone Number
          
                         0x00 = User Zone 0
                         0x01 = User Zone 1
                                 .
                                 .
                                 .
                         0x80 = System Zone
          
            0x0C = RAP CRC
          
                     Parameters 3-6 are not used
          
            0x0D = AFH drive parameters
                     Parameter 3 = AFH drive parameter index
                        NOTE: Enter value in IEEE 754 float 32 bit representation!
          
                     Parameters 4-6 are not used
          
            0x0E = AFH head parameters
          
                     Parameter 3 = Head
                     Parameter 4 = AFH head parameter index
                        NOTE: Enter value in IEEE 754 float 32 bit representation!
          
                     Parameter 5-6 = not used
          
            0x0F = AFH head/zone parameters
          
                     Parameter 3 = Head
                     Parameter 4 = AFH head/zone parameter index
                     Parameter 5 = Zone Number
          
                         0x00 = User Zone 0
                         0x01 = User Zone 1
                                 .
                                 .
                                 .
                         0x80 = System Zone
          
                     Parameter 6 = not used
          
            0x10 = Shared registers
          
                     Parameter 3 = Set
                     Parameter 4 = Head
                     Parameter 5 = Parameter index
                     Parameter 6 = Zone Number
          
                         0x00 = User Zone 0
                         0x01 = User Zone 1
                                 .
                                 .
                                 .
                         0x80 = System Zone
          
            0x11 = VBAR Configuration
          
                     Parameters 3-6 are not used
          
            0x12 = Channel Parameters Information Table
          
                     Parameter 0 = Index
                     Parameter 3 = Table
                     Parameter 4 = Table offset
          
            0xFF = RAP Table of Contents
          
                     Parameters 3-6 are not used
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: 0
    
    3 - P3 (select value to be modified).
    
        If Parameter 0 is entered, this parameter is used to select the value to be
        modified.  The definition of this parameter depends on the value entered for
        Parameter 2.  See the Parameter 2 description for more information.
      
        If Parameter 0 is not entered and Parameter 1 is set to display RAP, this
        parameter will specifies the heads to display their adaptive value based on
        the display mode that is set by Level T O comamnd.  With Verbose Formatted
        ASCII Output Mode, the adaptive value on all heads will be displayed.  With
        Formatted ASCII Output Mode, if Parameter3 is not entered only the adaptive
        value on the existing heads will be displayed; if Parameter3 is entered only
        the adaptive value on the requested head will be displayed. Otherwise this
        parameter is not used.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: 0
    
    4 - P4 (select value to be modified).
    
        If Parameter 0 is entered, this parameter is used to select the value to be
        modified.  The definition of this parameter depends on the value entered for
        Parameter 2.  See the Parameter 2 description for more information.
      
        If Parameter 0 is not entered, this parameter is not used.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: 0
    
    5 - P5 (select value to be modified).
    
        If Parameter 0 is entered, this parameter is used to select the value to be
        modified.  The definition of this parameter depends on the value entered for
        Parameter 2.  See the Parameter 2 description for more information.
      
        If Parameter 0 is not entered, this parameter is not used.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: 0
    
    6 - P6 (select value to be modified).
    
        If Parameter 0 is entered, this parameter is used to select the value to be
        modified.  The definition of this parameter depends on the value entered for
        Parameter 2.  See the Parameter 2 description for more information.
      
        If Parameter 0 is not entered, this parameter is not used.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: 0
    
    7 - RAP Update Option.
    
        This parameter is a bit significant value that specifies how the modified
        RAP values are to be applied.  The bits are defined as follows:
    
            Bits 31-2: not used
    
            Bit 1: Enable Track Format update.
    
                   If this bit is equal to 1, the Track Format will be updated based on the
                   RAP values that were modified.  If this bit is equal to 0, the
                   Track Format will not be modified.
    
            Bit 0: Enable Channel Parameter Reload.
    
                   If this bit is equal to 1, the Channel Registers will be updated based
                   on the RAP values that were modified.  If this bit is equal
                   to 0, the Channel Registers will not be modified.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: 0 (Disable Track Format Update and Channel Parameter Reload)
    

  <b><i><u>Output Data:</u></i></b>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
<a name="RAP_DATA_14"></a>
    If no error occurred and the RAP data is being displayed ...
    
<a name="RAP_DRIVE_CONFIG_DATA_14"></a>
       The following is an example of the RAP Drive Configuration information that will
       be displayed.
       
          (P1=01) RAP:
       
             (P2=01) RAP Drive Config:
       
                Format Rev: 0010
                Contents Rev: 0D00
                Drive Serial Number: Invalid
                RAP Heads: 0001
                RAP User Zones: 0010
                RAP System Zones: 0001
                Tracks/zone:
                Alts/volume:
                Sec/track:
                Total Cyls:
       
<a name="RAP_TEMP_SENSOR_CONFIG_DATA"></a>
       The following is an example of the RAP Temperature Sensor Configuration information
       that will be displayed.
       
          (P1=01) RAP:
       
            (P2=02) RAP Temp Sensor Config:
       
              Thermistor Temp Sensor Offset: 00
              Thermistor Temp Sensor Scale: 64
              Thermistor Temp Table Elements: 1E
       
              Thermistor Temp Lookup Table:
                                 0    1    2    3    4    5    6    7
                Temperature:  FFD0 FFDA FFE3 FFEC FFFE 000F 001F 002F
                A to D Value: FF91 FF8D FF89 FF86 FF7E FF76 FF6E FF67
       
                                 8    9    A    B    C    D    E    F
                Temperature:  003E 004D 005B 0076 0090 00A9 00D9 0107
                A to D Value: FF5F FF57 FF50 FF40 FF31 FF21 FF02 FEE3
       
                                10   11   12   13   14   15   16   17
                Temperature:  0138 016D 01A9 01CA 01EE 0214 023E 0254
                A to D Value: FEC5 FEA6 FE87 FE77 FE68 FE58 FE49 FE41
       
                                18   19   1A   1B   1C   1D
                Temperature:  026B 0283 029C 02B6 02D2 02EE
                A to D Value: FE3A FE32 FE2A FE22 FE1B FE13
       
<a name="RAP_VBAR_ZONE_CONFIG_DATA_14"></a>
       The following is an example of the RAP Zone Configuration information that will be
       displayed.
       
          (P1=01) RAP:
       
            (P2=03) RAP VBAR Zone Config:
       
             If firmware supports ID System Partition Location:
                NominalFirstSysTrack: 0002448A
                NumSysTracks: 0000012C
                SysSpareTracksPerHd: 0F
                ActiveSerpentsPerZoneGroup: 00
       
             If firmware supports MD System Partition Location (or a location enveloped
             by the User Partition):
                SysStartMinizoneIndex: 02D6
                SysNumMinizones: 0002
                LBAsPerSysZoneCopy: 000132EA
                ActiveSerpentsPerZoneGroup: 00
       
       
                Head 0
                                     Minizones
                   User Zone   00:    127
                   User Zone   01:    127
                   User Zone   02:    12E
                   User Zone   03:    A1
                   User Zone   04:    8A
                   User Zone   05:    A5
                   User Zone   06:    CC
                   User Zone   07:    103
                   User Zone   08:    9B
       
<a name="RAP_TUNED_DRIVE_PARMS_DATA_14"></a>
       The following is an example of the RAP Tuned Drive Parameters information that will be
       displayed.
       
          (P1=01) RAP:
       
            (P2=04) Tuned Drive Parms:
       
              (P3=00) Reg Group 00:
       
                      P4=    0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F
                Reg Addr: 0000 0001 0055 0084 0085 0086 008C 008E 0090 0092 0095 0099 009B 009C 009D 009E
                Reg Data: 0390 000B 01C7 8078 11D2 0092 4100 8A00 0073 0003 0021 01E9 0000 000F 0000 0000
       
                      P4=   10   11   12   13   14   15   16   17   18   19   1A   1B   1C   1D   1E   1F
                Reg Addr: 009F 00A0 00A1 00A3 00A4 00A5 00A6 00A7 00B7 00B8 00BC 00BD 00BE 00BF 00D6 00D7
                Reg Data: 0000 2000 0000 0000 38DA 14D1 0048 7880 FA00 1986 0000 1525 00F0 7F00 004C 00A5
       
                      P4=   20   21   22   23   24   25   26   27   28   29   2A   2B   2C   2D   2E   2F
                Reg Addr: 00DA 00DC 00DD 00DE 00E0 00E2 00E5 00E9 00EB 00EC 00ED 00EE 00EF 00F0 00F1 00F2
                Reg Data: 2100 00D4 0000 0000 6817 0000 0000 0000 0000 0000 0000 0000 0000 001C 004A 7000
       
                      P4=   30   31   32   33   34   35   36   37   38   39   3A
                Reg Addr: 00F3 00F5 00F6 00F7 00F8 00F9 00FA 00FB 00FC 00FD 00FE
                Reg Data: 0000 0088 0020 0020 0000 0FFF 0000 0000 0000 0040 0000
       
              (P3=01) Reg Group 01:
       
                      P4=    0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F
                Reg Addr: 0061 0062 0063 0064 0075 0076 00E4 00E5 00E6 00EA 00EB 00EC 00ED 00EE 00F0 00F1
                Reg Data: 204F 0044 2630 0000 0520 0000 F20B 0000 0000 0000 0000 0D07 0000 4020 0000 0003
       
                      P4=   10   11   12   13   14   15   16   17   18   19
                Reg Addr: 00F4 00F5 00F6 00F7 00F8 00F9 00FB 00FD 00FE 00FF
                Reg Data: 0004 0002 0024 0000 0000 0000 015A 1847 0000 0400
       
<a name="RAP_TUNED_HEAD_ZONE_PARMS_DATA_14"></a>
       The following is an example of the RAP Tuned Head Parameters information that will be
       displayed.
       
          (P1=01) RAP:
       
            (P2=06) RAP Tuned Head/Zone Parms:
       
              (P3=00) Head 00:
       
                (P4=00) Reg Group 00:
       
                                               P5=    0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F
                                         Reg Addr: 0089 008A 008B 0093 0094 0096 0098 0097 0098 00B0 00B1 00B2 00B3 00B4 00B5 00B6
                  (P6=00) User Zone 00 Reg Data:   3DF4 3DF4 A1EF 0804 0CB8 0004 0500 C900 0100 9886 2868 E306 B053 8077 0080 00EE
                  (P6=01) User Zone 01 Reg Data:   3DF4 3DF4 A1EF 0804 0C60 0004 0500 C900 0100 AA78 1051 E902 B169 8075 0080 00EE
                  (P6=02) User Zone 02 Reg Data:   3DF4 3DF4 A1EF 0804 0C20 0004 0500 C900 0100 A37A 1657 DE02 AE78 807C 0080 00EE
                  (P6=80) System Zone 00 Reg Data: 3DF4 3DF4 A1EF 0804 0BC0 0004 0500 C900 0100 A47C 1253 E402 AB80 807A 0080 00EE
       
                                               P5=   10   11   12   13   14   15   16   17   18   19   1A   1B   1C   1D   1E   1F
                                         Reg Addr: 00B9 00BB 00C0 00C1 00C2 00C3 00C4 00C5 00C6 00C7 00C8 00C9 00CA 00CB 00CC 00CD
                  (P6=00) User Zone 00 Reg Data:   4026 0800 0000 0000 0000 0000 2828 2828 2828 2828 4444 4444 4444 4444 7C7C 7C7C
                  (P6=01) User Zone 01 Reg Data:   4026 0800 0000 0000 0000 0000 2828 2828 2828 2828 4444 4444 4444 4444 7C7C 7C7C
                  (P6=02) User Zone 02 Reg Data:   4026 0800 0000 0000 0000 0000 2828 2828 2828 2828 4444 4444 4444 4444 7C7C 7C7C
                  (P6=80) System Zone 00 Reg Data: 4026 0800 0000 0000 0000 0000 2828 2828 2828 2828 4444 4444 4444 4444 7C7C 7C7C
       
                                               P5=   20   21   22   23   24   25   26
                                         Reg Addr: 00CE 00CF 00D0 00D1 00D2 00D3 00D4
                  (P6=00) User Zone 00 Reg Data:   7C7C 7C00 0000 0000 0000 0000 0000
                  (P6=01) User Zone 01 Reg Data:   7C7C 7C00 0000 0000 0000 0000 0000
                  (P6=02) User Zone 02 Reg Data:   7C7C 7C00 0000 0000 0000 0000 0000
                  (P6=80) System Zone 00 Reg Data: 7C7C 7C00 0000 0000 0000 0000 0000
       
<a name="RAP_ZONE_FORMAT_BUDGET_PARMS_DATA_14"></a>
       The following is an example of the RAP Zone Format Budget Parameters information that
       will be displayed.
       
          (P1=01) RAP:
       
            (P2=07) RAP Zone Format Budget Parms:
       
              Format Budget Rev: 01
       
                                      InitialPlo  Plo    Isg   PreSrvGap PostSrvGap SeqPlo1 SeqPlo
                                        (P3=0)   (P3=1) (P3=2)  (P3=3)     (P3=4)   (P3=5)  (P3=6)
              (P4=00) User Zone 00:       1C       26     0D      20         04       14      1E
              (P4=01) User Zone 01:       1B       25     0C      20         05       13      1D
              (P4=02) User Zone 02:       1C       26     0B      20         05       13      1D
              (P4=03) User Zone 03:       1D       26     0B      20         05       14      1D
              (P4=04) User Zone 04:       1C       26     0B      21         05       13      1D
              (P4=05) User Zone 05:       1D       25     0B      21         05       14      1C
              (P4=06) User Zone 06:       1C       24     0C      21         05       14      1C
              (P4=07) User Zone 07:       1B       24     0C      21         05       13      1C
              (P4=08) User Zone 08:       1C       25     0A      21         04       13      1C
              (P4=09) User Zone 09:       1D       24     0A      20         04       14      1B
              (P4=0A) User Zone 0A:       1C       23     0A      20         04       13      1A
              (P4=0B) User Zone 0B:       1C       23     0A      20         05       13      1A
              (P4=0C) User Zone 0C:       1C       23     0A      1F         04       13      1A
              (P4=0D) User Zone 0D:       1B       22     0A      1F         04       13      1A
              (P4=0E) User Zone 0E:       1B       21     09      1F         04       12      18
              (P4=0F) User Zone 0F:       1B       20     09      1D         04       12      17
              (P4=80) System Zone 00:     1A       20     09      1D         04       11      17
       
                                      SeqPad SeqIsgWr SeqIsgRd SeqSgToRg SeqSkipRdDelay SeqSyncTo
                                      (P3=7)  (P3=8)   (P3=9)   (P3=A)       (P3=B)      (P3=C)
              (P4=00) User Zone 00:     02      13       19       08           34          34
              (P4=01) User Zone 01:     02      12       18       08           33          34
              (P4=02) User Zone 02:     02      12       18       09           34          34
              (P4=03) User Zone 03:     02      12       18       09           34          34
              (P4=04) User Zone 04:     02      12       18       09           34          34
              (P4=05) User Zone 05:     02      12       17       09           35          32
              (P4=06) User Zone 06:     02      12       17       09           35          32
              (P4=07) User Zone 07:     02      12       17       08           33          32
              (P4=08) User Zone 08:     02      11       16       08           33          32
              (P4=09) User Zone 09:     02      11       16       08           34          32
              (P4=0A) User Zone 0A:     02      11       15       08           33          31
              (P4=0B) User Zone 0B:     02      11       15       08           33          2F
              (P4=0C) User Zone 0C:     02      11       15       08           33          2F
              (P4=0D) User Zone 0D:     02      10       14       07           32          2E
              (P4=0E) User Zone 0E:     02      10       13       07           32          2D
              (P4=0F) User Zone 0F:     02      10       12       07           32          2A
              (P4=80) System Zone 00:   02      10       12       06           31          2A
       
<a name="RAP_TCC_TEMP_POINT_PARMS_DATA_14"></a>
       The following is an example of the RAP TCC Temperature Point Parameters information
       that will be displayed.
       
          (P1=01) RAP:
       
            (P2=09) RAP TCC Temp Point Parms: 19 37 FFFFFFF6
       
<a name="RAP_TUNED_PREAMP_PARMS_DATA_14"></a>
       The following is an example of the RAP Preamp Parameters information that will be
       displayed.
       
          (P1=01) RAP:
       
            (P2=0A) RAP Tuned Preamp Parms:
       
              (P3=00) Head 00:
       
                                        WrCur   WrDamp  WrDampDur
                                        (P4=0)  (P4=1)   (P4=2)
                (P5=00) User Zone 00:     0F      08       0E
                (P5=01) User Zone 01:     0F      08       0E
                (P5=02) User Zone 02:     0F      08       0E
                (P5=80) System Zone 00:   0F      08       0E
       
<a name="RAP_TCC_PREAMP_OFFSET_PARMS_DATA_14"></a>
       The following is an example of the RAP TCC Preamp Offset Parameters information that
       will be displayed.
       
          (P1=01) RAP:
       
            (P2=0B) RAP TCC Preamp Offset Parms:
       
              (P3=00) Set 00:
       
                (P4=00) Head 00:
       
                                          WrCurOff  WrDampOff  WrDampDurOff
                                           (P5=0)    (P5=1)       (P5=2)
                  (P6=00) User Zone 00:      00        00           00
                  (P6=01) User Zone 01:      00        00           00
                  (P6=02) User Zone 02:      00        00           00
                  (P6=80) System Zone 00:    00        00           00
       
              (P3=01) Set 01:
       
                (P4=00) Head 00:
       
                                          WrCurOff  WrDampOff  WrDampDurOff
                                           (P5=0)    (P5=1)       (P5=2)
                  (P6=00) User Zone 00:      00        00           00
                  (P6=01) User Zone 01:      00        00           00
                  (P6=02) User Zone 02:      00        00           00
                  (P6=80) System Zone 00:    00        00           00
       
              (P3=02) Set 02:
       
                (P4=00) Head 00:
       
                                          WrCurOff  WrDampOff  WrDampDurOff
                                           (P5=0)    (P5=1)       (P5=2)
                  (P6=00) User Zone 00:      00        00           00
                  (P6=01) User Zone 01:      00        00           00
                  (P6=02) User Zone 02:      00        00           00
                  (P6=80) System Zone 00:    00        00           00
       
<a name="RAP_CRC_DATA"></a>
       The following is an example of the RAP CRC display.
       
          (P1=01) RAP:
       
            (P2=0C) RAP CRC: 00000000
       
<a name="RAP_AFH_DRIVE_PARMS_DATA_14"></a>
       
       The following is an example of the RAP AFH drive parameters information that will be
       displayed.
       
          (P1=01) RAP:
       
            (P2=0D) RAP AFH Drive Parms:
       
               C1 (P3=x)      C2             C3             C4             C5             C6             C7
               +0.000000E-0   +0.000000E-0   +0.000000E-0   +0.000000E-0   +0.000000E-0   +0.000000E-0   +0.000000E-0
       
               C8             C9             C10            C11            C12            C13            C14
               +0.000000E-0   +0.000000E-0   +0.000000E-0   +0.000000E-0   +0.000000E-0   +0.000000E-0   +0.000000E-0
       
               C15            C16            C17            C18            C19            C20            C21
               +0.000000E-0   +0.000000E-0   +0.000000E-0   +0.000000E-0   +0.000000E-0   +0.000000E-0   +0.000000E-0
       
               RC1            RC2            RC3            RC4            RC5            RC6
               +0.000000E-0   +0.000000E-0   +0.000000E-0   +0.000000E-0   +0.000000E-0   +0.000000E-0
       
               WC1            WC2            WC3            WC4            WC5            WC6            WC7
               +0.000000E-0   +0.000000E-0   +0.000000E-0   +0.000000E-0   +0.000000E-0   +0.000000E-0   +0.000000E-0
       
               WC8            WC9            WC10
               +0.000000E-0   +0.000000E-0   +0.000000E-0
       
               Preheat Time (P3=25) = 03E8
               TargIdleClr (P3=26) =  00
               CertTemp (P3=27) = 35
       
<a name="RAP_AFH_HEAD_PARMS_DATA_14"></a>
       The following is an example of the RAP AFH head parameters information that will be
       displayed.
       
          (P1=01) RAP:
       
            (P2=0E) RAP AFH Head Parms:
       
                                      TC1 (P4=x)     TC2
              (P3=00) Head 00:        +0.000016E-3   +0.000000E-0
              (P3=01) Head 01:        +0.000016E-3   +0.000000E-0
       
<a name="RAP_AFH_HEAD_ZONE_PARMS_DATA_14"></a>
       The following is an example of the RAP AFH head/zone parameters information that will be
       displayed:
       
          (P1=01) RAP:
       
            (P2=0F) RAP AFH Head Zone Parms:
       
              Heater DAC
       
                (P3=00) Head 00:
       
                                        WrPreHt   WrHt    RdHt
                                        (P4=0)    (P4=1)  (P4=2)
                (P5=00) User Zone 00:     20       1E      1F
                (P5=01) User Zone 01:     20       1E      1F
                (P5=02) User Zone 02:     28       26      27
                (P5=80) System Zone 00:   28       26      27
       
              Clearance
       
                (P3=00) Head 00:
       
                                        W+HtClr   RHtClr  TargWrClr TargPreClr TargRdClr   TargMaintClr
                                        (P4=3)    (P4=4)  (P4=5)    (P4=6)     (P4=7)      (P4=8)
                (P5=00) User Zone 00:     20       1E      1F         20        1E         1F
                (P5=01) User Zone 01:     20       1E      1F         20        1E         1F
                (P5=02) User Zone 02:     28       26      27         28        26         27
                (P5=80) System Zone 00:   28       26      27         28        26         27
       
              SWD
       
                (P3=00) Head 00:
                                        SWDAvg   SWDDelta SWDFilt
                                        (P4=9)    (P4=A)  (P4=B)
                (P5=00) User Zone 00:     20       1E      1F
                (P5=01) User Zone 01:     20       1E      1F
                (P5=02) User Zone 02:     28       26      27
                (P5=80) System Zone 00:   28       26      27
       
<a name="RAP_VBAR_CONFIG_DATA_14"></a>
       The following is an example of the RAP Drive Configuration information that will
       be displayed.
       
          (P1=01) RAP:
       
             (P2=11) RAP VBAR Config:
       
                 Nominal Serpent Width: 32
       
                 Serpent Width  Cyl Skew Adj
          Head 0    32             0000
          Head 1    32             0000
          Head 2    32             0000
          Head 3    32             0000
          Head 4    32             0000
          Head 5    32             0000
          Head 6    32             0000
          Head 7    32             0000
       
          Num Sector Size Configs: 0C
       
          Sector Size: 0200
          Max LBA: 1C6BA999
       
          Sector Size: 0202
          Max LBA: 0000B000
       
          Sector Size: 0204
          Max LBA: 0000A000
       
       
<a name="RAP_CHANNEL_PARMS_INFO_DATA_14"></a>
       The following is an example of the RAP Channel Parameters information that will be
       displayed.
       
          (P1=01) RAP:
       
            (P2=12) RAP Channel Parms Info:
       
                  Idx      Tbl [Drive=0; Zone=1]  Offset
                  (P3=xx)         (P4=xx)         (P5=xx)
                  0               0                 0
                  1               0                 2
                  2               1                 0
                  3               1                 3
       
    

  <b><i><u>Revision History:</u></i></b>
<a name="DISPLAY_MODIFY_RAP_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).
    
    if RAP_FORMAT_14_REV_2
    0012.0000   Changed Gamma values.  Added new TCS values.
    endif

<a name="DISPLAY_MODIFY_RW_WORKING_PARMS_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Display / Modify RW Working Parameters"></a><hr align=left width="75%"><b> Display / Modify RW Working Parameters (Level 2, 7 'I,3')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command displays and optionally modifies the specified value of the Read/Write
    Working Parameters.

  <b><i><u>Quick Help:</u></i></b>
<a name="DISPLAY_MODIFY_RW_WORKING_PARMS_QUICK_HELP"></a>
    "DisplayModifyRwWorkingParms, I[ParmValue],3,[ParmId],[P3],[P4],,,[P7]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="DISPLAY_MODIFY_RW_WORKING_PARMS_INPUT_PARAMETER"></a>
    0 - P0 (New RW Working Parameter Value).
    
        If this parameter is entered, the adaptive value specified by command
        parameters 3 through 5 will be set equal to the value of this parameter.
    
          Type:    Unsigned 32-bit value.
    
          Range:   0 to 0xFFFFFFFF
    
          Default: None.
    
    1 - P1 (RW Working Parameter Group ID = 3).
    
        This parameter specifies the Group ID of the RW Working Parameters, which is 3.
    
          Type:    Unsigned 32-bit value.
    
          Range:   3 is the only valid value.
    
          Default: None.
    
    2 - P2 (Head).
    
        This parameter specifies the head.  If no head is specified, all heads' data are
        displayed.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: None
    
    3 - P3 (RW Working Parameter Subgroup ID).
    
        This parameter specifies the RW Working Parameters Subgroup ID.  The following are
        valid values for the Subgroup ID:
<a name="RW_WORKING_PARAMETERS_SUBGROUP_IDS"></a>
        0x00: WRITE_CURRENT_OFS
        0x01: WRITE_DAMPING_OFS
        0x02: WRITE_DAMPING_DUR_OFS
        0x03: TWEAK_TEMP_OFS
        0x04: WRITE_PREHEAT_OFS
        0x05: WRITE_HEAT_OFS
        0x06: READ_HEAT_OFS
        0x07: MAINTENANCE_HEAT_OFS
        0x08: RANGE_BITS_OFS
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: 0
    
    4 - P4 (Zone).
    
        This parameter specifies the zone.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: 0
    

  <b><i><u>Output Data:</u></i></b>
<a name="DISPLAY_MODIFY_RW_WORKING_PARMS_OUTPUT_DATA"></a>
    
    
    (P1=03) RW Working:
    
       (P2=00) Head 00:
    
                                 WrkIW    WrkIWDamp   WrkIWDur    WrkTweakTemp
                                 (P3=00)  (P3=01)     (P3=02)     (P3=03)
          (P4=00) User Zone 00:   07       02          05          1A
          (P4=01) User Zone 01:   07       02          05          1A
             .                    .        .           .           .
             .                    .        .           .           .
             .                    .        .           .           .
          (P4=0F) User Zone 0F:   07       02          05          1A
          (P4=10) User Zone 10:   07       02          05          1A
          (P4=80) System Zone 00: 07       02          05          1A
    
                                 WrkPreHt WrkWriteHt  WrkReadHt   WrkMaintHt  WrkHtRange
                                 (P3=04)  (P3=05)     (P3=06)     (P3=07)
          (P4=00) User Zone 00:   2D       26          1A         29          00
          (P4=01) User Zone 01:   31       2A          1E         31          00
             .                    .        .           .          .           .
             .                    .        .           .          .           .
             .                    .        .           .          .           .
          (P4=0F) User Zone 0F:   29       22          14         29          00
          (P4=10) User Zone 10:   29       22          14         29          00
          (P4=80) System Zone 00: 29       23          14         1E          00
    

  <b><i><u>Revision History:</u></i></b>
<a name="DISPLAY_MODIFY_RW_WORKING_PARMS_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="DISPLAY_MODIFY_SAP_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Display / Modify SAP"></a><hr align=left width="75%"><b> Display / Modify SAP (Level 2, 7 'I,2')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command displays the values of the specified servo adaptive parameters.

  <b><i><u>Quick Help:</u></i></b>
<a name="DISPLAY_MODIFY_SAP_QUICK_HELP"></a>
    "DisplayModifySap, I[ParmValue],2,[ParmId],[P3],[P4],[P5]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="DISPLAY_MODIFY_SAP_INPUT_PARAMETER"></a>
     0 - New SAP Value.
    
         If this parameter is entered, the adaptive value specified by command
         parameters 3 through 5 will be set equal to the value of this parameter.
    
           Type:    Unsigned 32-bit value.
    
           Range:   0 to 0xFFFFFFFF
    
           Default: None.
    
     1 - SAP Group ID.
    
         This parameter specifies the Group ID of the SAP, which is 2.
    
           Type:    Unsigned 32-bit value.
    
           Range:   2 is the only valid value.
    
           Default: None.
    
     2 - SAP Subgroup ID.
    
         This parameter specifies the ID of the SAP value to be displayed or modified.
         If Parameter 0 is not entered, entering a value of zero for this parameter
         will display all of the parameters in the SAP.  The following SAP parameters are
         supported:
<a name="SAP_PARM_SUBGROUP_IDS"></a>
         0x00: RAW_HEX_SUBGROUP_ID - Raw Hex dump of the entire SAP
         
         0x01: ALL_SAP_SUBGROUPS_SUBGROUP_ID - All SAP Subgroups ID
         
         0x02: MAX_HEAD_SUBGROUP_ID - Max Head (maximum head supported by servo)
         
         0x03: MR_BIAS_SUBGROUP_ID - MR Bias Table (table of MR bias values)
         
         0x04: MAX_MR_BIAS_SUBGROUP_ID - Max MR Bias Table (table of Max MR bias values)
         
         0x05: BIAS_TABLE_SUBGROUP_ID - Bias Table (table of Flex Bias values)
         
         0x06: BIAS_HYST_TABLE_SUBGROUP_ID - Bias Hysteresis Table (table of Bias Hysteresis values)
         
         0xFF: SAP_TOC_SUBGROUP_ID - Table of Contents (all subgroups currently supported by this command)
    
           Type:    Unsigned 32-bit value
    
           Range:   0 to 0xFFFFFFFF
    
           Default: 0
    
     3 - Parameter 3.
    
         This parameter's meaning depends on the SAP Subgroup ID (P2).  The information about
         it's meaning is available in the display of the SAP data.
    
           Type:    Unsigned 32-bit value
    
           Range:   0 to 0xFFFFFFFF
    
           Default: None.
    
    <font color=red>
     4 - Parameter 4.
    
         This parameter's meaning depends on the SAP Subgroup ID (P2).  The information about
         it's meaning is available in the display of the SAP data.
    
           Type:    Unsigned 32-bit value
    
           Range:   0 to 0xFFFFFFFF
    
           Default: 0
    
    </font>
    <font color=red>
     5 - Parameter 5.
    
         This parameter's meaning depends on the SAP Subgroup ID (P2).  The information about
         it's meaning is available in the display of the SAP data.
    
           Type:    Unsigned 32-bit value
    
           Range:   0 to 0xFFFFFFFF
    
           Default: 0
    
    </font>

  <b><i><u>Output Data:</u></i></b>
<a name="DISPLAY_MODIFY_SAP_OUTPUT_DATA"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
    
    If no error occurred, then the output of this command will be displayed as follows:
<a name="GET_SAP_DATA"></a>
<a name="DISPLAY_SAP_HEX_DUMP_DATA"></a>
    If the option to display a raw hex dump of the SAP was selected, then the following
    will be displayed:
    
       Addr 0000: xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx
       Addr 0010: xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx
       Addr 0020: xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx
       ......
       where xx is the SAP data at the specified index position
    
<a name="READ_MODIFY_SAP_DATA"></a>
<a name="DISPLAY_SAP_TOC_DATA"></a>
    If the option to display the Display/Modify SAP Table Of Contents was selected, then the
    following will be displayed:
    
       (P2=00) SAP: Raw Hex dump of the entire SAP
       (P2=01) SAP: All SAP Subgroups
       (P2=02) SAP: Max Head (maximum head supported by servo)
       (P2=03) SAP: MR Bias Table (table of MR bias values)
       (P2=04) SAP: Max MR Bias Table (table of Max MR bias values)
       (P2=05) SAP: Bias Table (table of Flex Bias values)
       (P2=06) SAP: Bias Hysteresis Table (table of Bias Hysteresis values)
       (P2=FF) SAP: Table of Contents
    
<a name="DISPLAY_MAX_HEAD_SAP_OUTPUT_DATA"></a>
    If the option to display servo's Max Head SAP value is selected, then the following is
    displayed:
    
       (P2=ss) Max Head: hh
    
       where:
       ss = Subgroup ID
       hh = Max Head
    
<a name="DISPLAY_MR_BIAS_SAP_OUTPUT_DATA"></a>
    If the option to display the entire MR Bias table is selected, then the following is
    displayed:
    
                         (P3=0) ... (P3=x)
       (P2=ss) MR Bias:   aabb  ...  aabb
    
       where:
         ss = Subgroup ID
          x = Max Head supported by servo
       aabb = MR Bias value (including register address)
    
    If the option to display a single MR Bias value is selected, then the following is displayed:
    
                         (P3=h)
       (P2=ss) MR Bias:   aabb
    
       where:
         ss = Subgroup ID
          h = Head
       aabb = MR Bias value (including register address)
    
<a name="DISPLAY_MAX_MR_BIAS_SAP_OUTPUT_DATA"></a>
    If the option to display the entire Max MR Bias table is selected, then the following is
    displayed:
    
                             (P3=0) ... (P3=m)
       (P2=ss) Max MR Bias:   aaaa  ...  aaaa
    
       where:
         ss = Subgroup ID
          m = Max Head supported by servo
       aaaa = Max MR Bias value
    
    If the option to display a single Max MR Bias value is selected, then the following is
    displayed:
    
                             (P3=h)
       (P2=ss) Max MR Bias:   aaaa
    
       where:
         ss = Subgroup ID
          h = Head
       aaaa = Max MR Bias value
    
<a name="DISPLAY_BIAS_TABLE_SAP_OUTPUT_DATA"></a>
    If the option to display servo's Flex Bias Table was selected, then the following will be
    displayed for each of the requested table entries.
    
                       Bias Value
       (P3=aaaa)       bbbb
    
       where:
         aaaa = is the Offset from the start of the Bias Table
         bbbb = is the Bias value at that table location.
    
<a name="DISPLAY_BIAS_HYSTERESIS_TABLE_SAP_OUTPUT_DATA"></a>
    If the option to display servo's Bias Hysteresis Table was selected,  then the following
    will be displayed for each of the requested table entries.
    
                       Bias Hysteresis Value
       (P3=aaaa)       bbbb
    
       where:
         aaaa = is the Offset from the start of the Bias Hysteresis Table
         bbbb = is the Bias Hysteresis value at that table location.
    
    
    

  <b><i><u>Examples:</u></i></b>

    Example #1:
    To display a raw hex dump of the SAP:

       F3 2>I,2
       F3 2>I,2,0

    Example #2:
    To display the SAP Table of Contents:

       F3 2>I,2,FF

    Example #3:
    To display all of the supported SAP subgroups in a humanized format:

       F3 2>I,2,1

    Example #4:
    To display any supported SAP subgroup in a humanized format:

       F3 2>I,2,s
       where 's' is a supported SAP subgroup ID

    Example #5:
    To display the MR Bias value for head 0:

       F3 2>I,2,3,0

    Example #6:
    To write the Max MR Bias value for head 1 to 0x003E:

       F3 2>I3E,2,4,1

  <b><i><u>Revision History:</u></i></b>
<a name="DISPLAY_MODIFY_SAP_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0001.0001   Added support for access to Max Head, MR Bias, and Max MR Bias
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).
    0012.0000   Added support for modifying/reading SAP Bias Table and SAP Bias Hysteresis Table

<a name="DISPLAY_MODIFY_ZAP_TABLE_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Display / Modify ZAP Table"></a><hr align=left width="75%"><b> Display / Modify ZAP Table (Level 4 't')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command displays or modifies the RAM ZAP table.

  <b><i><u>Quick Help:</u></i></b>
<a name="DISPLAY_MODIFY_ZAP_TABLE_QUICK_HELP"></a>
    "DisplayModifyZapTable, t[EntryNum],[EntryValue]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="DISPLAY_MODIFY_ZAP_TABLE_PARM"></a>
    0 - ZAP Table Entry Number.
    
        This parameter specifies the number of the ZAP Table entry to be modified.
        If this parameter and / or Parameter 1 are not entered, the ZAP table will
        be displayed.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: None
    
    1 - ZAP Table Entry Data.
    
        This parameter specifies the value to be written to the specified ZAP table entry.
        If this parameter and / or Parameter 0 are not entered, the ZAP table will be
        displayed.
    
          Type:    Signed 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: None
    

  <b><i><u>Output Data:</u></i></b>
<a name="ZAP_TABLE_DATA"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
      If no error occurred, the whole Zap Table will be displayed with the following format:
    
      Row 000 xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx
      Row 001 xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx
      Row 002 xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx
      ......
      where xxxx is the ZAP data at the specified index position of the ZAP table
    

  <b><i><u>Revision History:</u></i></b>
<a name="DISPLAY_MODIFY_ZAP_TABLE_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="DISPLAY_NATIVE_INTERFACE_AND_RW_CMD_HISTORY_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Display Native Interface and Read/Write Command History"></a><hr align=left width="75%"><b> Display Native Interface and Read/Write Command History (Online Control X)</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command displays the command history of the Native Interface and Read/Write
    subsystem.

  <b><i><u>Quick Help:</u></i></b>
<a name="DISPLAY_NATIVE_INTERFACE_AND_RW_CMD_HISTORY_QUICK_HELP"></a>
    "DisplayInterfaceAndRwCmdHistory";

  <b><i><u>Input Parameters:</u></i></b>
    None

  <b><i><u>Output Data:</u></i></b>
<a name="NATIVE_INTERFACE_AND_RW_CMD_HISTORY"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
        If no error occurred, following information will be displayed.
    
           "ATA ccc Cmds"
           "Ts(ms)     dT(ms)   Op Cnt  LBA"
           "dddddddddd eeeeeeee ff gggg hhhhhhhhhhhh"                        <font color=brown>*  see remark below</font>
    
           "RW iii Cmds"
           "Ts(ms)     dT(ms)   xT(ms)  Type Option Mode  St EC       Info"
           "jjjjjjjjjj kkkkkkkk llllllll oo  pppppp qqqqqq r ssssssss"       <font color=brown>** see remark below</font>
    
           where
    
           ccc is the number of ATA commands to display. The oldest one is displaed first
           dddddddddd is the time stamp(ms) of the ATA command when it was recorded
           eeeeeeee is the time difference(ms) from the previous ATA command
           ff is the ATA Op-code. For example, EC is for Identify Device command
           gggg is the block count specified in the ATA task file
           hhhhhhhhhhhh is the LBA number specified in the ATA task file
    
           iii is the number of Read/Write commands to display. The oldest one is displayed first
           jjjjjjjjjj is the time stamp(ms) of the Read/Write command when it was recorded
           kkkkkkkk is the time difference(ms) from the previous Read/Write command.
                    If this is 99999999, it means the time difference is indeterminate
           llllllll is the excution time duration for which the Read/Write request ran.
                    If this is 99999999, it means the excution time is indeterminate
     
           Also some supplementary information may be displayed in the "Info" field.
           That includes request types, options, modes, input/output(information/response) frames
           and buffer configuration, etc.
    
           oo is the Read/Write command request type.
<a name="RW_REQUEST_TYPE"></a>
              0x00     SEEK        Seek request
              0x01     XFR_ALT     Read/Write transfer alternate sector request
              0x02     XFR         Read/Write transfer request
              0x03     RD_CHNL     Access Read Channel request
              0x04     SRV_MEM     Access Servo Memory request
              0x05     SRV_FLW     Add Primary Servo Flaw request
              0x06     DITH        Dithering request
              0x07     DITH_WR     Dithering write enhance request
              0x08     CAL         Drive Calibration request
              0x09     ERA_TRK     Erase Track request
              0x0A     FDB         Execute FDB Motor Leakage Detection test request
              0x0B     FMT_TRK     Format Track request
              0x0C     FMT_SYS     Format System Partition request
              0x0D     FMT_UNT     Format Unit request
              0x0E     HD_RES      Get Head Resistance request
              0x0F     HTR_RES     Get Heater Resistance request
              0x10     GET_RVFF    Get Servo RVFF sensor status
              0x11     ACFF_RECAL  ACFF Recalibrate status
              0x12     TEMP        Get Temperature request
              0x13     TWK_FH      Tweak fly height values request
              0x14     VOLT        Get Voltage Levels request
              0x15     HD_DIAG     Head diagnostics test request
              0x16     HD_SPK      Head Spike Screen request
              0x17     REALLOC     Immediate Reallocation request
              0x18     MRK_PND     Mark Block for Pending Reallocation request
              0x19     HD_FH       Measure Head Fly Heights request
              0x1A     VCM_TEMP    Measure VCM Temperature and Resistance request
              0x1B     MEM_DBG     Memory mapped debug capture request
              0x1C     PROC_DL     Process defect lists request
              0x1D     SCRB_DL     Scrub the defect lists request
              0x1E     PROC_GDL    Process growth defect lists request
              0x1F     REF_SRV_MEM Refresh servo memory request
              0x20     RELD_RAP    Reload RAP parameters request
              0x21     ERR_RATE    Measure error rate
              0x22     DL          Retrieve defect list request
              0x23     SRV_EC      Retrieve the servo error code FIFO request
              0x24     SCN_DFCT    Scan defect adjacent sectors request
              0x25     SELF_SK     Self seek request
              0x26     SK_TUNE     Seek profile tuning request
              0x27     SND_SRV     Send servo request
              0x28     FIX_RAP     Fixup RAP for depop request
              0x29     DEPOP       Send Servo Electrical Depop request
              0x2A     INIT_DITH   Initialize Dithering parameters
              0x2B     PES         Servo PES FIFO access request
              0x2C     PREAMP      Set Preamp mode request
              0x2D     SET_VOLT    Configure voltage margin level request
              0x2E     ZAP         Configure the ZAP correction mode request
              0x2F     SPN_UP      Spinup request
              0x30     SPN_DN      Spindown request
              0x31     ZLR         Track ZLR request
              0x32     UNKNOWN     Unsupported request
              0x33     UNMRK       Unmark Block for Pending Reallocation request
              0x34     TCC         Update TCC Manager request
              0x35     ALT_TONE    Write SMART Alternating Tones Request
              0x36     XFR_TRK     Read/Write transfer track request
              0x37     XFR_WDG     Read/Write transfer wedge request
              0x38     PWR         Set R/W Power Management request
              0x39     CLR_ALT     Clear R/W User Alt List request
              0x3A     LATCH       Put heads on the latch request
              0x3B     SV_ALT      Save R/W User Alt List to Media request
              0x3C     MATLAB      Enter Servo Matlab Shell request
              0x3D     SWEEP       Perform sweep of media to knock off particles request
              0x3E     CLR_SLIP    Clear R/W Slip List request
              0x3F     FA_AFH      Field Adjust AFH request
              0x40     TWK_WR_PWR  Tweak write power request
              0x41     SEC2RLL     Convert sector data to RLL data
              0x42     SWD         SWD(Skip Write Detect) Enable/Disable request
              0x43     CLR_ALT_ENT Clear User Alt List Entry request
              0x44     ADJ_CLR     Adjust Target Clearance request
              0x45     FALL        Control drive free-fall protection request
              0x46     XFR_SEC     Read/Write transfer sector request
              0x47     DISC_SLIP   Update servo disc slip parameters request
              0x48     RE_ALT      Restore R/W User Alt List from Media request
              0x49     RST_RVFF    Reset Servo RVFF sensor status request
              0x4A     HST         Head Stability Test
              
           qqqqqq is the Read/Write command request mode
<a name="RW_REQUEST_MODE"></a>
              Transfer/Seek Request Modes:
              0x00000001           Skip mask mode enabled
              0x00000002           Transfer of EDC/ECC data enabled (R/W Long)
              0x00000004           Disable on-the-fly ECC correction
              0x00000008           Read-continuous mode enabled
              0x00000010           Apply specified seek speed (Seek Request Only)
              0x00000020           Apply track offset with seek
              0x00000040           Disable disc IOEDC Error Detection
              0x00000080           Report override data integrity escape seed to Data Manager
              0x00000100           Disable block address prepending
              0x00000200           Disable block address prepend error detection
              0x00000400           Apply override block address prepend and IOEDC seed
              0x00000800           Media format mode enabled
              0x00001000           Force Read Gate On during transfer
              0x00002000           Disable seeks during transfer (track crossings are not allowed)
              0x00004000           Mask out pre-amp faults
              0x00008000           Prime seek mode enabled (Seek Request Only)
              0x00010000           Enable forced sync on read (Transfer Requests Only)
              0x00020000           Seek without destination cylinder validation (Seek Request Only)
              0x00040000           Track ZLR mode
              0x00080000           Do not reload channel on next seek
              0x00100000           Single track transfer with zero latency start and wrap around logical end
              0x00200000           Single track transfer with wrap around logical end
     
           pppppp is the Read/Write request options.
<a name="RW_REQUEST_OPTION"></a>
              Transfer/Seek Request Options:
              0x00000001 LBA       LBA Format Address Type
              0x00000002 PBA       PBA Format Address Type
              0x00000003 SEC       Sector Format Address Type
              0x00000004 TRK       Track Format Address Type
              0x00000005 WDG       Wedge Format Address Type
              0x00000010 USR       User Partition Area
              0x00000020 SYS       System Partition Area
              0x00000030 SOD       SMART OD Partition Area
              0x00000040 SID       SMART ID Partition Area
              0x000000F0           Invalid Partition Area
              0x00000100 RD        Normal Read Transfer Type
              0x00000200 CMP       Compare Read Transfer Type
              0x00000300 CRT       Cert Read Transfer Type
              0x00000400 WR        Normal Write Transfer Type
              0x00001000           Read Seek Type
              0x00002000           Write Seek Type
              0x00003000           Write Header Seek Type
              0x00004000           Physical Seek Type
              0x00010000           Apply long delay after seek completion
              0x00020000           Log seek related statistics
              0x00040000           Disable the heater on read seek
                                   Valid only if ALTITUDE_FLY_HEIGHT_MODULATION_WORKAROUND compile switch is true.
              0x00040000           Track unique randomizer seeding.
                                   Valid only if TRACK_UNIQUE_RANDOMIZER_SEED compile switch is true.
              0x00080000           LBA numbering of BIPS Parity Sectors
              0x00100000           Indicate track skew should be computed
              0x00200000           Use worst-case delta-L value
              
              Spinup Request Options:
              0x00000000 NORMAL    Normal Spinup
              0x00000001 ONLY      Spin-only Spinup
              
              Spindown Request Options:
              0x00000000 NORMAL    Normal Spindown
              0x00000001 QCK       Quick Spindown
              0x00000002           Quick Low-power Spindown
              0x00000003           Late Entry Spindown
              
              Read Track Request Options:
              0x00000001           Use LBA to access track
              0x00000002           Assert read gate for entire track regardless of errors
              
              Write Track Request Options:
              0x00000001           Use LBA to access track
              0x00000002           Disable IOEDC parity checking
              
              Reallocate Block Request Options:
              0x00000001 L1        Does attempt a data scrub (i.e. write-verify) of the original block location.
                                   Does a hard reallocate if it fails.
              0x00000002 L2        Does attempt a data scrub (i.e. write-verify) of the original block location.
                                   Does NOT do a hard reallocate if fails (unless it becomes an unrecovered error).
              0x00000004 HARD      Does not attempt a data scrub (i.e. write-verify) of the original block location.
              0x00000008 MRK       Adds the input LBA to the pending reallocation list.
              0x00000010 UNMRK     Removes the input LBA from the pending reallocation list.
              0x00000020 RGD       If reallocated, defect is categorized as Reserved Grown defect.
              
              Configure voltage margin level request options:
              0x00000000           No change in the voltage margin
              0x00000001           Configure for low voltage margin
              0x00000002           Configure for nominal voltage margin
              0x00000003           Configure for high voltage margin
              
              Configure the ZAP correction mode request options:
              0x00000000           Disable all ZAP correction
              0x00000001           Enable Write ZAP only
              0x00000002           Enable Read ZAP only
              0x00000003           Enable Read and Write ZAP
              0x00000004           Apply ZAP from Servo RAM
              
              Clear Alt List Request Options:
              0x00000000           Disable save of list to media
              0x10000000           Enable of save of list to media
              
              Clear Slip List Request Options:
              0x00000000           Disable of save of list to media
              0x10000000           Enable of save of list to media
              
              Clear Alt List Entry Request Options:
              0x00000000           Disable of save of list to media
              0x10000000           Enable of save of list to media
              
              Update Servo Disc Slip Parms Request Options:
              0x80000000           Request servo re-cal pending status only.
              0x40000000           Force servo re-cal and update of disc slip parameters.
              0x20000000           Send updated (if calibration was performed) disc slip parameters to servo.
              0x10000000           Send saved disc slip parameters (from media file) to servo.
     
           r is the R/W Sense Status.
<a name="RW_SENSE_STATUS"></a>
              0x0 RW_REQUEST_SATISFIED_WITH_RECOVERY - Request was satisfied with error recovery performed
              0x1 RW_REQUEST_SATISFIED - Request was satisfied (no error recovery performed)
              0x2 RW_REQUEST_FAILED -Request was not satisfied
     
           ssssssss is the R/W Sense Error Code.
    
           Read/Write request information and response frames
              B Aaaaaaaa        where Aaaaaaaa is the LBA or PBA number
              L Bbbbbbbb        where Bbbbbbbb is the Transfer Length
              CH Cccccc.D       where Cccccc is the cylinder and D is the head number
              CHS Cccccc.D.Eeee where Cccccc is the cylinder, D is the head and Eeee is the sector number
    
           Read/Write request buffer configuration
              BO Ffffff   where Ffffff is the buffer config option
              VL Gggg.Hhhh  where Gggg is the start VBM index and Hhhh is the length in sectors
                 of the VBM buffer segment
              BES Iiiiiiii.Jjjjjjjj.Kkkkkkkk where Iiiiiiii is the base address and Jjjjjjjj
                 the top address and Kkkkkkkk the start address of the non-VBM buffer segment
    
           <font color=brown>Remarks
           *  - This line is repeated for the number of ATA commands, specified by the ccc described above
           ** - This line is repeated for the number of Read/Write commands, specified by the iii described above.
           </font>

  <b><i><u>Revision History:</u></i></b>
<a name="DISPLAY_NATIVE_INTERFACE_AND_RW_CMD_HISTORY_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="DISPLAY_NATIVE_INTERFACE_CMD_STATE_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Display Native Interface Command State"></a><hr align=left width="75%"><b> Display Native Interface Command State (Online '~')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command displays state of the Native Interface command.

  <b><i><u>Quick Help:</u></i></b>
<a name="DISPLAY_NATIVE_INTERFACE_CMD_STATE_QUICK_HELP"></a>
    "DisplayInterfaceCmdState";

  <b><i><u>Input Parameters:</u></i></b>
    None

  <b><i><u>Output Data:</u></i></b>
<a name="NATIVE_INTERFACE_CMD_STATE"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
        If no error occurred, following information will be displayed.
    
           "ATA St cc Er dd Op ee f gggggggggggg, hhhh iiii jjjj"
           "Ts(ms)     dT(ms)   xT(ms)  Type Option Mode  St EC       Info"
           "kkkkkkkkkk llllllll oooooooo pp  qqqqqq rrrrrr s tttttttt"
    
           where
    
              cc is the AT Status register
              dd is the AT Error register
              ee is the AT Command register
              f is the upper 4-bits of the AT device/head register
              gggggggggggg is the AT LBA registers which is concatenation of multiple registers
              hhhh is the AT Starting Sector Count register
              iiii is the AT (current) Sector Count register
              jjjj is the AT Feature register
    
              kkkkkkkkkk is the time stamp(ms) of the Read/Write command when it was recorded
              llllllll is the time difference(ms) from the previous Read/Write command.
                       If this is 99999999, it means the time difference is indeterminate
              oooooooo is the excution time duration for which the Read/Write request ran.
                       If this is 99999999, it means the excution time is indeterminate
              pp is the Read/Write command request type
              qqqqqq is the Read/Write command request options
              rrrrrr is the Read/Write command request mode
              s is the R/W Sense Status.
              tttttttt is the R/W Sense Error Code.
    
              For more detail description of RW command state please refer Online Control-X,
              Native Interface and Read/Write Command History Information, command
    

  <b><i><u>Revision History:</u></i></b>
<a name="DISPLAY_NATIVE_INTERFACE_CMD_STATE_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="DISPLAY_NATIVE_INTERFACE_CONFIG_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Display Native Interface Configuration"></a><hr align=left width="75%"><b> Display Native Interface Configuration (Online Control E)</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command displays the Native Interface configuration information.

  <b><i><u>Quick Help:</u></i></b>
<a name="DISPLAY_NATIVE_INTERFACE_CONFIG_QUICK_HELP"></a>
    "DisplayInterfaceConfig";

  <b><i><u>Input Parameters:</u></i></b>
    None

  <b><i><u>Output Data:</u></i></b>
<a name="NATIVE_INTERFACE_CONFIG_OUTPUT"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
<a name="AT_INTERFACE_CONFIG_OUTPUT_DATA"></a>
    If no error occurred and the native interface is AT or SATA, the following information
    will be displayed.
    
          "CurrentCHS=cccc/dd/ee  MltSiz=fgg  DMAMod=hi"
    
       where
    
          cccc  is the number of Current Logical Cylinders
    
          dd    is the number of Current Logical Heads
    
          ee    is the number of Current Logical Sectors
    
          f     is the AT Interface Multiple Block validity, 0 = Disabled 1 = Enabled
    
          gg    is the AT Interface Multiple Block Size
                This is valid only if AT Interface Multiple Block validity, f above, is 1
    
          h     is the current AT Interface DMA Mode. 2 = Multiword DMA 4 = Ultra DMA
    
          i     is the current AT Interface DMA Mode Level
                This is valid only if current AT Interface DMA Mode, h above, is valid
    
        Else
    
           "Unsupported Native Interface Type"
    

  <b><i><u>Revision History:</u></i></b>
<a name="DISPLAY_NATIVE_INTERFACE_CONFIG_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="DISPLAY_NATIVE_INTERFACE_RD_CACHE_INFO_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Display Native Interface Read Cache Information"></a><hr align=left width="75%"><b> Display Native Interface Read Cache Information (Online Control F)</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command displays the Native Interface's read cache information.

  <b><i><u>Quick Help:</u></i></b>
<a name="DISPLAY_NATIVE_INTERFACE_RD_CACHE_INFO_QUICK_HELP"></a>
    "DisplayInterfaceRdCacheInfo";

  <b><i><u>Input Parameters:</u></i></b>
    None

  <b><i><u>Output Data:</u></i></b>
<a name="NATIVE_INTERFACE_RD_CACHE_INFO"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
        If no error occurred, the read cache information will be displayed as follows.
    
           "VBM Cache SRAM                   VBM Remap Table"
           "Ix LBA          Scnt Dlta Stat | LBA          Scnt Atch Strt End  Next Prev AC FL"
           "cc dddddddddddd eeee ffff gggg   dddddddddddd eeee hhhh iiii jjjj kkkk llll mm nn"    <font color=brown>* see remark below</font>
    
           "Cache Search Hardware Info"
           "Target LBA oooooooooooo Count pppp"
           "Config qqqq Status rrrr"
           "Start Entry ss End Entry tt"
           "Total Hits uuu Best Hit vvv"
           "Active Entry ww Delta xxxxxxxxxx"
           "First Hit Entry yy Last Hit Entry zz"
    
           "Cache Segments MV-LV Linked List Info"
           "MV Index Aa LV Index Bb Number of Valuable Segments Cc"
           "Dd->Dd->Dd->Dd->Dd->Dd->Dd->Dd->Dd->Dd->Dd->Dd->Dd->Dd->Dd->Dd->"                     <font color=brown>** see remark below</font>
    
           "Free Cache Segments Linked List Info"
           "Free Head Ee Free Tail Ff Number of Free Segments Gg"
           "Hh->Hh->Hh->Hh->Hh->Hh->Hh->Hh->Hh->Hh->Hh->Hh->Hh->Hh->Hh->Hh->"                     <font color=brown>*** see remark below</font>
    
           "Sector Size: User(VBM) Iiii(Jjjj) System Kkkk"
           "HBACI Llll HMACI Mmmm FBUFI Nnnn FBACI Oooo"
    
           where
    
           cc is the cache segment entry number, also referred as cache segment index
           dddddddddddd is the starting Logical Block Address in the cache segment
           eeee is the valid number of sectors in the cache segment
           ffff is the difference between target LBA and Start LBA of the cache table entry
           gggg is the cache search result status indicating hit type (Full, Partial, etc)
           hhhh is the number of sectors attached to this cache segment
           iiii is the first sector's VBM Map Index into buffer memory
           jjjj is the last sector's VBM Map Index into buffer memory
           kkkk is the linked list pointer to the next cache segment entry
           llll is the linked list pointer to the previous cache segment entry
           mm is the number of commands which have reserved this cache segment
           nn is the flag that indicates the cache segment's status (Write pending, etc)
    
           oooooooooooo is the target LBA that will be compared to the cache table entries
              for the purpose of determining cache hits
           pppp is the target sector count that will be compared to the cache table entries
           qqqq is the configuration of the cache search engine
           rrrr is the status that indicates cache search result
           ss is the first cache entry number to be searched for cache hits
           tt is the last cache entry number to be searched for cache hits
           uuu is the total number of cache entries that had a hit during the cache search
           vvv is the entry number of the best cache hit for the cache search
           ww is the entry number used to determine which of several candidate hits is labeled
              as the best hit
           xxxxxxxxxx is the value, Target LBA ?Start LBA, for the cache table entry
              currently being searched
           yy is the first cache entry of cache hit of any kind detected during the search
           zz is the last cache entry of cache hit of any kind detected during the search
    
           Aa is the Most Valuable cache segment's entry number
           Bb is the Least Valuable cache segment's entry number
           Cc is the number of Valuable cache segment entries
           Dd is the entry numbers of Valuable cache segments showing from the Most to the Least
           Ee is the entry number of the Free Head cache segment
           Ff is the entry number of the Free Tail cache segment
           Gg is the number of Free cache segment entries
           Hh is the entry numbers of Free cache segments showing from Head to Tail
    
           Iiii is the User area sector size in bytes including IODEC field
           Jjjj is the User area sector size in bytes including IODEC field, for VBM conversion
           Kkkk is the System area sector size in bytes
           Llll is the Host FIFO Buffer Address Counter (VBM Index)
           Mmmm is the Host FIFO Memory Address Counter (VBM Index)
           Nnnn is the Formatter FIFO VBM index for buffer
           Oooo is the Formatter FIFO VBM index for formatter
    
           <font color=brown>Remarks
           *   - This line is repeated for the number of cache segment entries implemented
           **  - This line is repeated until all Valuable cache entries, indicated by
                        Cc above, are displayed. 16 entries are displayed per line
           *** - This line is repeated until all Free cache entries, indicated by Gg
                        above, are displayed. 16 entries are displayed per line
           </font>

  <b><i><u>Revision History:</u></i></b>
<a name="DISPLAY_NATIVE_INTERFACE_RD_CACHE_INFO_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="DISPLAY_PREAMP_HEAD_RESISTANCE_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Display Preamp Head Resistance"></a><hr align=left width="75%"><b> Display Preamp Head Resistance (Level 7 'X')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command measures and displays the resistance of all heads.

  <b><i><u>Quick Help:</u></i></b>
<a name="DISPLAY_PREAMP_HEAD_RESISTANCE_QUICK_HELP"></a>
    "DisplayPreampHdResistance, X";

  <b><i><u>Input Parameters:</u></i></b>
    None

  <b><i><u>Output Data:</u></i></b>
<a name="PREAMP_HEAD_RESISTANCE"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
        If no error occurred, the following information will be displayed for each head.
    
           "Head cc Resistance dddd"
    
           where
    
              cc is the logical head address
    
              dddd is the head's resistance value

  <b><i><u>Revision History:</u></i></b>
<a name="DISPLAY_PREAMP_HEAD_RESISTANCE_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="DISPLAY_RW_STATISTICS_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Display Read/Write Statistics"></a><hr align=left width="75%"><b> Display Read/Write Statistics (Online '`')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command displays read and write error counters for each head.

    Use online '$' to get error rates by zone.

    Error 100C DETSEC 00008000
    - this error is caused by the error stats log being not initialized.
    Hit ctl-W to initialize the error log.
  
  <b><i><u>Related Commands:</u></i></b>
    any level Ctl-W - enables RW statistics gathering and zeros out the error counters
    level L i   - L>iFFFD will zero out the error counters.
    level L E   - L>E,,0 will disable statistics gathering
                - L>E,,1 will enable statistics gathering
                - L>E,,2 will zero out the error counters

  <b><i><u>Quick Help:</u></i></b>
<a name="DISPLAY_RW_STATISTICS_QUICK_HELP"></a>
    "DisplayRwStats";

  <b><i><u>Input Parameters:</u></i></b>
    None

  <b><i><u>Output Data:</u></i></b>
<a name="RWSTATS_LOG_DATA"></a>
    
           Rbit  Hard  Soft  OTF   Raw   Rsym  Sym   Wbit  Whrd  Wrty
           X.X   X.X   X.X   X.X   X.X   X.X   X.X   X.X   X.X   X.X
           X.X   X.X   X.X   X.X   X.X   X.X   X.X   X.X   X.X   X.X
    
           Where X.X is the log base 10 value as follows:
    
           Rbit: The number of BITS drive attempted to read.  This counter increments by 512*8
                 for each sector attempted to be read.
    <font color=red>
                 This value is forced to be at least equal to the raw error rate.
    </font>
    
           Hard: Records errors that could not be read.  This counter increments by one per
                 set of retires.
    
           Soft: Records errors that required one or more retries, including errors that could not
                 be read.  This counter increments by one per set of retries.
    
           OTF:  Records any error that caused the disk sequencer to stop.  This counter
                 increments by one for each separate retry.
    
           Raw:  Records count of all sectors in error that the disk encountered, including
                 those sectors the disk was able to correct.  A given sector will only increment
                 this counter by 1 no matter how many symbols are in error.  ( This accounting
                 is just like ST-10 code. )
    
           Rsym: The number of symbols the drive attempted to read.  This includes user data,
                 IOECD, and ECC fields.  Each time a sector read is retried, the number of
                 symbols read is incremented by the number of symbols in a sector.
    
           Sym:  Symbol based error rate.  This is
                 -1 * log10 ( bad symbols reported by hardware / symbols read )
    
           Wbit: The number of BITS drive attempted to write.  This counter increments by
                 512*8 once for each sector attempted to be written.
    <font color=red>
                 This value is forced to be at least equal to the Wrty value.
    </font>
    
           Whrd: Write hard errors.  This counter increments by one each time the drive fails
                 to write a sector.  This counter only increments once per set of retries.
    
           Wrty: Records errors that required one or more retries but did not require
                 full error recovery configuration to write. This counter increments
                 by one per set of retries.
    
      Example:
           10 sectors read  ( 10*512*8 bits )
           18 OTF corrections
           4 soft errors
           2 hard errors
         --- --- --- --- --- --- --- --- ---
         rbit = log10 (10*512*8)
         hard = log10 (    2     / (10*512*8) )
         soft = log10 (  (2+4)   / (10*512*8) )
         OTF  = log10 ( (2+4+18) / (10*512*8) )
      

  <b><i><u>Examples:</u></i></b>

    Example #1:

        F3 2> `
               Rbit  Hard  Soft  OTF   Raw   Rsym  Sym   Wbit  Whrd  Wrty
        Hd 0   9.4   9.4   9.4   9.4   5.9   8.5   4.9   0.0   0.0   0.0
        Hd 1   9.3   9.3   9.3   9.3   5.9   8.4   4.9   0.0   0.0   0.0
        
  <b><i><u>Revision History:</u></i></b>
<a name="DISPLAY_RW_STATISTICS_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0001.0001   Changed how stats are calculated if no successful transfers have occurred.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).
    0011.0001   Improve accuracy of logarithm math.
    0012.0000   Added support for symbol based error rates.

<a name="DISPLAY_RW_STATISTICS_BY_ZONE_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Display Read/Write Statistics By Zone"></a><hr align=left width="75%"><b> Display Read/Write Statistics By Zone (Online '$')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command displays read and write error counters for each head and zone.

    Error 100C DETSEC 00008000
    - this error is caused by the error stats log being not initialized.
    Hit ctl-W to initialize the error log.
  
  <b><i><u>Related Commands:</u></i></b>
    any level Ctl-W - enables RW statistics gathering and zeros out the error counters
    level L i   - L>iFFFD will zero out the error counters.
    level L E   - L>E,,0 will disable statistics gathering
                - L>E,,1 will enable statistics gathering
                - L>E,,2 will zero out the error counters

  <b><i><u>Quick Help:</u></i></b>
<a name="DISPLAY_RW_STATISTICS_BY_ZONE_QUICK_HELP"></a>
    "DisplayRwStatsByZone";

  <b><i><u>Input Parameters:</u></i></b>
    None

  <b><i><u>Output Data:</u></i></b>
<a name="RWSTATS_LOG_DATA"></a>
    
           Rbit  Hard  Soft  OTF   Raw   Rsym  Sym   Wbit  Whrd  Wrty
           X.X   X.X   X.X   X.X   X.X   X.X   X.X   X.X   X.X   X.X
           X.X   X.X   X.X   X.X   X.X   X.X   X.X   X.X   X.X   X.X
    
           Where X.X is the log base 10 value as follows:
    
           Rbit: The number of BITS drive attempted to read.  This counter increments by 512*8
                 for each sector attempted to be read.
    <font color=red>
                 This value is forced to be at least equal to the raw error rate.
    </font>
    
           Hard: Records errors that could not be read.  This counter increments by one per
                 set of retires.
    
           Soft: Records errors that required one or more retries, including errors that could not
                 be read.  This counter increments by one per set of retries.
    
           OTF:  Records any error that caused the disk sequencer to stop.  This counter
                 increments by one for each separate retry.
    
           Raw:  Records count of all sectors in error that the disk encountered, including
                 those sectors the disk was able to correct.  A given sector will only increment
                 this counter by 1 no matter how many symbols are in error.  ( This accounting
                 is just like ST-10 code. )
    
           Rsym: The number of symbols the drive attempted to read.  This includes user data,
                 IOECD, and ECC fields.  Each time a sector read is retried, the number of
                 symbols read is incremented by the number of symbols in a sector.
    
           Sym:  Symbol based error rate.  This is
                 -1 * log10 ( bad symbols reported by hardware / symbols read )
    
           Wbit: The number of BITS drive attempted to write.  This counter increments by
                 512*8 once for each sector attempted to be written.
    <font color=red>
                 This value is forced to be at least equal to the Wrty value.
    </font>
    
           Whrd: Write hard errors.  This counter increments by one each time the drive fails
                 to write a sector.  This counter only increments once per set of retries.
    
           Wrty: Records errors that required one or more retries but did not require
                 full error recovery configuration to write. This counter increments
                 by one per set of retries.
    
      Example:
           10 sectors read  ( 10*512*8 bits )
           18 OTF corrections
           4 soft errors
           2 hard errors
         --- --- --- --- --- --- --- --- ---
         rbit = log10 (10*512*8)
         hard = log10 (    2     / (10*512*8) )
         soft = log10 (  (2+4)   / (10*512*8) )
         OTF  = log10 ( (2+4+18) / (10*512*8) )
      

  <b><i><u>Examples:</u></i></b>

    Example #1:

        F3 2> $
        Hd Zn  Rbit  Hard  Soft  OTF   Raw   Rsym  Sym   Wbit  Whrd  Wrty
         0  0  8.1   8.1   8.1   7.4   5.7   7.2   4.6   0.0   0.0   0.0
         0  1  7.8   7.8   7.8   7.0   5.9   6.9   4.6   0.0   0.0   0.0
         0  2  7.9   7.9   7.9   7.3   5.7   6.9   4.3   0.0   0.0   0.0
         0  3  8.0   8.0   8.0   7.1   6.1   7.0   4.6   0.0   0.0   0.0
         0  4  7.9   7.9   7.9   7.1   5.7   7.0   4.5   0.0   0.0   0.0
         0  5  8.0   8.0   8.0   7.1   5.5   7.1   4.4   0.0   0.0   0.0
         0  6  8.1   8.1   8.1   7.2   5.7   7.1   4.4   0.0   0.0   0.0
         0  7  7.9   7.9   7.9   7.2   5.7   7.0   4.5   0.0   0.0   0.0
         0  8  7.5   7.5   7.5   7.5   5.3   6.6   4.0   0.0   0.0   0.0
         0  9  7.9   7.9   7.9   7.0   5.6   6.9   4.3   0.0   0.0   0.0
         0  A  7.8   7.8   7.8   6.9   5.5   6.9   4.3   0.0   0.0   0.0
         0  B  7.9   7.9   7.9   7.0   5.0   6.9   3.8   0.0   0.0   0.0
         0  C  7.5   7.5   7.5   7.0   5.3   6.6   4.2   0.0   0.0   0.0
         0  D  7.9   7.9   7.9   6.9   5.5   6.9   4.2   0.0   0.0   0.0
         0  E  7.5   7.5   7.5   7.0   5.6   6.6   4.4   0.0   0.0   0.0
         0  F  7.5   7.5   7.5   6.9   5.4   6.5   4.1   0.0   0.0   0.0
        Sumry: 9.1   9.1   9.1   7.1   5.5   8.1   4.2   0.0   0.0   0.0
        
        Hd Zn  Rbit  Hard  Soft  OTF   Raw   Rsym  Sym   Wbit  Whrd  Wrty
         1  0  7.9   7.9   7.9   7.2   6.0   6.9   4.6   0.0   0.0   0.0
         1  1  7.8   7.8   7.8   7.0   5.8   6.9   4.5   0.0   0.0   0.0
         1  2  7.9   7.9   7.9   7.2   5.8   6.9   4.5   0.0   0.0   0.0
         1  3  7.9   7.9   7.9   7.3   5.8   7.0   4.6   0.0   0.0   0.0
         1  4  8.1   8.1   8.1   7.2   6.0   7.2   4.6   0.0   0.0   0.0
         1  5  8.1   8.1   8.1   7.2   5.8   7.2   4.5   0.0   0.0   0.0
         1  6  8.1   8.1   8.1   7.1   6.0   7.1   4.5   0.0   0.0   0.0
         1  7  8.0   8.0   8.0   7.1   5.7   7.1   4.4   0.0   0.0   0.0
         1  8  8.0   8.0   8.0   7.1   5.9   7.0   4.6   0.0   0.0   0.0
         1  9  8.0   8.0   8.0   7.1   5.8   7.0   4.4   0.0   0.0   0.0
         1  A  7.6   7.6   7.6   7.3   5.7   6.6   4.4   0.0   0.0   0.0
         1  B  7.5   7.5   7.5   7.5   5.8   6.6   4.7   0.0   0.0   0.0
         1  C  7.8   7.8   7.8   6.9   5.7   6.9   4.5   0.0   0.0   0.0
         1  D  7.5   7.5   7.5   7.2   5.6   6.6   4.4   0.0   0.0   0.0
         1  E  8.0   8.0   8.0   7.1   5.6   7.0   4.3   0.0   0.0   0.0
         1  F  7.7   7.7   7.7   7.0   5.8   6.7   4.3   0.0   0.0   0.0
        Sumry: 9.1   9.1   9.1   7.2   5.8   8.1   4.5   0.0   0.0   0.0

  <b><i><u>Revision History:</u></i></b>
<a name="DISPLAY_RW_STATISTICS_BY_ZONE_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).
    0011.0001   Improve accuracy of logarithm math.
    0012.0000   Added support for symbol based error rates.

<a name="DISPLAY_SIGN_ON_MSG_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Display Sign On Message"></a><hr align=left width="75%"><b> Display Sign On Message (Online Control L)</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command displays the sign on message, which includes Product configuration,
    HDA configuration, PCBA configuration, Firmware revision and Feature configuration
    information.

  <b><i><u>Quick Help:</u></i></b>
<a name="DISPLAY_SIGN_ON_MSG_QUICK_HELP"></a>
    "DisplaySignOnMsg";

  <b><i><u>Input Parameters:</u></i></b>
    None

  <b><i><u>Output Data:</u></i></b>
<a name="BASIC_DRIVE_INFO"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
        If no error occurred , the following information will be displayed.
    
           "Product FamilyId: cc, MemberId: dd"
    
           where
    
              cc is the Product Family ID
    
              dd is the Product Family Member ID
    
           "HDA SN: eeeeeeee, RPM: ffff, Wedges: gggg, Heads: h, Lbas: jjjjjjjj, PreampType: kk kk"
    
           where
    
              eeeeeeee is the HDA Serial Number
    
              ffff is the spin speed in Rotations per Minute
    
              gggg is the number of servo wedges per track in hex
    
              h is the number of heads
    
              jjjjjjjj is the number of user LBAs in hex
    
              kk kk is the Preamp Type (Preamp Registers 0 and 1)
    
           "PCBA SN: llllllll, Controller: mmmmm, Channel: pppp, PowerAsic: qqqq Rev rr, BufferBytes: ssssssss"
    
           where
    
              llllllll is the PCBA Serial Number
    
              mmmm is an ASCII string that specifies the controller type
    
              nnnn is the controlle clock speed in MHz
    
              pppp is an ASCII string that specifies the Read Channel type
    
              qqqq is an ASCII string that specifies the Power ASIC type
    
              rr is the Power ASIC revision
    
              ssssssss is the data buffer size in bytes
    
<a name="FIRMWARE_PACKAGE_INFO_OUTPUT_DATA"></a>
    
    "Package Version: CCCCCC.CCCC.CCCCCC.CCCCCCCC, Package P/N: DDDDDDDDD, Package Builder ID: EE,...
     Package Build Date: MM-DD-YYYY, Package Build Time: HH:MM:SS, Package CFW Version: GGGG.GGGG.GGGGGG.GGGG,...
        Package SFW1 Version: IIII, Package SFW2 Version: JJJJ, Package SFW3 Version: KKKK, Package SFW4 Version: LLLL"
    
    where
    
       CCCCCC.CCCC.CCCCCC.CCCCCCCC is the Package Version Field.
    
       DDDDDDDDD is the Package Part Number Field.
    
       EE is the Package Builder ID Field.
    
       MM/DD/YYYY is the Package Build Date Field.
    
       HH:MM:SS is the Package Build Time Field.
    
       GGGG.GGGG.GGGGGG.GGGG is the Package CFW Component Version Field.
    
       IIII Package SFW Component 1 Version Field.
    
       JJJJ Package SFW Component 2 Version Field.
    
       KKKK Package SFW Component 3 Version Field.
    
       LLLL Package SFW Component 4 Version Field.
    
    example output:
        Package Version: MS1240.STD1.AA0502.STD10013, Package P/N: 100421943, Package Builder ID: C4,
        Package Build Date: 03/08/2007, Package Build Time: 151452, Package CFW Version: MS12.STD1.123456.B600,
        Package SFW 1 Version: B413, Package SFW 2 Version: C415, Package SFW 3 Version: ----, Package SFW 4 Version: ----
    
    A warning message may be printed which indicates that some of the Firmware Package information
    has been truncated. The most likely causes of this warning would be that Package information is
    invalid or that this diagnostic does not support the Firmware Package format returned by the drive.
    
    example output:
       Warning: Package Info truncation occurred.
       
    
<a name="CONTROLLER_FIRMWARE_REV_INFO"></a>
    
    "Controller FwRev CCCCCCCC, CustomerRel DDDDDD, Changelist EEEE, ProdType FFFF, Date GG/GG/GGGG, Time HHHHHH, UserId IIIIIIII";
    
    where
    
       CCCCCCCC is the Controller Firmware Revision.
    
       DDDD is the Customer Release number.
    
       EEEEEEEE is the Perforce Changelist Number.
    
       FFFF is the Product Type.
    
       GG/GG/GGGG is the date the code was built.
    
       HHHHHH is the time the code was built.
    
       IIIIIIII is the global ID of the person that built the code.
    
<a name="SERVO_FIRMWARE_REV"></a>
    
    "Servo FwRev CCCC
    
    where
    
       CCCC is the Servo Firmware Revision.
    
<a name="RAP_REV_INFO_OUTPUT_DATA"></a>
    
    "RAP FW Implementation Key: CC, RAP FormatRev DD, ContentsRev EE";
    
    where
    
       CC is the RAP FW Implemenation Key.
    
       DD is the RAP Format Revision.
    
       EE is the RAP Contents Revision.
    
    
           "Features:"
           "- AFH tttttttt"
           "- VBAR tttttttt" or "- VBAR with adjustable zone boundaries tttttttt"
           "- Volume Based Sparing tttttttt"
           "- IOEDC tttttttt"
           "- IOECC tttttttt"
           "- DERP Read Retries tttttttt"
           "- LTTC-UDR2 uuuuuuuu"
    
           where
    
              tttttttt = "enabled" or "disabled"
              uuuuuuuu = "enabled" or "disabled" or "compiled off"
    

  <b><i><u>Revision History:</u></i></b>
<a name="DISPLAY_SIGN_ON_MSG_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0002.0000   Added IOEDC and IOECC enabled status.
    0003.0000   Added Firmware Package Information to the output data.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).
    0012.0000   Added LTTC-UDR2 disabled, enabled, or compiled off indication
    0013.0000   Added RAP FW Implementation Key.

<a name="DISPLAY_SUPER_PARITY_RAM_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Display Super Parity RAM"></a><hr align=left width="75%"><b> Display Super Parity RAM (Level G 'E')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command displays the specified segment of the Super Parity RAM.

  <b><i><u>Quick Help:</u></i></b>
<a name="DISPLAY_SUPER_PARITY_RAM_QUICK_HELP"></a>
    "DisplaySuperParityRam, G[StartAddr],[EndAddr]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="DISPLAY_SUPER_PARITY_RAM_PARM"></a>
    0 - Start Address Offset of Super Parity RAM.
    
        This parameter specifies the start address offset of the super parity RAM.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xffff,
    
          Default: 0
    
    1 - End Address Offset of Super Parity RAM.
    
        This parameter specifies the end address offset of the super parity RAM.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xffff
    
          Default: 0
    

  <b><i><u>Output Data:</u></i></b>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    

  <b><i><u>Revision History:</u></i></b>
<a name="DISPLAY_SUPER_PARITY_RAM_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="DISPLAY_TEMPERATURE_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Display Temperature"></a><hr align=left width="75%"><b> Display Temperature (Levels 7 'D')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This commmand displays the temperature of the specified device (preamp or thermistor).

  <b><i><u>Quick Help:</u></i></b>
<a name="DISPLAY_TEMPERATURE_QUICK_HELP"></a>
    "DisplayTemperature, D,[DevSelect]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="DISPLAY_TEMPERATURE_PARM"></a>
    0 - not used.
    
        This parameter is not currently used.  For the legacy ST10 code, entering
        this parameter forced the cert temperature to be equal the current temperature.
    
          Type:    None
    
          Range:   None
    
          Default: None
    
    1 - Device Select.
    
        This parameter selects the device for which the temperature is to be displayed.
    
        If this parameter is equal to 2, the Preamp temperature will be displayed, else the
        Thermistor temperature will be displayed.
    
          Type:    Unsigned 8-bit value
    
          Range:   0 to 0xFF
    
          Default: 0 (Display Thermistor temperature)
    
    2 - not used.
    
        This parameter is not currently used.  For the legacy ST10 code, if this
        parameter was equal to 0x22, the temperature value was written to the disk with
        the Adaptive parameters.
    
          Type:    None
    
          Range:   None
    
          Default: None
    

  <b><i><u>Output Data:</u></i></b>
<a name="DEVICE_TEMPERATURE_OUTPUT_DATA"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
        If no error occurred and the Preamp temperature was returned, the following message
        will be displayed.
    
              "Preamp temp cccc, CCd"
    
           where
    
              cccc is the temperature value obtained from preamp (hexadecimal)
                CC is the temperature value obtained from preamp (decimal)
     
        If no error occurred and the Thermistor temperature was returned, the following
        message will be displayed.
    
              "Ref voltage dddd Thermistor voltage eeee Thermistor temp in degrees C ffff, FFd"
    
           where
    
              dddd is the A to D Reference Voltage
    
              eeee is the Thermistor Voltage
    
              ffff is the Thermistor Temperature in degrees Celsius (hexadecimal)
                FF is the Thermistor Temperature in degrees Celsius (decimal)
    

  <b><i><u>Revision History:</u></i></b>
<a name="DISPLAY_TEMPERATURE_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).
    0012.0000   Added Temperature in degrees Celsius (decimal) to output.

<a name="DISPLAY_TRACK_INFO_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Display Track Information"></a><hr align=left width="75%"><b> Display Track Information (Level 2 'X' or Level A 'l')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command displays information about the specified track.  If no track address is
    specified, this command will display information about the current Target Track.

  <b><i><u>Quick Help:</u></i></b>
<a name="DISPLAY_TRACK_INFO_QUICK_HELP"></a>
       Level 2
    "DisplayTrkSectorInfo, X[LogCyl],[Hd],[SysAreaOpt],[Opts],[RowsPerPage]";
       Level l
    "DisplayTrkInfo, l[LogCyl],[Hd],[SysAreaOpt],[Opts],[RowsPerPage]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="DISPLAY_TRACK_INFO_OR_SECTOR_INFO_PARM"></a>
    0 - Logical Cylinder Address.
    
        If Parameter 2 is not entered, this parameter is the User Area logical cylinder
        address of the track for which information is to be displayed.  If Parameter 2
        is entered, this parameter is the System Area logical cylinder address of the
        track for which information is to be displayed.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: Next logical cylinder address in the Test Space
    
    1 - Logical Head Address.
    
        This parameter is the logical head address of the track for which information
        is to be displayed.
    
          Type:    Unsigned 8-bit value
    
          Range:   0 to 0xFF
    
          Default: Next logical head address in the Test Space
    
    2 - System Area Flag.
    
        If any value is entered for this parameter, then Parameter 0 specifies a System
        Area logical cylinder address, else it specifies a User Area logical cylinder
        address.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: None
    
    3 - Display Sector Information option.
    
        If this parameter is equal to 0, the specified tracks sector information will not
        be displayed, else the specified tracks sector information will be displayed.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: For Level 2 'X' the default is 1 (Display track's Sector Information)
                   For Level A 'l' the default is 0 (Don't display track's Sector Information)
    
    4 - Sector Information Rows Per Page.
    
        If Parameter 3 is entered and this parameter is entered, the sector information
        display will pause after the number of rows specified by this parameter and wait for
        the user to enter a character.  If this parameter is not entered, all of the sector
        information will be displayed without pausing.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: None (Don't pause the sector information display)
    

  <b><i><u>Output Data:</u></i></b>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
    If no error occurred, the following information will be displayed:
<a name="TRACK_INFO"></a>
    
       "Track Info:"
       "Partition PhyCyl   LogCyl   NomCyl   Radius_mils LogHd Zn FirstLba FirstPba LogSecs PhySecs WdgSkw SecPerFrm WdgPerFrm"
       "User      cccccccc dddddddd nnnnnnnn o.ooooooEoo ee    ff gggggggg hhhhhhhh iiii    jjjj    kkkk   llll      mmmm"        or
       "System    cccccccc dddddddd nnnnnnnn o.ooooooEoo ee    ff gggggggg hhhhhhhh iiii    jjjj    kkkk   llll      mmmm"
    
    where
    
       cccccccc          is the Logical Cylinder address where Logical Cylinders do not
                         include the cylinders in other partitions.
    
       dddddddd          is the Physical Cylinder address where Physical Cylinders
                         include User Area Cylinders, System Area Cylinders and Spare
                         Cylinders.
    
       ee                is the Logical Head address where Logical Heads do not
                         include heads that have been depopulated.
    
       ff                is the number of the zone that contains the track.
    
       gggggggg          is the first Logical Block Address (LBA) on the track.
    
       hhhhhhhh          is the first Physical Block Address (PBA) on the track.
    
       iiii              is the number of logical sectors on the track.
    
       jjjj              is the number of physical sectors on the track.
    
       kkkk              is the skew in wedges from index to the wedge that contains
                         physical sector 0.
    
       llll              is the number of physical sectors per frame.
    
       mmmm              is the number of wedges per frame.
    
       nnnnnnnn          is the Nominal Cylinder address where Nominal Cylinders
                         remove the VBAR scaling factor.
    
       o.ooooooEoo       is the Radius in milliinches as measured from the hub.
    
    If the Sector Information display is enabled, the following additional information
    will be displayed:
<a name="TRACK_SECTOR_INFO"></a>
    
    "Sector Info:"
    
    "PhySec(LogSec) Wdg SFI        PhySec(LogSec) Wdg SFI        PhySec(LogSec) Wdg SFI        PhySec(LogSec) Wdg SFI        Split"
      cccc   dddd   eee ffffffff    gggg   hhhh   iii jjjjjjjj    kkkk   llll   mmm nnnnnnnn    pppp   qqqq   rrr tttttttt   qqq:rrr
      <The previous line is repeated until all sectors on the track are displayed>
    
    As shown above, the sector information is displayed in four columns.  For each column,
    the Physical Sector Address (PhySec) increments sequentially for each row.  All of the
    sectors in a given row are at the same sector offset from the start of the frame and
    frames are seperated by a blank line.  The displayed information is defined as follows:
    
       cccc, gggg, kkkk and pppp are the Physical Sector Address.
    
       dddd, hhhh, llll and qqqq are the Logical Sector Address.
    
       eee, iii, mmm and rrr are the number of the Servo Burst that preceeds the sector.
    
       ffffffff, jjjjjjjj, nnnnnnnn, tttttttt are the number of NRZ Symbols from Index
       to the start of the sector.
    
       qqq is the number of bytes before the servo burst that splits the sector for all
       sectors in the row.
    
       rrr is the number of bytes after the servo burst that splits the sector for all
       sectors in the row.
    

  <b><i><u>Revision History:</u></i></b>
<a name="DISPLAY_TRACK_INFO_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="DISPLAY_ZONE_INFO_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Display Zone Information"></a><hr align=left width="75%"><b> Display Zone Information (Levels 2, 7 'x')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command displays information about the media partitions (System and User) and
    data zones.

  <b><i><u>Quick Help:</u></i></b>
<a name="DISPLAY_ZONE_INFO_QUICK_HELP"></a>
    "DisplayZoneInfo, x[Partition],[Hd],[Zone],[DisplayWedgeOpSyms]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="DISPLAY_ZONE_INFO_PARM"></a>
    0 - Partition.
    
        This parameter specifies the partition for which the zone information is to
        be displayed.
    
             0 = User Partition
             1 = System Partition
    
          Type:    Unsigned 8-bit value
    
          Range:   0 or 1
    
          Default: If this paremater is not entered, the information will be displayed for
                   all partitions.
    
    1 - Head.
    
        This parameter specifies the head for which the zone information is to be displayed.
    
          Type:    Unsigned 8-bit value
    
          Range:   0 to 0xff
    
          Default: If this parameter is not entered, the zone information will be displayed
                   for all heads.
    
    2 - Zone.
    
        This parameter specifies the zone for which the zone information is to be displayed.
    
          Type:    Unsigned 8-bit value
    
          Range:   0 to 0xff
    
          Default: If this parameter is not entered, the zone information will be displayed
                   for all zones.
    
    3 - Options.
    
         This parameter is a bit significant value that selects the following options:
    
             Bits 31-1: not used
    
             Bit 0:     Display Wedge Operation NRZ Symbol Information option.
    
                        If this bit is equal to 1, the number of NRZ Symbols for
                        the following wedge operations will be displayed: Unformatted
                        Direct Write, Unformatted Direct Read, Formatted Direct Write,
                        Formatted Direct Read.
    
                        This option is only valid for drives that implement VBAR.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xffffffff
    
          Default: 0 (Don't display the Wedge Operation NRZ Symbol information)
    

  <b><i><u>Output Data:</u></i></b>
    For Non VBAR drives:

<a name="NON_VBAR_DRIVE_GEOMETRY_DATA"></a>
    If no error occurred, the following information will be displayed.
    
       "System Partition"
       "  LastLba  LastPba  HdSkew CylSkew MiniZnSkew"
       "  cccccccc dddddddd  eeee   ffff      gggg"
    
       "  Hd FirstCyl LastCyl MiniZnCyls"
       "   h  iiiiii  jjjjjj    kkkkkk"
    
       "  Zones: ll"
       "     First  Total  Spare   First   Sec   Wedge    Spare     Cum     Last  LastMini CumMini"
       "  Zn  Cyl   Cyls   Cyls     Lba    Trk  NrzSyms   Secs     Slips   MiniZn  ZnCyls  ZnSkew"
       "  mm nnnnnn pppppp qqqqqq rrrrrrrr ssss tttttttt uuuuuuuu vvvvvvvv  wwww   xxxxxx   yyyy"
    
       "User Partition"
       "  LastLba  LastPba  HdSkew CylSkew MiniZnSkew"
       "  CCCCCCCC DDDDDDDD  EEEE   FFFF      GGGG"
    
       "  Hd FirstCyl LastCyl MiniZnCyls"
       "   H  IIIIII  JJJJJJ    KKKKKK"
    
       "  Zones: LL"
       "     First  Total  Spare   First   Sec   Wedge    Spare     Cum     Last  LastMini CumMini"
       "  Zn  Cyl   Cyls   Cyls     Lba    Trk  NrzSyms   Secs     Slips   MiniZn  ZnCyls  ZnSkew"
       "  MM NNNNNN PPPPPP QQQQQQ RRRRRRRR SSSS TTTTTTTT UUUUUUUU VVVVVVVV  WWWW   XXXXXX   YYYY"
    
       where
    
          cccccccc is the ending Logical Block Address (LBA) of the System Partition.
    
          dddddddd is the ending Physical Block Address of the System Partition.
    
          eeee is the Head Skew in data wedges for the System Partition.
    
          ffff is the Cylinder Skew in data wedges for the System Partition.
    
          gggg is the mini zone skew in data wedges for the System Partition.
    
          h is the Logical Head Address in the System Partition.
    
          iiiiii is the starting physical cylinder address of the System Partition on
                 the specified head.
    
          jjjjjj is the ending physical cylinder address of the System Partition on
                 the specified head.
    
          kkkkkk is the mini zone size in cylinders for the System Partition.
    
          ll is the number of System Partition data zones.
    
          mm is the System Partition data zone number.
    
          nnnnnn is the starting physical cylinder address of the System Partition
                 data zone.
    
          pppppp is the total number of physical cylinders contained in the System
                 Partition data zone.
    
          qqqqqq is the number of spare cylinders contained in the System Partition data
                 zone.
    
          rrrrrrrr is the starting Logical Block Address (LBA) of the System Partition
                   data zone.
    
          ssss is the number of physical sectors per track in the System Partition data
               zone.
    
          tttttttt is the size of a data wedge in NRZ Symbols.
    
          uuuuuuuu is the number of spare sectors in the System Partition data zone.
    
          vvvvvvvv is the cummulative number of slips in the System Partition data zone.
    
          wwww is the index of the last mini zone in the System Partition data zone.
    
          xxxxxx is the number of cylinders contained in the last mini zone of the System
                 Partition data zone.
    
          yyyy is the cummulative skew per mini zone in System Partition data zone.
    
          CCCCCCCC is the ending Logical Block Address (LBA) of the User Partition.
    
          DDDDDDDD is the ending Physical Block Address of the User Partition.
    
          EEEE is the Head Skew in data wedges for the User Partition.
    
          FFFF is the Cylinder Skew in data wedges for the User Partition.
    
          GGGG is the mini zone skew in data wedges for the User Partition.
    
          H is the Logical Head Address in the User Partition.
    
          IIIIII is the starting physical cylinder address of the User Partition on
                 the specified head.
    
          JJJJJJ is the ending physical cylinder address of the User Partition on
                 the specified head.
    
          KKKKKK is the mini zone size in cylinders for the User Partition.
    
          LL is the number of User Partition data zones.
    
          MM is the User Partition data zone number.
    
          NNNNNN is the starting physical cylinder address of the User Partition
                 data zone.
    
          PPPPPP is the total number of physical cylinders contained in the User
                 Partition data zone.
    
          QQQQQQ is the number of spare cylinders contained in the User Partition data
                 zone.
    
          RRRRRRRR is the starting Disk Logical Block Address (LBA) of the User Partition
                   data zone.
    
          SSSS is the number of physical sectors per track in the User Partition data
               zone.
    
          TTTTTTTT is the size of a data wedge in NRZ Symbols.
    
          UUUUUUUU is the number of spare sectors in the User Partition data zone.
    
          VVVVVVVV is the cummulative number of slips in the User Partition data zone.
    
          WWWW is the index of the last mini zone in the User Partition data zone.
    
          XXXXXX is the number of cylinders contained in the last mini zone of the User
                 Partition data zone.
    
          YYYY is the cummulative skew per mini zone in User Partition data zone.
    

    For VBAR drives:

<a name="VBAR_DRIVE_GEOMETRY_DATA"></a>
    If no error occurred, the following information will be displayed.
    
       "User Partition"
       " LBAs CCCCCCCC - DDDDDDDD"
       " PBAs EEEEEEEE - FFFFFFFF"
       " HdSkew GGGG CylSkew HHHH"
       " ZonesPerHd JJ"
    
       "  Head K, PhyCyls LLLLLLLL - MMMMMMMM, LogCyls NNNNNNNN - PPPPPPPP"
    
       "     First    Sec   Sym   Sym"
       "  Zn Cyl      Track Wedge Track    MHz"
       "  QQ RRRRRRRR SSSS  TTTT  UUUUUUUU VVVVVVVV"
    
       "System Partition"
       " LBAs cccccccc - dddddddd"
       " PBAs eeeeeeee - ffffffff"
       " HdSkew gggg CylSkew hhhh"
       " ZonesPerHd jj"
    
       "  Head k, PhyCyls llllllll - mmmmmmmm, LogCyls nnnnnnnn - pppppppp"
    
       "     First    Sec   Sym   Sym"
       "  Zn Cyl      Track Wedge Track    MHz"
       "  qq rrrrrrrr ssss  tttt  uuuuuuuu vvvvvvvv"
    
       where
    
          CCCCCCCC is the first Logical Block Address (LBA) of the User Partition.
    
          DDDDDDDD is the last Logical Block Address (LBA) of the User Partition.
    
          EEEEEEEE is the first Physical Block Address (PBA) of the User Partition.
    
          FFFFFFFF is the last Physical Block Address (PBA) of the User Partition.
    
          GGGG is the Head Skew in data wedges for the User Partition.
    
          HHHH is the Cylinder Skew in data wedges for the User Partition.
    
          JJ is the number of zones per head in the User Partition.
    
          K is the Logical Head Address of the User Partition zone information to follow.
    
          LLLLLLLL is the starting physical cylinder address of the User Partition on
                   the specified head.
    
          MMMMMMMM is the ending physical cylinder address of the User Partition on
                   the specified head.
    
          NNNNNNNN is the starting logical cylinder address of the User Partition on
                   the specified head.
    
          PPPPPPPP is the ending logical cylinder address of the User Partition on
                   the specified head.
    
          QQ is the User Partition data zone number.
    
          RRRRRRRR is the starting physical cylinder address of the User Partition
                   data zone.
    
          SSSS is the number of physical sectors per track in the User Partition data
               zone.
    
          TTTT is the size of a data wedge in NRZ Symbols for the User Partition data zone.
    
          UUUUUUUU is the size of a track in NRZ Symbols for the User Partition data zone.
    
          VVVVVVVV is the data frequency, in MHz, for the User Partition data zone.
    
          cccccccc is the first Logical Block Address (LBA) of the System Partition.
    
          dddddddd is the last Logical Block Address (LBA) of the System Partition.
    
          eeeeeeee is the first Physical Block Address (PBA) of the System Partition.
    
          ffffffff is the last Physical Block Address (PBA) of the System Partition.
    
          gggg is the Head Skew in data wedges for the System Partition.
    
          hhhh is the Cylinder Skew in data wedges for the System Partition.
    
          jj is the number of zones per head in the System Partition.
    
          k is the Logical Head Address of the System Partition zone information to follow.
    
          llllllll is the starting physical cylinder address of the System Partition on
                   the specified head.
    
          mmmmmmmm is the ending physical cylinder address of the System Partition on
                   the specified head.
    
          nnnnnnnn is the starting logical cylinder address of the System Partition on
                   the specified head.
    
          pppppppp is the ending logical cylinder address of the System Partition on
                   the specified head.
    
          qq is the System Partition data zone number.
    
          rrrrrrrr is the starting physical cylinder address of the System Partition
                   data zone.
    
          ssss is the number of physical sectors per track in the System Partition data
               zone.
    
          tttt is the size of a data wedge in NRZ Symbols for the System Partition data zone.
    
          uuuuuuuu is the size of a track in NRZ Symbols for the System Partition data zone.
    
          vvvvvvvv is the data frequency, in MHz, for the System Partition data zone.
    
    If the Display Wedge Operation NRZ Symbol Information option is enabled (Parameter 3
    Bit 0 set), the following additional information will be displayed for each User and
    System partition zone.
    
       "Sym        Sym        Sym      Sym"
       "UnFmtDirWr UnFmtDirRd FmtDirWr FmtDirRd"
       "WWWW       XXXX       YYYY     ZZZZ"
    
       where
    
          WWWW is the number of NRZ Symbols for an Unformatted Direct Wedge Write operation
               in the zone.
    
          XXXX is the number of NRZ Symbols for an Unformatted Direct Wedge Read operation
               in the zone.
    
          YYYY is the number of NRZ Symbols for an Formatted Direct Wedge Write operation
               in the zone.
    
          ZZZZ is the number of NRZ Symbols for an Formatted Direct Wedge Read operation
               in the zone.
    

  <b><i><u>Revision History:</u></i></b>
<a name="DISPLAY_ZONE_INFO_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0002.0000   Modified to display the logical cylinder range for each head for
                VBAR drives.
    0002.0001   Modified to display the NRZ Symbols per sector for each partition
                for VBAR drives.  Modified to display the NRZ Symbols per Wedge
                for Unformatted Direct Wedge Write and Read and Formatted Direct
                Wedge Write and Read operations on VBAR drives.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="DOS_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Display Directed Offline Scan Information"></a><hr align=left width="75%"><b> Display Directed Offline Scan Information (Level 7 'm')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command is used to display information from the Directed Offline Scan subsystem.

  <b><i><u>Quick Help:</u></i></b>
<a name="DOS_QUICK_HELP"></a>
    "DOS, m[Flags],[StartLba],[EndLba],[MinCount]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="DOS_COMMAND_PARM"></a>
    0 - Action Mask
    
        This input is a bitmask of what should be displayed:
          0x01  counter values
          0x02  counter group descriptors
          0x04  miscellaneous DOS data
          0x08  cylinder and head data
          0x10  number of ought to and need to scans due
          0x100 clear DOS tables and write to disk
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0x100
    
          Default: 4 ( thresholds )
    
    1 - Start LBA
    
        This input is to set the LBA of the first data elements to display.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: 0
    
    2 - End LBA
    
        This input is to set the LBA of the last data elements to display
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: Start LBA ( parm 1 )
    
    3 - Minimum Count To Display
    
        Count values lower than this input will not be displayed.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: 0
    

  <b><i><u>Output Data:</u></i></b>
                                                       Group      Group
    First    log   phys    Last     log   phys      Descriptor  Descriptor
     LBA     cyl    cyl     LBA     cyl    cyl Count    Type       Value   Hd Zn
         0      0      0     34D3      5      5    0     IDX           0    0  0
      aaaa   bbbb   cccc     dddd   eeee   ffff   gg     hhh         iii    j  k
  
   aaaa - First LBA of DOS scan area
                only visible if action mask contains 1h or 2h
  
   bbbb - First logical cylinder of DOS scan area
                only visible if action mask contains 08h
  
   cccc - First physical cylinder of DOS scan area
                only visible if action mask contains 08h
  
   dddd - Last LBA of DOS scan area
                only visible if action mask contains 1h or 2h
  
   eeee - Last logical cylinder of DOS scan area
                only visible if action mask contains 08h
  
   ffff - Last physical cylinder of DOS scan area
                only visible if action mask contains 08h
  
   gg   - Number of writes for this DOS scan area
                only visible if action mask contains 1h or 2h
  
   hhh  - Type of group descriptor.  This will be:
          IDX: The DOS counter group descriptor points to a counter
          CTR: The DOS counter group descriptor is itself a counter
                only visible if action mask contains 2h
  
   iii  - The value in the group descriptor.  This value is most meaningful if the "Group
          Descriptor Type" is CTR.
                only visible if action mask contains 2h
  
   j    - The head that the DOS scan area resides on
                only visible if action mask contains 08h
  
   k    - The zone that the DOS scan area resides in
                only visible if action mask contains 08h
  
  <b><i><u>Examples:</u></i></b>

 F3 7>m1
                                                     
                                                     
    First     Last
     LBA       LBA  Count
         0     34D3    0    0  0
                                                     
 F3 7>m2
                            Counter    Counter
                             Group      Group
    First     Last        Descriptor  Descriptor
     LBA       LBA  Count    Type       Value
         0     34D3    0     IDX           0    0  0
                                                     
 F3 7>m7
                            Counter    Counter
                             Group      Group
    First     Last        Descriptor  Descriptor
     LBA       LBA  Count    Type       Value
         0     34D3    0     IDX           0    0  0
  OughtToScanThreshold: 2000
  NeedToScanThreshold:  2000
  Writes since last save:       0
  Ought to save threshold:    7D0
  Need to save threshold:     FA0
                                                     
 F3 7>m1f
                                                       Counter    Counter
                                                        Group      Group
    First    log   phys    Last     log   phys      Descriptor  Descriptor
     LBA     cyl    cyl     LBA     cyl    cyl Count    Type       Value   Hd Zn
         0      0      0     34D3      5      5    0     IDX           0    0  0
  OughtToScanThreshold: 2000
  NeedToScanThreshold:  2000
  Writes since last save:       0
  Ought to save threshold:    7D0
  Need to save threshold:     FA0
  Scans over ought to threshold: 0
  Scans over need to threshold: 0
 
  <b><i><u>Revision History:</u></i></b>
<a name="DOS_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0001.0001   Add ability to clear counters, add display writes since save, add display
                limits of writes until save.
    0001.0002   Add ability to display cylinder and head information.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="DOWNLOAD_GENERIC_FILE_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Download Generic File"></a><hr align=left width="75%"><b> Download Generic File (Level T 'P')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command downloads a generic file to the drive.

  <b><i><u>Quick Help:</u></i></b>
<a name="DOWNLOAD_GENERIC_FILE_QUICK_HELP"></a>
    "DownloadGenericFile, P[FileBytes]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="DOWNLOAD_GENERIC_FILE_PARM"></a>
    0 - File Bytes.
    
        This parameter specifies the number file bytes to be downloaded.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: None
    

  <b><i><u>Output Data:</u></i></b>
    None.

  <b><i><u>Revision History:</u></i></b>
<a name="DOWNLOAD_GENERIC_FILE_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="DRIVE_FREE_FALL_PROTECTION_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Drive Free Fall Protection"></a><hr align=left width="75%"><b> Drive Free Fall Protection (Level 5 'F')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command does the drive free fall protection control, measurement and
    simulation.

  <b><i><u>Quick Help:</u></i></b>
<a name="DRIVE_FREE_FALL_PROTECTION_QUICK_HELP"></a>
    "DriveFreeFallProtection, F[OpCode],[SimDur],[SimSensorOutputs]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="DRIVE_FREE_FALL_PROTECTION_PARM"></a>
    0 - Operation Code Of Drive Free Fall Protection
    
        This parameter specifies the operation code of the drive free fall
        protection.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: None
    
    1 - Free-Fall Timer Sensitivity
    
        This parameter specifies the free-fall timer sensitvity.
    
          Type:    Unsigned 8-bit value
    
          Range:   0 to 0xFF
    
          Default: None
    
    2 - Tumble Timer Sensitivity
    
        This parameter specifies the tumble timer sensitvity.
    
          Type:    Unsigned 8-bit value
    
          Range:   0 to 0xFF
    
          Default: None
    
    3 - Simulation Duration
    
        This parameter specifies the duration to simulate the drive free fall
        protection.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: None
    
    4 - Simulation Sensor Outputs
    
        This parameter specifies the simulation outputs value to be applied.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: None
    

  <b><i><u>Output Data:</u></i></b>
<a name="DRIVE_FREE_FALL_PROTECTION_DATA"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
        If no error occurred, the following will be displayed
    
          Read/Write Drive Free Fall Protection Info
          Read/Write Free Fall Protection is AA
          Read/Write Free Fall Protection Event is BB
          Read/Write Free Fall Protection is CC
    
          Servo Drive Free Fall Protection Info
          Servo Free Fall Protection is DD
          Servo Free Fall Protection Event is EE
          Servo Free Fall Sensor Health = FF
    
           where
    
              AA is the status of Read/Write Free Fall Protection.
    
              BB is the status of Read/Write Free Fall Protection Event.
    
              CC is the status of Read/Write Free Fall Protection Activation.
    
              DD is the status of Servo Free Fall Protection.
    
              EE is the status of Servo Free Fall Protection Event.
    
              FF is the value of Servo Free Fall Sensor Health.
    

  <b><i><u>Revision History:</u></i></b>
<a name="DRIVE_FREE_FALL_PROTECTION_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="EDIT_BUFFER_MEMORY_BYTE_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Edit Buffer Memory Byte"></a><hr align=left width="75%"><b> Edit Buffer Memory Byte (Level 1 'U')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    The Edit Buffer Memory Byte command displays the contents of the specified buffer
    memory location and prompts the user ( --> ) to enter a new value to be written
    to the location.  While waiting for the new value to be entered, this command will
    monitor the memory location and display its value if it changes.

    Entering a Line Feed (Control J) character following the prompt will increment the
    buffer memory address and display the value of the next location.

    The command is terminated when a carriage return is entered following the prompt.

    This command default to editing memory one byte (8-bits) at a time.

    ************************************** NOTE *********************************************
    This command should be used with great caution, since it has the potential to corrupt
    critical data stored in the data buffer.
    *****************************************************************************************

  <b><i><u>Quick Help:</u></i></b>
<a name="EDIT_BUFFER_MEMORY_BYTE_QUICK_HELP"></a>
    "EditBufferMemoryByte, U[AddrHi],[AddrLo],[MemValue],[NumBytes]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="EDIT_MEMORY_PARM"></a>
    0 - Memory Address or Memory Address High.
    
        If Parameter 1 is not entered, this parameter contains the 32-bit address
        of the first memory byte to be edited.  If Parameter 1 is entered, this
        parameter contains the upper 16-bits of the address of the first memory
        byte to be edited.
    
          Type:    Unsigned 32-bit value, if parameter 1 is not entered
                   Unsigned 16-bit value, if parameter 1 is entered
    
          Range:   0 to 0xffff, if parameter 1 is not entered
                   0 to 0xffffffff, if parameter 1 is entered
    
                   The specified address must be properly aligned for the number of
                   bytes to be edited.  Parameter 3 specifies the number of bytes to
                   be edited.  If Parameter 3 is equal to 4, the specified address
                   must be a multiple of 4.  If Parameter 3 is equal to 2, the
                   specified address must be a multiple of 2.
    
          Default: 0
    
    1 - Memory Address Low.
    
        If entered, this parameter contains the lower 16-bits of the address of the
        first memory byte to be edited.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xffff
    
                   The specified address must be properly aligned for the number of
                   bytes to be edited.  Parameter 3 specifies the number of bytes to
                   be edited.  If Parameter 3 is equal to 4, the specified address
                   must be a multiple of 4.  If Parameter 3 is equal to 2, the
                   specified address must be a multiple of 2.
    
          Default: None. If this parameter is not entered, Parameter 0 is assumed
                   to specify the entire 32-bit address of the first memory byte
                   to be edited.
    
    2 - Memory Data.
    
        If entered, this parameter contains the value with which the specified memory
        address is to be written.
    
          Type:    Unsigned 32-bit value, if parameter 3 is equal to 4
                   Unsigned 16-bit value, if parameter 3 is equal to 2
                   Unsigned 8-bit value, if parameter 3 is not entered or is equal to 1
    
          Range:   0 to 0xffffffff, if parameter 3 is equal to 4
                   0 to 0xffff, if parameter 3 is equal to 2
                   0 to 0xff, if parameter 3 was not entered or is equal to 1
    
          Default: None. If this parameter is not entered, the specified memory
                   address will be read, the value will be displayed and the
                   user will be prompted to enter a new value.  While waiting
                   for a new value to be entered, this command will monitor the
                   value of the specified memory location and display the value
                   if it changes.
    
    3 - Number of Bytes.
    
        This parameter specifies the number of memory bytes to be displayed or modified.
        The memory address specified by Parameters 0 and 1 must be a multiple of this value.
        For example, if this parameter is equal to 4, the specified address must be a
        multiple of 4 and if this parameter is equal to 2, the specified address must be
        a multiple of 2.
    
          Type:    Unsigned 8-bit value
    
          Range:   1, 2 and 4 are the allowed values
    
          Default: 1 byte for the Level 1 'U' and 'S'
                   2 bytes for the Level 1 'm'
    

  <b><i><u>Output Data:</u></i></b>
<a name="EDIT_MEMORY_DATA"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
        If no error occurred, the memory data will be displayed as follows.
    
              "Adr cccccccc ( dddddddd ) = ee --> "          or
              "Adr cccccccc ( dddddddd ) = ffff --> "        or
              "Adr cccccccc ( dddddddd ) = gggggggg --> "
    
           where
    
              cccccccc is the byte offset from the start of the memory
    
              dddddddd is the processor address
    
              ee is an 8-bit value written to or read from memory
    
              ffff is a 16-bit value written to or read from memory
    
              gggggggg is a 32-bit value written to or read from memory
    

  <b><i><u>Revision History:</u></i></b>
<a name="EDIT_BUFFER_MEMORY_BYTE_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="EDIT_PROCESSOR_MEMORY_BYTE_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Edit Processor Memory Byte"></a><hr align=left width="75%"><b> Edit Processor Memory Byte (Level 1 'S')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    The Edit Processor Memory Byte command displays the contents of the specified processor
    memory location and prompts the user ( --> ) to enter a new value to be written to the
    location.  While waiting for the new value to be entered, this command will monitor the
    memory location and display its value if it changes.

    Entering a Line Feed (Control J) character following the prompt will increment the
    processor memory address and display the value of the next location.

    The command is terminated when a carriage return is entered following the prompt.

    This command default to editing memory one byte (8-bits) at a time.

  <b><i><u>Quick Help:</u></i></b>
<a name="EDIT_PROCESSOR_MEMORY_BYTE_QUICK_HELP"></a>
    "EditProcessorMemoryByte, S[AddrHi],[AddrLo],[MemValue],[NumBytes],[Opts]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="EDIT_MEMORY_PARM"></a>
    0 - Memory Address or Memory Address High.
    
        If Parameter 1 is not entered, this parameter contains the 32-bit address
        of the first memory byte to be edited.  If Parameter 1 is entered, this
        parameter contains the upper 16-bits of the address of the first memory
        byte to be edited.
    
          Type:    Unsigned 32-bit value, if parameter 1 is not entered
                   Unsigned 16-bit value, if parameter 1 is entered
    
          Range:   0 to 0xffff, if parameter 1 is not entered
                   0 to 0xffffffff, if parameter 1 is entered
    
                   The specified address must be properly aligned for the number of
                   bytes to be edited.  Parameter 3 specifies the number of bytes to
                   be edited.  If Parameter 3 is equal to 4, the specified address
                   must be a multiple of 4.  If Parameter 3 is equal to 2, the
                   specified address must be a multiple of 2.
    
          Default: 0
    
    1 - Memory Address Low.
    
        If entered, this parameter contains the lower 16-bits of the address of the
        first memory byte to be edited.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xffff
    
                   The specified address must be properly aligned for the number of
                   bytes to be edited.  Parameter 3 specifies the number of bytes to
                   be edited.  If Parameter 3 is equal to 4, the specified address
                   must be a multiple of 4.  If Parameter 3 is equal to 2, the
                   specified address must be a multiple of 2.
    
          Default: None. If this parameter is not entered, Parameter 0 is assumed
                   to specify the entire 32-bit address of the first memory byte
                   to be edited.
    
    2 - Memory Data.
    
        If entered, this parameter contains the value with which the specified memory
        address is to be written.
    
          Type:    Unsigned 32-bit value, if parameter 3 is equal to 4
                   Unsigned 16-bit value, if parameter 3 is equal to 2
                   Unsigned 8-bit value, if parameter 3 is not entered or is equal to 1
    
          Range:   0 to 0xffffffff, if parameter 3 is equal to 4
                   0 to 0xffff, if parameter 3 is equal to 2
                   0 to 0xff, if parameter 3 was not entered or is equal to 1
    
          Default: None. If this parameter is not entered, the specified memory
                   address will be read, the value will be displayed and the
                   user will be prompted to enter a new value.  While waiting
                   for a new value to be entered, this command will monitor the
                   value of the specified memory location and display the value
                   if it changes.
    
    3 - Number of Bytes.
    
        This parameter specifies the number of memory bytes to be displayed or modified.
        The memory address specified by Parameters 0 and 1 must be a multiple of this value.
        For example, if this parameter is equal to 4, the specified address must be a
        multiple of 4 and if this parameter is equal to 2, the specified address must be
        a multiple of 2.
    
          Type:    Unsigned 8-bit value
    
          Range:   1, 2 and 4 are the allowed values
    
          Default: 1 byte for the Level 1 'U' and 'S'
                   2 bytes for the Level 1 'm'
    
<a name="EDIT_PROCESSOR_MEMORY_PARM"></a>
    4 - Options.
    
        Parameter 4 bit 0 controls the validation of the processor memory address.
    
            Bit 15-1: not used
    
            Bit 0: Disable Memory Address Validation
    
                   If this bit is cleared, the specified memory address will be validated
                   before attempting to read or write the location.  If this bit is set,
                   the specified memory address will be used without first validating it
                   against the memory map.
    
                   ******************************** NOTE ***********************************
                   Attempting to read or write an invalid memory address may hang the drive.
                   *************************************************************************
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0x0001
    
          Default: 0 (Enable Memory Address Validation)
    

  <b><i><u>Output Data:</u></i></b>
<a name="EDIT_MEMORY_DATA"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
        If no error occurred, the memory data will be displayed as follows.
    
              "Adr cccccccc ( dddddddd ) = ee --> "          or
              "Adr cccccccc ( dddddddd ) = ffff --> "        or
              "Adr cccccccc ( dddddddd ) = gggggggg --> "
    
           where
    
              cccccccc is the byte offset from the start of the memory
    
              dddddddd is the processor address
    
              ee is an 8-bit value written to or read from memory
    
              ffff is a 16-bit value written to or read from memory
    
              gggggggg is a 32-bit value written to or read from memory
    

  <b><i><u>Revision History:</u></i></b>
<a name="EDIT_PROCESSOR_MEMORY_BYTE_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="EDIT_PROCESSOR_MEMORY_WORD_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Edit Processor Memory Word"></a><hr align=left width="75%"><b> Edit Processor Memory Word (Level 1 'm')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    The Edit Processor Memory Word command displays the contents of the specified processor
    memory location and prompts the user ( --> ) to enter a new value to be written to the
    location.  While waiting for the new value to be entered, this command will monitor the
    memory location and display its value if it changes.

    Entering a Line Feed (Control J) character following the prompt will increment the
    processor memory address and display the value of the next location.

    The command is terminated when a carriage return is entered following the prompt.

    This command default to editing memory two bytes (16-bits) at a time.

  <b><i><u>Quick Help:</u></i></b>
<a name="EDIT_PROCESSOR_MEMORY_WORD_QUICK_HELP"></a>
    "EditProcessorMemoryWord, m[AddrHi],[AddrLo],[MemValue],[NumBytes],[Opts]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="EDIT_MEMORY_PARM"></a>
    0 - Memory Address or Memory Address High.
    
        If Parameter 1 is not entered, this parameter contains the 32-bit address
        of the first memory byte to be edited.  If Parameter 1 is entered, this
        parameter contains the upper 16-bits of the address of the first memory
        byte to be edited.
    
          Type:    Unsigned 32-bit value, if parameter 1 is not entered
                   Unsigned 16-bit value, if parameter 1 is entered
    
          Range:   0 to 0xffff, if parameter 1 is not entered
                   0 to 0xffffffff, if parameter 1 is entered
    
                   The specified address must be properly aligned for the number of
                   bytes to be edited.  Parameter 3 specifies the number of bytes to
                   be edited.  If Parameter 3 is equal to 4, the specified address
                   must be a multiple of 4.  If Parameter 3 is equal to 2, the
                   specified address must be a multiple of 2.
    
          Default: 0
    
    1 - Memory Address Low.
    
        If entered, this parameter contains the lower 16-bits of the address of the
        first memory byte to be edited.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xffff
    
                   The specified address must be properly aligned for the number of
                   bytes to be edited.  Parameter 3 specifies the number of bytes to
                   be edited.  If Parameter 3 is equal to 4, the specified address
                   must be a multiple of 4.  If Parameter 3 is equal to 2, the
                   specified address must be a multiple of 2.
    
          Default: None. If this parameter is not entered, Parameter 0 is assumed
                   to specify the entire 32-bit address of the first memory byte
                   to be edited.
    
    2 - Memory Data.
    
        If entered, this parameter contains the value with which the specified memory
        address is to be written.
    
          Type:    Unsigned 32-bit value, if parameter 3 is equal to 4
                   Unsigned 16-bit value, if parameter 3 is equal to 2
                   Unsigned 8-bit value, if parameter 3 is not entered or is equal to 1
    
          Range:   0 to 0xffffffff, if parameter 3 is equal to 4
                   0 to 0xffff, if parameter 3 is equal to 2
                   0 to 0xff, if parameter 3 was not entered or is equal to 1
    
          Default: None. If this parameter is not entered, the specified memory
                   address will be read, the value will be displayed and the
                   user will be prompted to enter a new value.  While waiting
                   for a new value to be entered, this command will monitor the
                   value of the specified memory location and display the value
                   if it changes.
    
    3 - Number of Bytes.
    
        This parameter specifies the number of memory bytes to be displayed or modified.
        The memory address specified by Parameters 0 and 1 must be a multiple of this value.
        For example, if this parameter is equal to 4, the specified address must be a
        multiple of 4 and if this parameter is equal to 2, the specified address must be
        a multiple of 2.
    
          Type:    Unsigned 8-bit value
    
          Range:   1, 2 and 4 are the allowed values
    
          Default: 1 byte for the Level 1 'U' and 'S'
                   2 bytes for the Level 1 'm'
    
<a name="EDIT_PROCESSOR_MEMORY_PARM"></a>
    4 - Options.
    
        Parameter 4 bit 0 controls the validation of the processor memory address.
    
            Bit 15-1: not used
    
            Bit 0: Disable Memory Address Validation
    
                   If this bit is cleared, the specified memory address will be validated
                   before attempting to read or write the location.  If this bit is set,
                   the specified memory address will be used without first validating it
                   against the memory map.
    
                   ******************************** NOTE ***********************************
                   Attempting to read or write an invalid memory address may hang the drive.
                   *************************************************************************
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0x0001
    
          Default: 0 (Enable Memory Address Validation)
    

  <b><i><u>Output Data:</u></i></b>
<a name="EDIT_MEMORY_DATA"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
        If no error occurred, the memory data will be displayed as follows.
    
              "Adr cccccccc ( dddddddd ) = ee --> "          or
              "Adr cccccccc ( dddddddd ) = ffff --> "        or
              "Adr cccccccc ( dddddddd ) = gggggggg --> "
    
           where
    
              cccccccc is the byte offset from the start of the memory
    
              dddddddd is the processor address
    
              ee is an 8-bit value written to or read from memory
    
              ffff is a 16-bit value written to or read from memory
    
              gggggggg is a 32-bit value written to or read from memory
    

  <b><i><u>Revision History:</u></i></b>
<a name="EDIT_PROCESSOR_MEMORY_WORD_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="ENABLE_AND_INIT_RW_STATISTICS_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Enable and Init RW Statistics"></a><hr align=left width="75%"><b> Enable and Init RW Statistics (Online Control W)</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command turns on and read / write statistics gathering and zeros the error counters.

  <b><i><u>Related Commands:</u></i></b>
    any level ` - display error counters
    level L i   - L>iFFFD will zero out the error counters.
    level L E   - L>E,,0 will disable statistics gathering
                - L>E,,1 will enable statistics gathering
                - L>E,,2 will zero out the error counters.

  <b><i><u>Quick Help:</u></i></b>
<a name="ENABLE_AND_INIT_RW_STATISTICS_QUICK_HELP"></a>
    "RwStatsEnableAndInit";

  <b><i><u>Input Parameters:</u></i></b>
    none

  <b><i><u>Output Data:</u></i></b>
<a name="RW_STATS_CONTROL_DATA"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
        The following will be displayed
    
              "Rd/Wr stats On"
        or
              "Rd/Wr stats Off"
    
    ( always "Rd/Wr Stats On" for Ctl-W )

  <b><i><u>Revision History:</u></i></b>
<a name="ENABLE_AND_INIT_RW_STATISTICS_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="ENABLE_DISABLE_CHANNEL_PREAMP_REGISTER_DISPLAY_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Enable/Disable Channel/Preamp Register Display"></a><hr align=left width="75%"><b> Enable/Disable Channel/Preamp Register Display (Level 2 'u')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command enables or disables the display of channel registers during retries.

  <b><i><u>Quick Help:</u></i></b>
<a name="ENABLE_DISABLE_CHANNEL_PREAMP_REGISTER_DISPLAY_QUICK_HELP"></a>
    "EnableDisableChannelPreampRegDisplay, u[EnableDisableOpt]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="ENABLE_DISABLE_CHANNEL_PREAMP_REGISTER_DISPLAY_PARM"></a>
    0 - Enable/Disable Channel/Preamp Register Display.
    
          This parameter will enable or disable the display of channel registers during
          retries.  If this parameter is set to 1, then channel registers will be displayed
          during retries.  If this parameter is not entered or set to 0, then channel
          will not be displayed during retries.
    
          Type:    Unsigned 8-bit value
    
          Range:   0 to 1
    
          Default: 0 (Disable channel/preamp tracing)
    

  <b><i><u>Output Data:</u></i></b>
<a name="ENABLE_DISABLE_CHANNEL_PREAMP_REGISTER_DISPLAY_OUTPUT_DATA"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
        If no error occurred, the following information will be displayed.
    
              "Channel tracing enabled"
    
              "Preamp tracing enabled"
    
        or
    
              "Channel Tracing disabled"
    
              "Preamp Tracing disabled"
    
        to indicate whether Channel/Preamp tracing has been enabled or disabled.  NOTE: If the
        read/write does NOT support Channel or Preamp Tracing, then the message will ALWAYS
        indicate that the feature is "disabled".
    

  <b><i><u>Revision History:</u></i></b>
<a name="ENABLE_DISABLE_CHANNEL_PREAMP_REGISTER_DISPLAY_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="ENABLE_DISABLE_LOGGING_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Enable / Disable Logging"></a><hr align=left width="75%"><b> Enable / Disable Logging (Level L 'E')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command enables / disables Error Logging, ASCII Logging and / or Read/Write
    Statistics Logging.  It also allows a user-created log to be selected.

    The following are the default or special log files supported by the diagnostics:
    0x0000: ACTIVE_ERROR_LOG_ID - Indicates the currently active error log.
    0x0001: ACTIVE_ASCII_LOG_ID - Indicates the currently active ASCII log.
    0x0002: ACTIVE_RW_STATISTICS_LOG_ID - Indicates the currently active R/W statistics log.
    0xFFFC: DEFAULT_ERROR_LOG_ID - Indicates the default error log.
    0xFFFD: DEFAULT_RW_STATISTICS_LOG_ID - Indicates the default R/W statistics log.
    0xFFFE: TEMPORARY_LOG_ID - This log is used internally for copy operations.
    0xFFFF: INVALID_LOG_ID - Indicates an invalid log.

  <b><i><u>Quick Help:</u></i></b>
<a name="ENABLE_DISABLE_LOGGING_QUICK_HELP"></a>
    "EnableDisableLogging, E[ErrLoggingOpt],[AsciiLoggingOpt],[RwStatsLoggingOpt]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="ENABLE_DISABLE_LOGGING_PARM"></a>
    0 - Enable or Disable Error Logging.
    
        This parameter enables Error Logging and selects the Active Error Log or disables
        Error Logging.  If this parameter is not entered, the current Error Logging mode
        will not be changed.  If this parameter is set to 1, then Error Logging will be
        enabled and the Default Error Log will be selected as the Active Error Log.  If
        this parameter is set to 2 or greater, then Error Logging will be enabled and this
        parameter will specify the ID of the log to be selected as the Active Error Log.
        
             0 = Disable Error Logging
             1 = Enable Error Logging and select Default Error Log
             2 to 0xFFFF = Enable Error Logging and select specified log
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: None
    
    1 - Enable or Disable ASCII Logging.
    
        This parameter enables or disables ASCII Logging.  If this parameter is not
        entered, the current ASCII Logging mode will not be changed.
    
             0 = Disable ASCII Logging
             1 = Enable ASCII Logging
    
          Type:    Unsigned 8-bit value
    
          Range:   0 or 1
    
          Default: None
    
    2 - Enable or Disable Read / Write Statistics Logging.
    
        This parameter enables or disables Read / Write Statistics Logging.  If this
        parameter is not entered, the current Read / Write Statistics Logging mode will
        not be changed.
    
             0 = Disable Read / Write Statistics Logging
             1 = Enable Read / Write Statistics Logging
             2 = Zero Read / Write Statistics Log
    
          Type:    Unsigned 8-bit value
    
          Range:   0 to 2
    
          Default: None
    

  <b><i><u>Output Data:</u></i></b>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    

  <b><i><u>Revision History:</u></i></b>
<a name="ENABLE_DISABLE_LOGGING_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).
    0011.0001   Added support for selecting a user-created error log.

<a name="ENABLE_DISABLE_PES_OUTPUT_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Enable / Disable PES Output"></a><hr align=left width="75%"><b> Enable / Disable PES Output (Level 4 'e')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command is used to enable / disable PES Output. When PES Output is enabled, real
    time PES signal will be outputted to AMUX test pin. A Left Shift Number is used to
    control the signal's resolution. First, the 16-bit PES value (Bit 15: sign bit,
    Bits 14 - 12: number of full tracks, Bits 11 - 0: fraction of one track. So 1000h means
    a full track and 800h is half of a track) is left shifted by the number specified in this
    command, and then the high byte of the shifted result is sent out to AMUX.

  <b><i><u>Quick Help:</u></i></b>
<a name="ENABLE_DISABLE_PES_OUTPUT_QUICK_HELP"></a>
    "EnableDisablePesOutput, e[PesLeftShiftCnt],[DisablePesOut]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="ENABLE_DISABLE_PES_OUTPUT_PARM"></a>
    0 - PES Output Left Shift Count.
    
       This parameter specifies the number of bits the PES value is to be shifted left
       before it is outputted.
    
       This parameter is only valid if Parameter 1 is not entered. If Parameter 1 is not
       entered and this parameter is not entered, then the current PES output state will
       be displayed.
    
          Type: Unsigned 16-bit value
    
          Range: 0 to 0x000E
    
          Default: None.
    1 - Disable PES Output.
    
       If this parameter is entered, PES output will be disabled. If this parameter is not
       entered and Parameter 0 is entered, PES output will be enabled. If this parameter
       is not entered and Parameter 0 is not entered, the current PES output state will be
       displayed.
    
          Type: Unsigned 16-bit value
    
          Range: 0 to 0xFFFF
    
          Default: None.

  <b><i><u>Output Data:</u></i></b>
<a name="ENABLE_DISABLE_PES_OUTPUT_DATA"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
        When PES Output is enabled, the result is displayed as:
    
           DiagDac On with Resolution = 2^ xx
              where xx is the PES Left Shift Number (in Hex format)
    
    
        When PES Output is disabled, the result is displayed as:
    
           PES output Disabled

  <b><i><u>Revision History:</u></i></b>
<a name="ENABLE_DISABLE_PES_OUTPUT_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="ENABLE_DISABLE_RVFF_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Enable / Disable RVFF"></a><hr align=left width="75%"><b> Enable / Disable RVFF (Level 4 'B')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command is used to enable / disable RVFF control in servo.

  <b><i><u>Quick Help:</u></i></b>
<a name="ENABLE_DISABLE_RVFF_QUICK_HELP"></a>
    "EnableDisableRvff, B[NewRvffControlMode]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="ENABLE_DISABLE_RVFF_PARM"></a>
    0 - New RVFF control mode to be used in servo.
    
       This parameter specifies the new RVFF control mode to be used in servo.
       Here is meaning of each bit of the RVFF control mode:
    
          Bit 0 = 0 then disable rv current injection
                = 1 then enable rv current injection
          Bit 1 = 0 then bypass velocity control portion of rv_ff code
                = 1 then execute velocity control portion of rv_ff code
          Bit 2 = 0 then bypass track following control portion of rv_ff code
                = 1 then execute track following control portion of rv_ff code
          Bit 3 = 0 then disable the averaging funtion in the track following portion
                = 1 then enable the averaging funtion in the track following portion
          Bit 4 = 0 then disable filtx gain parameter adaptation
                = 1 then enable filtx gain parameter adaptation
          Bit 5 = 0 then disable rv data acquisition during twiddle
                = 1 then enable rv data acquisition during twiddle
          Bit 6 reserved
          Bit 7 = 0 then disable rv current injection in velocity/settle mode
                = 1 then enable rv current injection in velocity/settle mode
          Bit 8 = 0 then Normal Code (RVFF IIR is tuned up for NearLine RV Spec)
                = 1 then Enable 2nd RVFF IIR Tuneup for DeskTop RV Spec
          Bit 9 = 0 Normal code
                = 1 McKinley DT Shock Detect method with external shock sensor is enabled
          Bits 10 - 15 reserved
    
       When this parameter is not entered, this command will simply display the current
       RVFF control mode without changing it.
    
          Type: Unsigned 16-bit value
    
          Range: 0 to 0xFFFF
    
          Default: None.

  <b><i><u>Output Data:</u></i></b>
<a name="ENABLE_DISABLE_RVFF_DATA"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
        RVFF control mode: xxxx:
              where xxxx is the RVFF control mode in servo (in Hex format)

  <b><i><u>Revision History:</u></i></b>
<a name="ENABLE_DISABLE_RVFF_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="ENABLE_DISABLE_SERVO_UPDATES_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Enable / Disable Servo Updates"></a><hr align=left width="75%"><b> Enable / Disable Servo Updates (Level 5 'U')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command enables or disables servo VCM DAC and / or A to D updates.

  <b><i><u>Quick Help:</u></i></b>
<a name="ENABLE_DISABLE_SERVO_UPDATES_QUICK_HELP"></a>
    "EnableDisableServoUpdates, U[VcmDacUpdateOpt],[AToDUdateOpt]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="ENABLE_DISABLE_SERVO_UPDATES_PARM"></a>
    0 - Disable / Enable VCM DAC Updates.
    
        If this parameter is equal to 0, servo updates of the VCM DAC will be disabled,
        else servo updates of the VCM DAC will be enabled.
    
          Type:    Unsigned 8-bit value
    
          Range:   0 to 0xFF
    
          Default: 1
    
    1 - Disable / Enable A to D Updates.
    
        If this parameter is equal to 0, servo A to D updates will be disabled, else
        servo A to D updates will be enabled.
    
          Type:    Unsigned 8-bit value
    
          Range:   0 to 0xFF
    
          Default: 1
    

  <b><i><u>Output Data:</u></i></b>
<a name="SERVO_UPDATES_STATUS"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
        If Servo VCM DAC updates are enabled, the following information will be displayed.
    
           "Servo VCM DAC Updates enabled"
    
        If Servo VCM DAC updates are enabled, the following information will be displayed.
    
           "Servo VCM DAC Updates disabled"
    
        If Servo A to D updates are enabled, the following information will be displayed.
    
           "Servo A to D Updates enabled"
    
        If Servo A to D updates are enabled, the following information will be displayed.
    
           "Servo A to D Updates disabled"
    

  <b><i><u>Revision History:</u></i></b>
<a name="ENABLE_DISABLE_SERVO_UPDATES_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="ENABLE_DISABLE_WRITE_FAULT_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Enable / Disable Write Fault"></a><hr align=left width="75%"><b> Enable / Disable Write Fault (Level 7 'u')</b><hr align=left width="75%">
  <b><i><u>Description:</u></i></b>
    This command enables or disables Write Fault errors.

  <b><i><u>Quick Help:</u></i></b>
<a name="ENABLE_DISABLE_WRITE_FAULT_QUICK_HELP"></a>
    "EnableDisableWrFault, u[Op]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="ENABLE_DISABLE_WRITE_FAULT_PARM"></a>
    0 - Operation.
    
        If Parameter 0 is not set, toggle the current state (not currently supported)
        If Parameter 0 is set to 0, turn write faults off
        If Parameter 0 is set to non-0, turn write faults on
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 1
    
          Default: none (toggle)
    

  <b><i><u>Output Data:</u></i></b>
<a name="WRITE_FAULT_TOGGLE_STATUS"></a>
    If no error occurred and write faults were disabled, the following message will be
    displayed.
    
          "Write Faults Disabled"
    
    If no error occurred and write faults were enabled, the following message will be
    displayed.
    
          "Write Faults Enabled"
    
    If the user tried to use the deprecated toggle mode, an error will be set and the
    following message will also be displayed.
    
          "Write Fault Toggle Unsupported"
    

  <b><i><u>Revision History:</u></i></b>
<a name="ENABLE_DISABLE_WRITE_FAULT_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="ENABLE_LOOPING_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Enable Looping"></a><hr align=left width="75%"><b> Enable Looping (All Levels 'L')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command enables looping, with the specified loop count and  options, on the next
    diagnostic command received.

  <b><i><u>Quick Help:</u></i></b>
<a name="ENABLE_LOOPING_QUICK_HELP"></a>
    "EnableLooping, L[Opts],[CountOrStopOnErrCode]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="ENABLE_LOOPING_PARM"></a>
    0 - Looping Options.
    
        This parameter is a bit-significant value that specifies the following options:
    
<a name="DIAG_CMD_LOOP_INFO_OPTIONS"></a>
          Bit 15-7: reserved
          
          Bit 6: Enable Stop on Test Space Wrapped
          
                 If this bit is equal to 1, then looping will stop when the Test
                 Space wraps.  This means that when the current head and track have
                 incremented past the end of the Test Space and have been wrapped
                 back to the beginning of the Test Space, then looping will stop.
          
          Bit 5: Enable Stop on Specified Error
          
                 If this bit is equal to 1, looping will be halted if the command
                 completes with the error code specified by Parameter 1.
          
          Bit 4: Disable Error Display
          
                 If this bit is equal to 1, errors that occur while looping will
                 not be displayed.
          
          Bit 3: reserved
          
          Bit 2: Enable Spin Down on Error
          
                 If this bit is equal to 1, the drive will be spun down if the
                 command completes with an error.
          
          Bit 1: Enable Stop on No Error
          
                 If this bit is equal to 1, looping will be halted if the command
                 completes with no error.
          
          Bit 0: Enable Continue on Error
          
                 If this bit is equal to 1, looping will continue if the command
                 completes with an error.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xffff
    
          Default: All options disabled
    
    1 - Stop On Error Code / Loop Count.
    
        If Parameter 0 bit 5 is equal to 1, this parameter will specify the Error
        Code on which looping should be halted.  If Parameter 0 bit 5 is equal to 0,
        this parameter will specify the number of times the command will be looped.
        Setting the Loop Count to 0 will cause the command to loop until one of the
        stop conditions specified by Parameter 1 occurs or until looping is aborted
        by the user entering a Carriage Return.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xffffffff
    
          Default: 0
    

  <b><i><u>Output Data:</u></i></b>
    None

  <b><i><u>Revision History:</u></i></b>
<a name="ENABLE_LOOPING_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0001.0001   Increased the size of Parameter 1 (Error Code or Loop Count) to 32-bits.
    0001.0002   Add option to enable stopping when the Test Space wraps.

<a name="ENABLE_ESLIP_SERIAL_PORT_MODE_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Enable ESLIP Serial Port Mode"></a><hr align=left width="75%"><b> Enable ESLIP Serial Port Mode (Online Control T)</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command enables ESLIP serial port mode.  In this mode, ASCII online and
    diagnostic mode commands are disabled and packet serial port mode is selected.

  <b><i><u>Quick Help:</u></i></b>
<a name="ENABLE_ESLIP_SERIAL_PORT_MODE_QUICK_HELP"></a>
    "EnableEslipSerialPortMode";

  <b><i><u>Input Parameters:</u></i></b>
    None

  <b><i><u>Output Data:</u></i></b>
    None

  <b><i><u>Revision History:</u></i></b>
<a name="ENABLE_ESLIP_SERIAL_PORT_MODE_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="ENABLE_ASCII_DIAG_SERIAL_PORT_MODE_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Enable ASCII Diagnostic Serial Port Mode"></a><hr align=left width="75%"><b> Enable ASCII Diagnostic Serial Port Mode (Online Control Z)</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command enables ASCII Diagnostic Serial Port mode.  In this mode, non-packet serial
    port mode is selected and online and ASCII seriap port diagnostic mode commands are
    enabled.

  <b><i><u>Quick Help:</u></i></b>
<a name="ENABLE_ASCII_DIAG_SERIAL_PORT_MODE_QUICK_HELP"></a>
    "EnableAsciiDiagSerialPortMode";

  <b><i><u>Input Parameters:</u></i></b>
    None

  <b><i><u>Output Data:</u></i></b>
    None

  <b><i><u>Revision History:</u></i></b>
<a name="ENABLE_ASCII_DIAG_SERIAL_PORT_MODE_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="ENABLE_ASCII_ONLINE_SERIAL_PORT_MODE_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Enable ASCII Online Serial Port Mode"></a><hr align=left width="75%"><b> Enable ASCII Online Serial Port Mode (Online Control R)</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command enables ASCII Online Serial Port Mode.  In this mode, non-packet serial
    port mode is selected, ASCII online serial port commands are enabled and diagnostic
    mode commands are disabled.

  <b><i><u>Quick Help:</u></i></b>
<a name="ENABLE_ASCII_ONLINE_SERIAL_PORT_MODE_QUICK_HELP"></a>
    "EnableAsciiOnlineSerialPortMode";

  <b><i><u>Input Parameters:</u></i></b>
    None

  <b><i><u>Output Data:</u></i></b>
    None

  <b><i><u>Revision History:</u></i></b>
<a name="ENABLE_ASCII_ONLINE_SERIAL_PORT_MODE_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="ENTER_BATCH_FILE_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Enter Batch File"></a><hr align=left width="75%"><b> Enter Batch File (Level 6 'E')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command inputs the specified Diagnostic Command Batch File.  A Batch File is
    sequence of Diagnostic Commands entered by the user via the serial port interface.
    The user terminates the Batch File by entering the '|' character.

    A Batch File may contain both Diagnostic Mode and Online commands.

  <b><i><u>Quick Help:</u></i></b>
<a name="ENTER_BATCH_FILE_QUICK_HELP"></a>
    "EnterBatchFile, E[BatchFileNum]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="ENTER_BATCH_FILE_PARM"></a>
    0 - Batch File Number.
    
        This parameter specifies the number of the Batch File to be entered.
        
          Type:    Unsigned 8-bit value
    
          Range:   0 to 2
    
          Default: 0
    

  <b><i><u>Output Data:</u></i></b>
    None

  <b><i><u>Revision History:</u></i></b>
<a name="ENTER_BATCH_FILE_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="ENTER_SERVO_MATLAB_SHELL_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Enter Servo Matlab Shell"></a><hr align=left width="75%"><b> Enter Servo Matlab Shell (Level 5 'S')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command enters servo matlab shell and never returns. It also spins down the drive
    first before entering the servo matlab shell.

  <b><i><u>Quick Help:</u></i></b>
<a name="ENTER_SERVO_MATLAB_SHELL_QUICK_HELP"></a>
    "EnterServoMatlabShell, S";

  <b><i><u>Input Parameters:</u></i></b>
    None

  <b><i><u>Output Data:</u></i></b>
    None

  <b><i><u>Revision History:</u></i></b>
<a name="ENTER_SERVO_MATLAB_SHELL_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="ERASE_SEACOS_DATA_AND_CODE_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Erase Seacos Data And Code"></a><hr align=left width="75%"><b> Erase Seacos Data And Code (Level T 'Z')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command performs various functions associated with Seacos.  This function will
    overwrite the Seacos overlay, Seacos security sector, ConGen, disk code and serial
    flash.

  <b><i><u>Input Parameters:</u></i></b>
<a name="ERASE_SEACOS_DATA_AND_CODE_CMD_PARAM"></a>
    0 - Minimal erase level
        "0" to erase serial flash and reboot to mask ROM code     Not supported yet
        "1" to erase Appcode             Not supported yet
        "2" to erase Cert                Not supported yet
        "3" to erase Cert Table          Not supported yet
        "4" to erase AT Overlays
        "5" to erase Congen              Not supported yet
        "6" to erase Security
        "7" to erase Seasos
    
          Type:    Unsigned 8-bit value
    
          Range:   0 to 0xFF
    
          Default: None
    
    1 - Erase mode
         
        This parameter specifies the following options:
    
        "1" means to erase the level the first param specify.
    
        "0" means to erase from 7th level to the minimal level the first param specify.
    
          Type:    Unsigned 8-bit value
    
          Range:   0 to 0xFF
    
          Default: None
    
    2 - Valid Command Key.
        this parameter must be equal to 22 Hex.  If this parameter is not equal to 22 Hex,
        the command will not be executed.
    
          Type:    Unsigned 8-bit value
    
          Range:   0 to 0xFF
    
          Default: None
    

  <b><i><u>Output Data:</u></i></b>
<a name="SEACOS_OP_STATUS"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
        If no error occurred, one of the following messages will be output to indicate the
        status of the Seacos operation performed.
    
           "Resetting"
           "Erased Seacos"
           "Erased Security"
           "ConGen, not supported"
           "Cert, not supported"
           "Cert Table, not supported"
           "Erased AT Overlays"
           "AppCode, not supported"
           "SFlash, not supported"
           "Invalid level"
           "Request dummy file failed"
           "Open SIM file failed"
           "Write SIM file failed"
           "Erase Overlay failed"
    

  <b><i><u>Revision History:</u></i></b>
<a name="ERASE_SEACOS_DATA_AND_CODE_REVISION_HISTORY"></a>
    0001.0000   Initial revision.

<a name="ERASE_TRACK_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Erase Track"></a><hr align=left width="75%"><b> Erase Track (Level 7 'b')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command erases the target track and the specified number of tracks on each side
    of the target track.

  <b><i><u>Quick Help:</u></i></b>
<a name="ERASE_TRACK_QUICK_HELP"></a>
    "EraseTrk, b[AdjacentTrkCnt],[EraseCntPerTrk],[AcEraseOpt]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="ERASE_TRACK_PARM"></a>
    0 - Adjacent Tracks to Erase.
    
        This parameter specifies the number of adjacent tacks on each side of the target
        track to be erased.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: 0
    
    1 - Erase Count per Track.
    
        This parameter specifies the number of times each track should be erased.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: 1
    
    2 - AC Erase Option.
    
        If any value is entered for this parameter, an AC erase will be performed, else a
        DC erase is performed.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: None
    

  <b><i><u>Output Data:</u></i></b>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    

  <b><i><u>Revision History:</u></i></b>
<a name="ERASE_TRACK_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="FAST_MSESER_MEASUREMENT_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Fast MSESER Measurement"></a><hr align=left width="75%"><b> Fast MSESER Measurement (Level E 'm')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command collects hardware data while reading sector data from the disk.
    Statistic analysis will be conducted for collected hardware data and results
    will be displayed.

  <b><i><u>Quick Help:</u></i></b>
<a name="FAST_MSESER_MEASUREMENT_QUICK_HELP"></a>
    "FastMseserMeasurement, m[]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="FAST_MSESER_MEASUREMENT_PARM"></a>
     0 - Start Sector.
    
         This parameter specifies the sector on which to start the read.
    <font color=red>
         When 0xFFFF, it means zero latency read.
    </font>
    
           Type:    Unsigned 16-bit value
    
           Range:   0 to max sector number on track
    
           Default: 0
    
     1 - Number of Sectors to Read.
    
         This parameter specifies the number of sectors to read.
         When 0, it means the whole track.
    
           Type:    Unsigned 16-bit value
    
           Range:   0 to total number of sectors per track
    
           Default: 0
    
     2 - Data Collection Options.
    
         This parameter is a bit-significant value that allows the user to control
         the data to be collected.
    
           Bit 15-3:   Reserved
    
           Bit 1:      If this bit is set, will collect MSE, VGAR, and a controller register.
                       Higher priority than bit 0
    
           Bit 0:      If this bit is set, will collect MSE, VGAR, and a channel register.
    
           Type:    Unsigned 16-bit value
    
           Range:   0 to 0xFFFF
    
           Default: 0 ( MSE, VGAR, and rotate through all FIR Taps and NLFR registers )
    
     3 - Register Address
    
         This parameter specifies the address of the register to read, when
         bit 1 or 0 of Parameter 2 is set.  If bit 1 is set, the entire 32-bit
         value is used to address a controller register.  If bit 0 is set, the
         lower 16-bit is used to address a Read Channel register.
    
           Type:    Unsigned 32-bit value
    
           Range:   0 to 0xFFFFFFFF
    
           Default: 0
    
     4 - Register Bit Mask
    
         This parameter specifies the bit mask that will be bit-AND'ed with
         data read from the register specified by parameter 3.
    
           Type:    Unsigned 16-bit value
    
           Range:   0 to 0xFFFF
    
           Default: 0xFFFF (all bits valid)
    
     5 - Sectors to Ingore.
    
         This parameter specifies the number of beginning sectors to ignore
         during statistic calculation.
    
           Type:    Unsigned 16-bit value
    
           Range:   0 to Number of Sectors to Read
    
           Default: 0
    
     6 - Percentage to trim.
    
         This parameter specifies the percent trimming to apply to the data at
         both low and high ends.
    
           Type:    Unsigned 8-bit value
    
           Range:   0 to 32h
    
           Default: 0
    
     7 - Display Options.
    
         This parameter is a bit-significant value that allows the user to control
         the level of output detail.
    
           Bit 15-2:   Reserved
    
           Bit 1:      If this bit is set, will display the statistical results
                       of the measured values in Decimal format.
    
           Bit 0:      If this bit is set, will display the raw data of the
                       measured values in Hex format
    
           Type:    Unsigned 16-bit value
    
           Range:   0 to 0xFFFF
    
           Default: 0xFFFF ( display everything )
    

  <b><i><u>Output Data:</u></i></b>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
<a name="RW_OP_STATUS_OUTPUT_DATA"></a>
        If an error occurred, the following information will be displayed.
    
              "DiagError aaaaaaaa R/W Status c R/W Error dddddddd"
    
           and
    
              "Next User LBA eeeeeeee LLL CHS ffffff.g.hhhh PLP CHS iiiiii.j.kkkk"
              "Remaining Transfer Length llllllll"
    
           or
    
              "Next System LBA eeeeeeee LLL CHS ffffff.g.hhhh PLP CHS iiiiii.j.kkkk"
              "Remaining Transfer Length llllllll"
    
           where
    
              aaaaaaaa is the Diagnostic Error Code
    
              c is the status returned by the R/W subsystem
    
                    0 = R/W request completed successfully with error recovery
                    1 = R/W request completed successfully (no error recovery performed)
                    2 = R/W request failed
    
              dddddddd is the error code returned by the R/W subsystem
    
              eeeeeeee is the Disk Logical Block Address of the sector in error
    
              ffffff is the Logical Cylinder Address of the sector in error
    
              g is the Logical Head Address of the sector in error
    
              hhhh is the Logical Sector Address of the sector in error
    
              iiiiii is the Physical Cylinder Address of the sector in error
    
              j is the Logical Head Address of the sector in error
    
              kkkk is the Physical Sector Address of the sector in error
    
              llllllll is the number of sectors remaining to be read or written
    
        If the Verbose Formatted ASCII Data Output Mode is selected, the Verbose Mode option
        bits will enable the following data to be output when set.
    
           Bit 0:      Enables the R/W Status and R/W Error to be displayed
           Bit 1:      Enable the Next Address to be displayed
           Bit 2:      Enables the Track Position and Track Follow Offset to be displayed
           Bit 3:      Enables the Target Address to be displayed
           Bit 4:      Enables the Recovery Status to be displayed
           Bit 5:      Enables the Fault Status to be displayed
           Bit 6:      Enables the Elapsed Time to be displayed
           Bits 31-7:  NA
    
        If Bit 0 is set, the R/W Status and R/W Error will be displayed even if no error
        occurred.  The data displayed will be formatted as shown above.
    
        If Bit 1 is set, the Next Address will be displayed even if no error occurred.  The
        data displayed will be formatted as shown above.
    
        If Bit 2 is set, the Track Position and Track Follow Offset will be displayed as
        follows.
    
              "Read Position, Persistent Offset m.m% Total Offset n.n%"          or
              "Write Position, Persistent Offset m.m% Total Offset n.n%"         or
              "Write Header Position, Persistent Offset m.m% Total Offset n.n%"
    
           where
    
              m.m is the Persistent Track Follow Offset in units of percentage of track width
    
              n.n is the Total Track Follow Offset in units of percentage of track width
    
        If Bit 3 is set, the Target Address will be displayed as follows.
    
              "Target User LBA pppppppp LLL CHS qqqqqq.r.ssss PLP CHS tttttt.u.vvvv"
              "Starting Transfer Length wwwwwwww"
    
           or
    
              "Target System LBA pppppppp LLL CHS qqqqqq.r.ssss PLP CHS tttttt.u.vvvv"
              "Starting Transfer Length wwwwwwww"
    
           where
    
              pppppppp is the starting Disk Logical Block Address
    
              qqqqqq is the starting Logical Cylinder Address
    
              r is the starting Logical Head Address
    
              ssss is the starting Logical Sector Address
    
              tttttt is the starting Physical Cylinder Address
    
              u is the starting Logical Head Address
    
              vvvv is the starting Physical Sector Address
    
              wwwwwwww is the starting Transfer Length
    
        If Bit 4 is set, the Recovery Status will be displayed as follows.
    
              "Recovered User LBA AAAAAAAA LLL CHS BBBBBB.C.DDDD PLP CHS EEEEEE.F.GGGG"
              "Recovery Flags HHHH Count II"
    
           or
    
              "Recovered System LBA AAAAAAAA LLL CHS BBBBBB.C.DDDD PLP CHS EEEEEE.F.GGGG"
              "Recovery Flags HHHH Count II"
    
           where
    
              AAAAAAAA is the Disk Logical Block Address of the last recovered sector
    
              BBBBBB is the Logical Cylinder Address of the last recovered sector
    
              C is the Logical Head Address of the last recovered sector
    
              DDDD is the Logical Sector Address of the last recovered sector
    
              EEEEEE is the Physical Cylinder Address of the last recovered sector
    
              F is the Logical Head Address of the last recovered sector
    
              GGGG is the Physical Sector Address of the last recovered sector
    
              HHHH are the Recovery Flags reported by the Read/Write code
    
              II is the Recovery Count reported by the Read/Write code
    
        If Bit 5 is set, the Fault Status will be displayed as follows.
    
              "Drive Fault Status JJJJ Preamp Fault Status KKKK"
    
           where
    
              JJJJ is the Drive Fault Status reported by the Read/Write code
    
              KKKK is the Preamp Fault Status reported by the Read/Write code
    
        If Bit 6 is set, the Elapsed Time for the read/write operation will be displayed.
<a name="ELAPSED_TIME"></a>
    
       "Elapsed Time a mins b secs"  or
       "Elapsed Time b.c secs"       or
       "Elapsed Time c.d msecs"
    
    where
    
       a is minutes
       b is seconds
       c is milliseconds
       d is microseconds
    
    

  <b><i><u>Examples:</u></i></b>
    There are prerequisites for issuing this diag command.
    First, user should issue a diag command to set the next target location to where the
    Fast MSE measurement should occur. A simple seek command would do the job.
    Second, user should issue a Set Track Format (Level 7 'K') command to set the track
    format to single-sector-per-wedge format.
    Typical example of usage is like following.

    F3 T>A0           (Select User Area and not to update cylinder and head)
    F3 T>/7           (Change diagnostic command level to 7)
    F3 7>S1000,0      (Seek to the target track)
    F3 7>K2           (Set track format to single sector per wedge format)
    F3 7>W,,,1        (Write the track with physical sector address flag on)
    F3 7>/E           (Change diagnostic command level to E)
    F3 E>m            (issue the Fast MSESER Measurement command)

  <b><i><u>Revision History:</u></i></b>
<a name="FAST_MSESER_MEASUREMENT_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="FILL_CORRECTION_BUFFER_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Fill Correction Buffer"></a><hr align=left width="75%"><b> Fill Correction Buffer (Level G 'B')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command fills the specified segment of Correction Buffer with the specified data
    pattern. If the verification of fill is enabled, the command reads the data back and
    compares with the patten it writes.

  <b><i><u>Quick Help:</u></i></b>
<a name="FILL_CORRECTION_BUFFER_QUICK_HELP"></a>
    "FillCorrectionBuffer, B[StartAddr],[EndAddr],[Pattern],[Opts]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="FILL_CORRECTION_BUFFER_PARM"></a>
    0 - Start Address Offset of Correction Buffer.
    
        This parameter specifies the start address offset of the correction buffer.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xffff,
    
          Default: 0
    
    1 - End Address Offset of Correction Buffer.
    
        This parameter specifies the end address offset of the correction buffer.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xffff
    
          Default: 0
    
    2 - Data Pattern.
    
        This parameter specifies the fill pattern specified. The specified pattern
        is assumed to be right justified. If the value of the patten is greater
        than 0x03FF, the command will take the lower 10 bits of the address as its
        pattern to write in the Correction Buffer instead of the input pattern.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0x03ff
    
          Default: 0
    
    3 - Options.
    
        This parameter is a bit-significant value that selects the following options.
    
          Bits 15-1:  not used
    
          Bit 0:      Verify the patten written to the correction buffer.
    
                      If this bit is cleared, the patten is written into the correction
                      buffer without the verification of reading back and comparing
                      with the written patten.
    
                      If this bit is set, the patten is written into the correction
                      buffer followed by the verification of reading back and comparing
                      with the written patten.
    
          Type:    Unsigned 8-bit value
    
          Range:   0 to 0xff
    
          Default: 0
    

  <b><i><u>Output Data:</u></i></b>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    

  <b><i><u>Revision History:</u></i></b>
<a name="FILL_CORRECTION_BUFFER_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="FILL_SUPER_PARITY_RAM_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Fill Super Parity RAM"></a><hr align=left width="75%"><b> Fill Super Parity RAM (Level G 'F')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command fills the specified segment of the Super Parity RAM with the specified
    data pattern.

  <b><i><u>Quick Help:</u></i></b>
<a name="FILL_SUPER_PARITY_RAM_QUICK_HELP"></a>
    "FillSuperParityRam, F[StartAddr],[EndAddr],[Pattern]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="FILL_SUPER_PARITY_RAM_PARM"></a>
    0 - Start Address Offset of Super Parity RAM.
    
        This parameter specifies the start address offset of the super parity RAM.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xffff,
    
          Default: 0
    
    1 - End Address Offset of Super Parity RAM.
    
        This parameter specifies the end address offset of the super parity RAM.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xffff
    
          Default: 0
    
    2 - Data Pattern.
    
        This parameter specifies the fill pattern. The specified pattern is assumed
        to be right justified. If the value of the input pattern is 0x0FFF, the Write
        Super Parity RAM diagnostics will set the pattern to 0 to start the write.
        After each writing to the even address location, the value of the pattern
        will be incremented for the next even address location. If the pattern
        reaches the value of 0x0FFF, the pattern will be wrapped back to 0 for the
        next write.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0x0fff
    
          Default: 0
    

  <b><i><u>Output Data:</u></i></b>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    

  <b><i><u>Revision History:</u></i></b>
<a name="FILL_SUPER_PARITY_RAM_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="FINE_RW_OFFSET_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Fine RW Offset Measurement"></a><hr align=left width="75%"><b> Fine RW Offset Measurement (Level E 'o')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command measures the Fine Reader/Writer Offset at the current track.
    The algorithm used here to measure the offset, a.k.a. micro-jog or MR offset,
    was basically ported from ST-10 code. Please see Pete Harllee for more detail about it.
 
    The algorithm used here can be divided into two big steps.
 
    The first step is to find a legitimate coarse MSE tub.
    Since the real offset is unknown, conventional method to find the tub is to sweep certain
    ranges of the offset with coarse offset increment. The range must be wide enough to cover
    the worst(biggest) ever heads and the increment must be narrow enough not to miss the tub.
    Because of this dilemma, finding the coase rw offset can be a very time consuming process.
    
    However, the alogorithm used here uses a different approach to find the coarse tub.
    Assuming the real offset should be fairly close to the current default, it scans one
    direction from the current default with a coarse increment of the offset. It then repeats
    the same process, alternating the direction, until a valid tub is found. If three
    measurements with finding good sync marks at more than half number of wedges in a track,
    it's regarded as having found a valid tub. This method is very fast especially if the
    real offset is close to the current default because the code would find the coarse tub
    after even a few measurements.
 
    The second step is to find the fine rw offset.
    The conventional method for doing this is to scan small range, for example, one track,
    with a fine, in many cases, the smallest possible, offset increments. This is also a time
    consuming process because the increment is very small even though the range is fairly
    small.
 
    The algorithm used here does this job differently from the conventional method.
    Once the coarse tub is found, the code tried to balance two sides of the tub since it's
    assumed that the MSE tub is bowl shaped and it is. If the code finds it's at the left
    side of the tub, it'll move to right direction and vice versa. When the code changes the
    scanning direction, it reduces the increment. If the increment becomes to zero or the MSE
    curve is so well balanced at both ends, the code calculates the fine rw offset that gives
    the same off-track margin(read capability) at both sides.

  <b><i><u>Quick Help:</u></i></b>
<a name="FINE_RW_OFFSET_QUICK_HELP"></a>
    "FineRwOffset, o[NumAvgs],[TrkStepSize],[NumGuardTrks]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="FINE_RW_OFFSET_PARM"></a>
    0 - Number of averages.
    
        This parameter specifies the number of target tracks to measure fine rw offset then
        average the measurement results to filter out any possible outliers.
    
          Type:    Unsigned 16-bit value
    
          Range:   1 to 0xFFFF
    
          Default: 5
    
    1 - Track step size.
    
        This parameter specifies the number of tracks between the sample tracks where
        the measurements occur.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: 4
    
    2 - Number of guard tracks.
    
        This parameter specifies the number of guard tracks at each side, ID and OD, of the
        sample tracks. These areas will be erased.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: 10
    

  <b><i><u>Output Data:</u></i></b>
<a name="FINE_RW_OFFSET"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
        If no error occurred, following information will be displayed.
    
        "Cyl/Hd cccccc/d OffsetPerTrk: eeeee OffsetDelta: fffff(sh.iiiEsj)"
     
        where
     
        cccccc is the physical cylinder number where the fine RW Offset measurement occurred
        d is the logical head number where the fine RW Offset measurement occurred
        eeeee is the RW Offset amount value for a data track at the target track
        ffffff is the measured RW offset difference(delta) from the current default offset
        sh.iiiEsj is the floating point value for the RW offset delta value, in percentage,
                  over the Offset amount value for a data track
     

  <b><i><u>Revision History:</u></i></b>
<a name="FINE_RW_OFFSET_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="FIRMWARE_RESET_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Firmware Reset"></a><hr align=left width="75%"><b> Firmware Reset (Online Control C)</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command spins down the drive, delays 5 seconds and jumps to the Power On Reset
    function.  A Control Z command will be required to enable the Diagnostic Mode commands
    following the completion of the reset.

  <b><i><u>Quick Help:</u></i></b>
<a name="FIRMWARE_RESET_DRIVE_QUICK_HELP"></a>
    "FirmwareReset";

  <b><i><u>Input Parameters:</u></i></b>
    None

  <b><i><u>Output Data:</u></i></b>
    The following string will be output to indicate that the drive is in the process
    of spinning down.

          "Spinning Down"

    When the spin down is complete, the following information will be displayed.

          "Spin Down Complete"
<a name="ELAPSED_TIME"></a>
    
       "Elapsed Time a mins b secs"  or
       "Elapsed Time b.c secs"       or
       "Elapsed Time c.d msecs"
    
    where
    
       a is minutes
       b is seconds
       c is milliseconds
       d is microseconds
    
    When delaying following spin down, the following string will be displayed.

          "Delaying eeee msec"

       where

          eeee is the length of the delay in milliseconds

    After the delay is complete, the following string will be output to indicate that
    the reset is being performed.

          "Jumping to Power On Reset"

  <b><i><u>Revision History:</u></i></b>
<a name="FIRMWARE_RESET_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="FORMAT_PARTITION_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Format Partition"></a><hr align=left width="75%"><b> Format Partition (Level T 'm')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command formats the specified partition.

  <b><i><u>Quick Help:</u></i></b>
<a name="FORMAT_PARTITION_QUICK_HELP"></a>
    "FormatPartition, m[Partition],[FormatOpts],[DefectListOpts],[MaxWrRetryCnt],[MaxRdRetryCnt],\n\r"
    "[MaxEccTLevel],[MaxCertifyTrkRewrites],[ValidKey],[DataPattern]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="FORMAT_PARTITION_PARM"></a>
    0 - Partition Number.
    
        This parameter specifies the media partition to be formatted.
    
             0 = User Partition
             1 = System Partition
    
          Type:    Unsigned 8-bit value
    
          Range:   0 or 1
    
          Default: 0
    
    1 - Format Options.
    
        This parameter is a bit significant value that selects the following options:
    
            Bits 31-6: not used
    
            Bit 5: Enable SeaCOS XF Space Format.
    
                   This bit is only valid when the User Partition is selected.  If this
                   bit is equal to 1, the the Format Partition command will only format
                   SeaCOS Extended File (XF) space.
                   NOTE: This feature can be enabled or disabled at compile-time.  Use
                   the quick help to determine whether your code supports this feature.
    
            Bit 4: Enable Zone Re-format Skipping.
    
                   If this bit is equal to 1, then the Format Partition command will
                   enable the zone re-format skipping mode during the format operation.
                   With this mode enabled, the format operation will not re-format
                   a zone if grown defects were found in the zone.
                   NOTE: This feature can be enabled or disabled at compile-time.  Use
                   the quick help to determine whether your code supports this feature.
    
            Bit 3: Enable Event-based Format Logging.
    
                   If this bit is equal to 1, then the Format Partition command will
                   display information about error events that occur during the format
                   operation.  This information will be displayed as interim status as
                   these events occur.
                   NOTE: This feature can be enabled or disabled at compile-time.  Use
                   the quick help to determine whether your code supports this feature.
    
            Bit 2: Disable User Partition Certify.
    
                   This bit is only valid when the User Partition is selected.  If this
                   bit is equal to 1, media certification and defect deallocation will
                   be disabled.
    
            Bit 1: Disable User Partition Format.
    
                   This bit is only valid when the User Partition is selected.  If this
                   bit is equal to 1, the User Partition sectors will not be written
                   with a constant data pattern.
    
            Bit 0: Corrupt User Partition Primary Defects.
    
                   This bit is only valid when the User Partition is selected.  If this
                   bit is equal to 1, the primary defective sectors will be corrupted.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 or 0xFFFFFFFF
    
          Default: 0 (Enable User partition Certify,
                      Enable User Partition Format,
                      Don't Corrupt Primary Defects)
    
    2 - Defect List Options.
    
        This parameter is a bit significant value that selects the following options:
    
            Bits 31-3: not used
    
            Bit 2: Process the Active Error Log.
    
                   This bit is only valid when the User Partition is selected.  If this
                   bit is equal to 1, the Format Client Defect List will be written with
                   contents of the Active Error Log and the option to process the Client
                   Defect List will be enabled.  If there is no Active Error Log or there
                   are no R/W-related entries in the Active Error Log, then this bit will
                   be ignored.
    
            Bit 1: Process Primary Defect Lists.
    
                   This bit is only valid when the User Partition is selected.  If this
                   bit is equal to 1, the the Primary Defect Lists will be used when
                   creating the defect list to be used by the format operation.
    
            Bit 0: Process Grown Defect Lists.
    
                   This bit is only valid when the User Partition is selected.  If this
                   bit is equal to 1, the the Grown Defect Lists will be used when
                   creating the defect list to be used by the format operation.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 or 0xFFFFFFFF
    
          Default: 0x00000003 (Process Grown Defect Lists,
                               Process Primary Defect Lists,
                               Do not process the Active Error Log)
    
    3 - Maximum Write Retry Count.
    
        If this parameter is entered, the maximum write retry count will be set to the
        specified value.  This parameter is only valid when the User Partition is being
        formatted (Parameter 0 is equal to 0).  If this parameter is not entered, the
        maximum write retry count will not be changed.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 or 0xFFFF
    
          Default: None.
    
    4 - Maximum Read Retry Count.
    
        If this paremeter is entered, the maximum read retry count will be set to the
        specified value.  This parameter is only valid when the User Partition is being
        formatted (Parameter 0 is equal to 0).  If this parameter is not entered, the
        maximum read retry count will not be changed.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 or 0xFFFF
    
          Default: None.
    
    5 - Maximum ECC T-Level.
    
        If this paremeter is entered, the maximum ECC T-Level will be set to the specified
        value.  This parameter is only valid when the User Partition is being formatted
        (Parameter 0 is equal to 0).  If this parameter is not entered, the ECC T-Level
        will not be changed.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 or 0xFFFF
    
          Default: None.
    
    6 - Track Rewrite During Certify Retry Threshold.
    
        If this parameter is entered, it specifies the maximum number of rewrite retries
        to be performed during the user partition certification pass.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 or 0xFFFF
    
          Default: None.  If this parameter is not entered, the default value recommended
                   by the R/W Firmware will be used.
    
    7 - Valid Command Key.
    
        For a User Partition format, this parameter must be equal to 22 Hex.  If this
        parameter is not equal to 22 Hex, the command will not be executed.
    
        For a System Partition format, this parameter must be equal to DD Hex.  If this
        parameter is not equal to DD Hex, the command will not be executed.
    
          Type:    Unsigned 8-bit value
    
          Range:   0x22 or 0xDD
    
          Default: None
    
    8 - Data Pattern For Format.
    
        This parameter specifies the data pattern to be used when formatting the specified
        partition.  If this parameter is not entered, the specified partition will be
        formatted with a 0x00000000 data pattern.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 or 0xFFFFFFFF
    
          Default: 0x00000000.
    

  <b><i><u>Output Data:</u></i></b>
<a name="FORMAT_PARTITION_DATA"></a>
    <GENERIC_ERROR>
    
        If the error occurred while processing the defect lists, the following additional
        information will be displayed.
    
           "Process Defect List Error"
           "R/W Sense cccccccc, R/W Error dddddddd, List Offset eeeeeeee, File Error ffffffff"
    
           where
    
              cccccccc is the sense status that was returned by the R/W subsystem
    
              dddddddd is the error code that was returned by the R/W subsystem
    
              eeeeeeee is the offset of the defect list entry at which the error occurred
    
              ffffffff is the error code that was returned by the system information manager (SIM)
    
        If the error occurred during the format operation, the following additional information
        will be displayed.
    
           "User Partition Format Failed - Elapsed Time c"
           "R/W Sense dddddddd, R/W Error eeeeeeee, File Error ffffffff"
           "Blk Addr gggggggg, Blk Addr Type hh, Cyl iiiiiiii, Hd jj";
    
           where
    
              c is the amount of time that has elapsed since the format operation was started
    
              dddddddd is the sense status that was returned by the R/W subsystem
    
              eeeeeeee is the error code that was returned by the R/W subsystem
    
              ffffffff is the error code that was returned by the system information manager (SIM)
    
              gggggggg is the R/W block address at which the error occurred
    
              hh is the R/W block address type at which the error occurred
    
              iiiiiiii is the R/W cylinder address at which the error occurred
    
              jj is the R/W head address at which the error occurred
    
        If no error occurred and the format operation is still in progress, the following
        information will be displayed.
    
           "Max Wr Retries = cc, Max Rd Retries = dd, Max ECC T-Level = ee, Max Certify Rewrite Retries = ffff"
           "User Partition Format  gg% complete, Zone hh, Pass ii, LBA jjjjjjjj, ErrCode kkkkkkkk, Elapsed Time l"
    
           where
    
              cc is the maximum write retry count to be used
    
              dd is the maximum read retry count to be used
    
              ee is the maximum ECC T-Level to be used
    
              ffff is the certify rewrite rety threshold
    
              gg is the percent of the format operation that has been completed
    
              hh is the data zone that is currently being formatted
    
              ii is the number of the current pass through the data zone
    
              jjjjjjjj is the last LBA that was formatted
    
              kkkkkkkk is the error code that was reported by the R/W subsystem
    
              l is the amount of time that has elapsed since the format operation was started
    
        If no error occurred, the format operation is still in progress, a format event occurs,
        and format event reporting is enabled, the following information will be displayed.
    
           "Event: Media Write Start, aaa Format, Zone bb, Start Blk cccccccc, Num Sectors dddddddd"
    
              or
    
           "Event: Write Xfer, Start Blk cccccccc, Len eeeeeeee, Next Blk ffffffff, Erc gggggggg, Stat hh"
    
              or
    
           "Event: Media Certify Start, New Format, Zone bb, Start Blk cccccccc, Num Sectors dddddddd"
    
              or
    
           "Event: Certify Xfer, Start Blk cccccccc, Len eeeeeeee, Next Blk ffffffff, Erc gggggggg, Stat hh"
    
              or
    
           "Event: Unrec Err, LBA iiiiiiii, PBA jjjjjjjj, Erc gggggggg, Trk llll, Hd mm, Sctr nn, Wdg oo, ZnGrp pp, Zn qq, DOS: rr/ss/tt"
           "Event: Unrec Err, LBA iiiiiiii, PBA jjjjjjjj, Erc gggggggg, Trk llll, Hd mm, Sctr nn, Wdg oo, Zn qq, DOS: rr/ss/tt"
           "Event: Unrec Err, LBA iiiiiiii, PBA jjjjjjjj, Erc gggggggg, Trk llll, Hd mm, Sctr nn, Wdg oo, ZnGrp pp, Zn qq"
           "Event: Unrec Err, LBA iiiiiiii, PBA jjjjjjjj, Erc gggggggg, Trk llll, Hd mm, Sctr nn, Wdg oo, Zn qq"
    
            NOTES: ZnGrp information is only available on drives supporting VBAR
                   DOS information is only available on drives supporting Directed Offline Scan
    
              or
    
           "Event: Cert Trk Rewrite, Retry Blk kkkkkkkk, Len eeeeeeee, Next Blk ffffffff, Erc gggggggg, Stat hh"
    
              or
    
           "Event: Cert Trk Rewrite Cntr Update, Cnt 0001"
    
           where
    
              aaa indicates whether this is a "New Format" or a "Reformat"
    
              bb is the zone
    
              cccccccc is the starting block
    
              dddddddd is the number of blocks to be formatted
    
              eeeeeeee is the length of the transfer
    
              ffffffff is the next starting block
    
              gggggggg is the error code that was reported by the R/W subsystem
    
              hh is the read/write status
    
              iiiiiiii is the logical block address (LBA)
    
              jjjjjjjj is the physical block address (PBA)
    
              kkkkkkkk is the block which causes the rewrite retry
    
              llll is the track on which the error occurred
    
              mm is the head on which the error occurred
    
              nn is the sector on which the error occurred
    
              oo is the wedge on which the error occurred
    
              pp is the zone group in which the error occurred
    
              qq is the zone in which the error occurred
    
              rr is the DOS scan unit associated with the error
    
              ss is the DOS relative cylinder in scan unit associated with the error
    
              tt is the DOS surface cylinder unit associated with the error
    
        If no error occurred and the format operation has successfully completed, the following
        information will be displayed.
    
           " User Partition Format Successful - Elapsed Time m"
    
           where
    
              m is the amount of time that has elapsed since the format operation was started
    
           If at least one zone re-format was skipped then the following will also be
           displayed upon successful completion of the format:
    
           "Zone re-format was skipped."
    

  <b><i><u>Examples:</u></i></b>

    Example #1:
    Perform a "quick format" (process defect lists, clear format corrupt, do not write
    or certify the drive)

       F3 T>m0,6,,,,,,22

    Example #2:
    Perform a "quick format" (don't process defect lists i.e. unslip and unalt, do not
    write or certify the drive)

       F3 T>m0,6,0,,,,,22

    Example #3:
    Perform a format with the default data pattern 0x00000000 and certify with event
    reporting enabled:

       F3 T>m0,8,,,,,,22

    Example #4:
    Perform a format and certify with event reporting enabled, set max write retries
    to 16, set max read retry count to 8, max ECC T-Level to 0, and track rewrite
    during certify retry threshold to 20:

       F3 T>m0,8,,10,8,0,14,22

    Example #5:
    Perform a format with user input data pattern 0xFFFFFFFF and certify with event
    reporting enabled:

       F3 T>m0,8,,,,,,22,ffffffff

  <b><i><u>Revision History:</u></i></b>
<a name="FORMAT_PARTITION_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0001.000X   Added ability to enable and display event-based output.
    0011.000X   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).
    0012.000X   Added additional parameter 8 for users to input data pattern for format. The
                default data pattern is 0x00000000 instead of the 0x77777777 for the User
                Partition and 0xFFFFFFFF for the System Partition.
    0012.001X   Added option to process the Active Error Log.
    
    Note on Minor Rev:
    ----.ZZZX   ZZZ represents the minor rev base value.
                X represents set of conditional feature flags.
                  - If bit 0 of X is set, then the ability to enable and display
                    event-based output is supported.
                  - If bit 1 of X is set, then the ability to enable zone re-format
                    skipping and output command result information if at least one
                    zone re-format was skipped is supported.
                  - If bit 2 of X is set, then the ability to format only SeaCOS
                    Extended File (XF) space is supported.
                  - (Bit 3 of X is reserved for future conditional features.)

<a name="GENERIC_RW_REQUEST_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Generic Read/Write Request"></a><hr align=left width="75%"><b> Generic Read/Write Request (Level 1 'G' and Level 7 'i')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    The Generic Read/Write Request commmand provides a pass through to the Read/Write
    subsystem.  The command parameters are passed to the Read/Write subsystem without
    being interpreted.

  <b><i><u>Quick Help:</u></i></b>
<a name="GENERIC_RW_REQUEST_QUICK_HELP"></a>
       Level 1
    "GenericRwRequest, G[Parm0],[Parm1],[Parm2],...[Parm9]";
       Level 7
    "GenericRwRequest, i[Parm0],[Parm1],[Parm2],...[Parm9]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="GENERIC_RW_REQUEST_PARM"></a>
    0 - Generic Read/Write Request Parameter 0.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xffffffff
    
          Default: 0
    
    1 - Generic Read/Write Request Parameter 1.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xffffffff
    
          Default: 0
    
    2 - Generic Read/Write Request Parameter 2.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xffffffff
    
          Default: 0
    
    3 - Generic Read/Write Request Parameter 3.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xffffffff
    
          Default: 0
    
    4 - Generic Read/Write Request Parameter 4.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xffffffff
    
          Default: 0
    
    5 - Generic Read/Write Request Parameter 5.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xffffffff
    
          Default: 0
    
    6 - Generic Read/Write Request Parameter 6.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xffffffff
    
          Default: 0
    
    7 - Generic Read/Write Request Parameter 7.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xffffffff
    
          Default: 0
    
    8 - Generic Read/Write Request Parameter 8.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xffffffff
    
          Default: 0
    
    9 - Generic Read/Write Request Parameter 9.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xffffffff
    
          Default: 0
    

  <b><i><u>Output Data:</u></i></b>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    

  <b><i><u>Revision History:</u></i></b>
<a name="GENERIC_RW_REQUEST_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="GENERIC_SERVO_COMMAND_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Generic Servo Command"></a><hr align=left width="75%"><b> Generic Servo Command (Level 5 'C')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    The Generic Servo command executes the servo command user specified and displays all
    result data returned by Servo, which includes Servo Command Status, Servo Diagnostic Reg,
    and Servo Data Response. Please note that it is the user's responsibility to enter the
    correct internal servo command number and the parameters associated with this servo
    command. This command itself does not verify the command number and parameters. It simply
    accepts what user entered and then passes them to the servo code.

  <b><i><u>Quick Help:</u></i></b>
<a name="GENERIC_SERVO_COMMAND_QUICK_HELP"></a>
    "GenericServoCmd, C[CmdNum],[Parm1],...[Parm7]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="GENERIC_SERVO_COMMAND_PARM"></a>
    0 - Internal Servo Command Number.
    
        This parameter specifies the internal servo command to be run.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: None
    
    1 - 1st parameter following the Internal Servo Command number.
    
        This parameter specifies the the 1st parameter following the Servo Command number.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: 0
    
    2 - 2nd parameter following the Internal Servo Command number.
    
        This parameter specifies the the 2nd parameter following the Servo Command number.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: 0
    
    3 - 3rd parameter following the Internal Servo Command number.
    
        This parameter specifies the the 3rd parameter following the Servo Command number.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: 0
    
    4 - 4th parameter following the Internal Servo Command number.
    
        This parameter specifies the the 4th parameter following the Servo Command number.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: 0
    
    5 - 5th parameter following the Internal Servo Command number.
    
        This parameter specifies the the 5th parameter following the Servo Command number.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: 0
    
    6 - 6th parameter following the Internal Servo Command number.
    
        This parameter specifies the the 6th parameter following the Servo Command number.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: 0
    
    7 - 7th parameter following the Internal Servo Command number.
    
        This parameter specifies the the 7th parameter following the Servo Command number.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: 0
    

  <b><i><u>Output Data:</u></i></b>
<a name="GENERIC_SERVO_COMMAND_DATA"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
        If no error occurred, the follwing information will be displayed.
    
              "Status aaaa, Diagnostic bbbb, Response cccc1 ccc2 ccc3 ccc4 ccc5 ccc6 ccc7 ccc8 ccc9 ccc10 ccc11 ccc12 ccc13 ccc14 ccc15 ccc16"
    
           where
    
              aaaa is the status of the command
    
              bbbb is the diagnostic register value of the command
    
              ccc1 - ccc16 is the servo data response values of the command
    

  <b><i><u>Revision History:</u></i></b>
<a name="GENERIC_SERVO_COMMAND_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="GET_THERMISTOR_TEMPERATURE_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Get Thermistor Temperature"></a><hr align=left width="75%"><b> Get Thermistor Temperature (Online Control B)</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command get the thermistor temperature of the drive.

  <b><i><u>Quick Help:</u></i></b>
<a name="GET_THERMISTOR_TEMPERATURE_QUICK_HELP"></a>
    "GetThermistorTemperature";

  <b><i><u>Input Parameters:</u></i></b>
    None

  <b><i><u>Output Data:</u></i></b>
<a name="DEVICE_TEMPERATURE_OUTPUT_DATA"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
        If no error occurred and the Preamp temperature was returned, the following message
        will be displayed.
    
              "Preamp temp cccc, CCd"
    
           where
    
              cccc is the temperature value obtained from preamp (hexadecimal)
                CC is the temperature value obtained from preamp (decimal)
     
        If no error occurred and the Thermistor temperature was returned, the following
        message will be displayed.
    
              "Ref voltage dddd Thermistor voltage eeee Thermistor temp in degrees C ffff, FFd"
    
           where
    
              dddd is the A to D Reference Voltage
    
              eeee is the Thermistor Voltage
    
              ffff is the Thermistor Temperature in degrees Celsius (hexadecimal)
                FF is the Thermistor Temperature in degrees Celsius (decimal)
    

  <b><i><u>Revision History:</u></i></b>
<a name="GET_THERMISTOR_TEMPERATURE_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).
    0012.0000   Added Temperature in degrees Celsius (decimal) to output.

<a name="GOOP_PLOT_INFO_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Goop Plot"></a><hr align=left width="75%"><b> Goop Plot (Level C 'T')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This function runs a goop plot.  It reads the specified tracks, putting each
    sector into a category based on the ECC correction required to read it:
       perfect
       not perfect but equal to or less than user specified threshold
       requires more correction than user specified threshold (includes sync errors and
          unreadable sectors)

  <b><i><u>Quick Help:</u></i></b>
<a name="GOOP_PLOT_INFO_QUICK_HELP"></a>
    "GoopPlot, T[Hd],[StartTrk],[EndTrk],[ECCLvl],[NoFrcSync],[SkipCnt]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="GOOP_PLOT_INFO_PARM"></a>
    0 - Head.
    
        If FF entered, test all heads
        If FE entered, test current head
    
    
          Type:    Unsigned 8-bit value
    
          Range:   0 to 0xFF
    
          Default: Current head
    
    1 - Starting Track
    
        This input indicates the first logical track to be tested.  0 means first track
        of drive.
    
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: Current track
    
    2 - Ending Track
    
        This input indicates the last logical track to be tested. 0 means last track
        of drive.
    
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: Starting Track
    
    3 - Correction level threshold
    
        This input indicates the T-level for the less than T versus greater than T split.
    
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to MaxECC
    
          Default: 2
    
    4 - Disable Force Sync
    
        If any value is input, Force Sync will NOT be used.
    
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: None
    
    5 - Skip Count
    
        This input indicates how many tracks are skipped between those tracks that are scanned.
    
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: 0
    

  <b><i><u>Output Data:</u></i></b>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
<a name="GOOP_PLOT_HEADER_DATA"></a>
    F3 C>T0,20,40,,,8
      Cyl Hd #Sec   T=0 0<T<=2    T>2
<a name="GOOP_PLOT_DATA"></a>
       20 0  1456d 1451d     4d     1d
       29 0  1456d 1452d     4d     0d
       32 0  1456d 1452d     3d     1d
       3B 0  1456d 1448d     8d     0d
    
    Note the 'd' indicating decimal values.
    F3 C>

  <b><i><u>Examples:</u></i></b>

    Example #1:
    To scan tracks 80 - 84 with correction threshold 6 on the current head:
      F3 C>T,80,84,6
        Cyl Hd #Sec    T=0 0<T<=6    T>6
         80 0  1456d    0d     1d  1455d
         81 0  1456d 1451d     5d     0d
         82 0  1456d 1454d     2d     0d
         83 0  1456d 1455d     1d     0d
         84 0  1456d 1450d     6d     0d

    Example #2:
    To scan every 4th track (that is, skipping three tracks) from C0 to D0 on head 0 with
    threshold 2 (default):

      F3 C>T0,c0,d0,,,3
        Cyl Hd #Sec    T=0 0<T<=2    T>2
         C0 0  1456d    0d     1d  1455d
         C4 0  1456d 1450d     6d     0d
         C8 0  1456d 1451d     5d     0d
         CC 0  1456d 1454d     2d     0d
         D0 0  1456d 1455d     1d     0d

  <b><i><u>Revision History:</u></i></b>
<a name="GOOP_PLOT_INFO_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0001.0001   Update code to properly handle tracks with no sectors.
    0002.0000   Make columns even, output cylinder in hex, add ability
                to skip tracks.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="HEAD_SMASH_TEST_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Head Smash Test"></a><hr align=left width="75%"><b> Head Smash Test (Level 8 'd')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command is used to perform head smash test towards OD or ID with given acceleration
    and deceleration currents / duration.

  <b><i><u>Quick Help:</u></i></b>
<a name="HEAD_SMASH_TEST_QUICK_HELP"></a>
    "HeadSmashTest, d[HeadDirection],[AccelerationDuration],[DecelerationDuration],[AccelerationCurrent],[DecelerationCurrent]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="HEAD_SMASH_TEST_INPUT_PARAMETER"></a>
    
    0 - Head Smashing Direction.
    
       This parameter specifies the direction the head is going to be smashed to. Only 0 or
       1 are valid input. The default value is 0 when not entered.
          0: Smash head towards OD
          1: Smash head towards ID
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 1
    
          Default: 0
    
    
    1 - Acceleration Duration.
    
       This parameter specifies the duration (in 0.1 ms uint) to be used for head
       acceleration. The default value is 10 ( = 10 * 0.1ms = 1ms) when not entered.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: 0Ah (10 Decimal)
    
    
    2 - Deceleration Duration.
    
       This parameter specifies the duration (in 0.1 ms uint) to be used for head
       deceleration. The default value is 10 ( = 10 * 0.1ms = 1ms) when not entered.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: 0Ah (10 Decimal)
    
    
    3 - Acceleration Current.
    
       This parameter specifies the current (in mA unit) to be used for head acceleration.
       The default value is 1000 ( = 1000mA = 1A) when not entered.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: 03E8h (1000 Decimal)
    
    
    4 - Deceleration Current.
    
       This parameter specifies the current (in mA unit) to be used for head deceleration.
       The default value is 0 when not entered.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: 0
    

  <b><i><u>Output Data:</u></i></b>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    

  <b><i><u>Examples:</u></i></b>

    Example #1:
    Smash head towards OD with acceleration duration 8 ms (= 50h * 0.1ms), deceleration
    duration 1.6 ms (= 10h * 0.1ms), acceleration current 32 mA (= 20h * 1mA), deceleration
    current 16 mA (= 10h * 1mA)

       F3 8>d,50,10,20,10

    Example #2:
    Smash head towards OD with acceleration duration 6.4 ms (= 40h * 0.1ms), deceleration
    duration as default (= 1 ms), acceleration current 48 mA (= 30h * 1mA), deceleration
    current as default (= 0 mA)

       F3 8>d0,40,,30

    Example #3:
    Smash head towards ID with acceleration duration as default (= 1 ms), deceleration
    duration 0.8 ms (= 8h * 0.1ms), acceleration current as default (= 1000 mA),
    deceleration current 32 mA (= 20h * 1mA)

       F3 8>d1,,8,,20

    Example #4:
    Smash head towards ID with acceleration duration as default (= 1 ms), deceleration
    duration as default (= 1 ms), acceleration current as default (= 1000 mA),
    deceleration current as default (= 0 mA)

       F3 8>d1

  <b><i><u>Revision History:</u></i></b>
<a name="HEAD_SMASH_TEST_REVISION_HISTORY"></a>
    0001.0000   Initial revision.

<a name="INCREMENT_RW_SCOPE_SYNC_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Increment Read/Write Scope Sync"></a><hr align=left width="75%"><b> Increment Read/Write Scope Sync (Online '>')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command increments the number of the Servo Wedge for which the Scope Sync Pulse
    will be generated.

  <b><i><u>Quick Help:</u></i></b>
<a name="INCREMENT_RW_SCOPE_SYNC_QUICK_HELP"></a>
    "IncRwScopeSync";

  <b><i><u>Input Parameters:</u></i></b>
    None

  <b><i><u>Output Data:</u></i></b>
<a name="SCOPE_SYNC_DATA"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
        If no error occurred, the following information will be displayed.
    
              "                  Burst cccc"
    
           where
    
              cccc is the current Scope Sync Wedge number
    

  <b><i><u>Revision History:</u></i></b>
<a name="INCREMENT_RW_SCOPE_SYNC_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="INIT_DEFECT_LIST_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Initialize Defect List"></a><hr align=left width="75%"><b> Initialize Defect List (Level T 'i')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command initializes the Defect List to contain no defects.

  <b><i><u>Quick Help:</u></i></b>
<a name="INIT_DEFECT_LIST_QUICK_HELP"></a>
    "InitDefectList, i[DefectListSelect],[SaveListOpt],[ValidKey]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="INIT_DEFECT_LIST_PARM"></a>
    0 - List Selection.
    
        This parameter is a bit significant value that specifies which defect lists
        are to be initialized.  Setting a bit indicates that the corresponding defect
        list is to be initialized.
    
             bits 31-3:  Reserved for possible use for additional lists
             bit 2:      User Alt List
             bit 1:      Reserved (ignored)
             bit 0:      User Slip List
    
          Type:    Unsigned 32-bit value
    
          Range:   1 or 4 or 5
    
          Default: None
    
    1 - Action
    
       0 - defects will be cleared in the current, volatile, copy of the defect
           list(s) in RAM , but lists won't be written to disk : modification is TEMPORARY .
       1 - modified ( cleared ) versions of defect lists will be written
           to disk : defects are PERMANENTLY cleared.
       2 - the defect list will be read from non-volatile memory, overwriting
           any changes in volatile memory.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 2
    
          Default: 0
    
    
    2 - Valid Command Key.
    
        This parameter must be equal to 22 Hex.  If this parameter is not equal to
        22 Hex, the command will not be executed.
    
          Type:    Unsigned 8-bit value
    
          Range:   0x22
    
          Default: None
    

  <b><i><u>Output Data:</u></i></b>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    

  <b><i><u>Examples:</u></i></b>

    Example #1:
    To initialize the slip list to zeros:
   
      T> i1,,22

    Example #2:
    To initialize the alt list to zeroes and save the zeroed list to disk:

      T> i4,1,22

    Example #3:
    To reread the alt list from disk:

      T> i4,2,22

  <b><i><u>Revision History:</u></i></b>
<a name="INIT_DEFECT_LIST_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0001.0001   Add ability to reload alt list.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="INIT_LOG_FILE_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Initialize Log File"></a><hr align=left width="75%"><b> Initialize Log File (Level L 'i')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command initializes the specified log file to be empty.

  <b><i><u>Quick Help:</u></i></b>
<a name="INIT_LOG_FILE_QUICK_HELP"></a>
    "InitLogFile, i[Log]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="INIT_LOG_FILE_PARM"></a>
    0 - Log Number.
    
        This parameter specifies the number of the log to be initialized.
    
        The following are the default or special log files supported by the diagnostics:
        0x0000: ACTIVE_ERROR_LOG_ID - Indicates the currently active error log.
        0x0001: ACTIVE_ASCII_LOG_ID - Indicates the currently active ASCII log.
        0x0002: ACTIVE_RW_STATISTICS_LOG_ID - Indicates the currently active R/W statistics log.
        0xFFFC: DEFAULT_ERROR_LOG_ID - Indicates the default error log.
        0xFFFD: DEFAULT_RW_STATISTICS_LOG_ID - Indicates the default R/W statistics log.
        0xFFFE: TEMPORARY_LOG_ID - This log is used internally for copy operations.
        0xFFFF: INVALID_LOG_ID - Indicates an invalid log.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: None
    

  <b><i><u>Output Data:</u></i></b>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    

  <b><i><u>Revision History:</u></i></b>
<a name="INIT_LOG_FILE_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="LOAD_UNLOAD_HEADS_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Load/Unload Heads"></a><hr align=left width="75%"><b> Load/Unload Heads (Level 3 'b')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    The command loads or unloads the heads for drives that support this feature.

  <b><i><u>Quick Help:</u></i></b>
<a name="LOAD_UNLOAD_HEADS_QUICK_HELP"></a>
    "LoadUnloadHeads, b[Cmd],[Velocity],[Dwell],[Lock]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="LOAD_UNLOAD_HEADS_PARM"></a>
    0 - Command Type ID.
    
          This parameter specifies which operation is to be performed.
<a name="LOAD_UNLOAD_TYPE_DESCRIPTION"></a>
          0x00: LOAD_HEADS_CMD - Indicates that a Load Heads servo command will be issued.
          0x01: UNLOAD_HEADS_CMD - Indicates that an Unload Heads servo command will be issued.
    
          Type:    Unsigned hexadecimal value
    
          Range:   0 to Maximum valid command type
    
          Default: 0
    
    1 - Load or Unload Velocity.
    
          For a 'Load Heads' command, this parameter specifies the load velocity.
          For a 'Unload Heads' command, this parameter specifies the unload velocity.
    
          If a value of 0 is entered then the load/unload velocity will not be modified
          and the default value in the servo firmware will be used.
    
          If a non-zero value is entered, then the velocity will be modified for the
          load/unload command. After completion of the command, the original value will
          then be restored.
    
          The units are ADC counts.
        
             Type:    Signed decimal value
    
             Range:   -999 to 999
    
             Default: 0
    
    2 - Enable Demod Sync.
    
          This parameter will enable or disable Demod Sync during the Load command.
    
          A value of 1 will enable Sync, a value of 0 will disable Sync.
    
          This parameter is ignored by the Unload command.
    
             Type:    Unsigned hexadecimal value
    
             Range:   0 or 1
    
             Default: 0
    
    3 - Enable Dwell.
    
          This parameter will enable or disable Dwell during the Load command.
    
          A value of 1 will enable Dwell, a value of 0 will disable Dwell.
    
          This parameter is ignored by the Unload command.
    
             Type:    Unsigned hexadecimal value
    
             Range:   0 or 1
    
             Default: 0
    
    4 - Unload Type.
    
          This parameter specifies the unload type to be done.
<a name="UNLOAD_TYPE_DESCRIPTION"></a>
          0: VCM_BEMF_VELOCITY_CONTROL - Vcm Bemf Control will be used.
          1: UNLOAD_IMMEDIATE - Unload Immediate will be used.
          2: HARDWARE_RETRACT - Hardware Retract will be used.
    
          This parameter is ignored by the Load command.
    
             Type:    Unsigned hexadecimal value
    
             Range:   0 or Maximum number of supported unload types.
    
             Default: 0
    

  <b><i><u>Output Data:</u></i></b>
<a name="LOAD_UNLOAD_HEADS_OUTPUT_DATA"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
        If no error occurred and Verbose Output Mode is selected,
        the following information will be displayed.
     
        AAAA LOAD/UNLOAD TYPE
        Elapsed Time bbb.bbb msecs
            cc Velocity in firmware
             d Velocity Cmd
             e Enable Demod Sync Cmd
             f Enable Dwell Cmd
             g Unload Type Cmd
          hhhh Load/Unload Time
         iiiii Bemf Calibrated Gain
             j Calibrated Vcm Bemf Offset
           kkk Bemf Calibrated Residual Error
             l Bemf Cal Retries
         mmmmm Load/Unload Peak Current
            nn Load/Unload Max Spin Dip Error
           ooo Load/Unload Peak Velocity
             p Load Heads Retries
          qqqq Load/Unload Status Code
     
        where:
        
        AAAA is the servo command: 0F00 for a Load operation or 0E00 for a Unload operation.
     
        bbb.bbb is the time in miliseconds for the execution of the servo command.
     
        cc is the Velocity as read from servo, which will be used as the default value.
           For a Load operation, the value of the load heads target velocity will be displayed.
           For an Unload operation, the value of unload heads target velocity will be displayed.
     
        The next several values are entries 'echoed' from the command line:
     
        d is the requested Velocity as entered via the command line.
     
        e is the Enable Demod Sync value as entered via the command line.
     
        f is the Enable Dwell value as entered via the command line.
     
        g is the Unload Type value as entered via the command line.
     
        The remaining values are data returned by servo after command completion:
     
        hhhh is the Load/Unload Time
     
        iiiii is the Bemf Calibrated Gain
     
        j is the value of the Calibrated Vcm Bemf Offset
        
        kkk is the value of Bemf Calibrated Residual Error
     
        l is the number Bemf Cal Retries used
     
        mmmmm is the value of Load/Unload Peak Current
     
        nn is the value of Load/Unload Max Spin Dip Error
     
        ooo if the value of Load/Unload Peak Velocity
     
        p  is the nuber of Load Heads Retries
     
        qqqq is the value of Load/Unload Status Code
     
     
 
  <b><i><u>Examples:</u></i></b>
 
    To load the heads with a velocity of -85:
    F3 3>b0,-85
                                                
    To unload the heads with a velocity of 317
    F3 3>b1,317

  <b><i><u>Revision History:</u></i></b>
<a name="LOAD_UNLOAD_HEADS_REVISION_HISTORY"></a>
    0001.0000   Initial revision.

<a name="MARK_MEDIA_FLAW_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Mark Media Flaw"></a><hr align=left width="75%"><b> Mark Media Flaw (Level 7 'h')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command marks tracks around an target area so that the target area may be found
    after the disk is developed.

    Note this command may take 10's of seconds.

<a name="MARK_MEDIA_FLAW_DIAGRAM"></a>
    Diagram below shows erased areas as 'E'.
    OD
                             *    E
             pointer length *     E
                             *    E
    EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE  *
    EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE   *  erase band width
    EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE  *
                           *
       undisturbed radius *
                           *
                              target flaw
                           *
       undisturbed radius *
                           *
    EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE  *
    EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE   *  erase band width
    EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE  *
                             *    E
             pointer length *     E
                             *    E
      ID

  <b><i><u>Quick Help:</u></i></b>
<a name="MARK_MEDIA_FLAW_QUICK_HELP"></a>
    "MarkMediaFlaw, h[PhyCyl],[Hd],[PhySec],[UndisturbedRadius],[EraseBandTrks],[PtrLen],[WgSpec],[Od/Id]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="MARK_MEDIA_FLAW_INFO_PARM"></a>
    0 - Cylinder
    
        This input specifies the physical cylinder to be marked.  This cylinder will
        not be written.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: none
    
    1 - Head.
    
        This input specifies the head number of the track to be marked.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: none
    
    2 - Sector or SFI or Wedge
    
        This input specifies which wedge is marked.
    
        If parameter 6 is 0 (default), this value is a physical sector number in the wedge
        to be marked.
        If parameter 6 is 1, this value is servo wedge number of the wedge to be marked.
        If parameter 6 is 2, this value is symbols from index in the wedge to be marked.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: none
    
    3 - Undisturbed Radius
    
        This input specifies how many tracks on each side of the defect are left undisturbed
        before the erase tracks begin.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: 0xF
    
    4 - Erase Band Width
    
        This input specifies how many tracks wide the full track erase mark will be.  This
        value must be at least three because the erase operation affects a minimum of three
        tracks.
    
          Type:    Unsigned 32-bit value
    
          Range:   3 to 0xFFFFFFFF
    
          Default: 0x1E
    
    5 - Pointer Length
    
        This input specifies how many tracks wide the single wedge erase pointer
        will be.   This pointer appears both inside the inner erase bands and outside the
        outer erase bands.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: 0x3C
    
    6 - Wedge Specifier Type
    
        This input specifies the units of parameter 2 ( sector or SFI or wedge )
        will be.
    
        If this value is 0 (default), parameter 2 is physical sector number.
        If this value is 1, parameter 2 is servo wedge number.
        If this value is 2, parameter 2 is symbols from index.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: 0 ( physical sector )
    
    7 - OD / ID Specifier
    
        This input indicates whether to mark the OD, the ID, or both.
    
        If this value is 1, mark only the OD.
        If this value is 2, mark only the ID.
        If this value is neither 1 nor 2, mark both the OD and the ID.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: 0 ( mark both OD and ID )
    

  <b><i><u>Output Data:</u></i></b>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    

  <b><i><u>Examples:</u></i></b>

    Example #1:
    To mark the wedge holding sector 17h of physical track 90, head 0:
          
       F3 7>h90,0,17
          
    or

       F3 7>h90,0,17,,,,0

    Example #2:
    To mark the wedge containing 7300h symbols from index of physical track 90, head 0:
          
       F3 7>h90,0,7300,,,,1

    Example #3:
    To mark wedge 8 of physical track 90, head 0:

       F3 7>h90,0,8,,,,2

    Example #4:
    To mark wedge 5 of physical track 90, head 0, leaving 0xC tracks undisturbed on either
    side of the defect, erasing 0x20 tracks on each side, and making pointers 0x55
    tracks long:

       F3 7>h90,0,5,C,20,55,2

    Example #5:
    To mark the wedge holding sector 5 of physical track 20h, head 1, using only tracks
    toward the ID from the defect:

       F3 7>h20,1,5,,,,,2

  <b><i><u>Revision History:</u></i></b>
<a name="MARK_MEDIA_FLAW_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0001.0001   Add support for inputting wedge or SFI as well as physical sector.
    0001.0002   Fix bug that prevented operation at extreme OD.
                Add ability to mark only one side of a defect.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).
    0011.0001   Improve accuracy of tracks erased

<a name="MEASURE_DISC_ECCENTRICITY_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Measure Disc Eccentricity"></a><hr align=left width="75%"><b> Measure Disc Eccentricity (Level 5 'E')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command performs the Measure Disc Eccentricity operation.
    
  <b><i><u>Quick Help:</u></i></b>
<a name="MEASURE_DISC_ECCENTRICITY_QUICK_HELP"></a>
    "MeasureDiscEccentricity";

  <b><i><u>Input Parameters:</u></i></b>
    None

  <b><i><u>Output Data:</u></i></b>
<a name="MEASURE_DISC_ECCENTRICITY_OUTPUT_DATA"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
    
    If no error occurred, then the following will be displayed for each supported head:
    
          Disc Eccentricity In Microinches
          Head     Magnitude   Real        Imag
             a     b.bbbbb     c.cccccc    d.dddddd
    
          where
    
             a is the head used for the measurement
    
             b.bbbbb is the magnitude in microinches complex eccentricity for the designated head
    
             c.ccccc is the real component in microinches of the complex eccentricity for the
             designated head
    
             d.ddddd is the imaginary component in microinches of the complex eccentricity for
             the designated head
    

  <b><i><u>Examples:</u></i></b>
 
    Example #1:
    To measure disc eccentricity on all heads:
       
       F3 5>E
 
  <b><i><u>Revision History:</u></i></b>
<a name="MEASURE_DISC_ECCENTRICITY_REVISION_HISTORY"></a>
    0001.0000   Initial revision.

<a name="MEASURE_LATCH_FORCE_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Measure Latch Force"></a><hr align=left width="75%"><b> Measure Latch Force (Level 3 'c')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    For drives that support this feature, this diagnostic will measure the force required to
    push the actuator off of the latch. The diagnostic will perform the measurement the
    user-specified number of times and return the minimum, average, and maximum values.
    The output data is unscaled (in dac counts).

  <b><i><u>Quick Help:</u></i></b>
<a name="MEASURE_LATCH_FORCE_QUICK_HELP"></a>
    "Measure Latch Force, c[NumberOfSamples]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="MEASURE_LATCH_FORCE_PARM"></a>
    0 - Number of Samples.
    
          This parameter specifies the number of times that the Latch Force Measurement
          should be done.
    
          Type:    Positive decimal value
    
          Range:   1 .. 999
    
          Default: 10
    

  <b><i><u>Output Data:</u></i></b>
<a name="MEASURE_LATCH_FORCE_OUTPUT_DATA"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
        If no error occurred the following information will be displayed.
     
        Latch Force:
        Min      Avg     Max
        aaaaa    bbbbb   ccccc
     
        Where:
        aaaaa is the Minimum Latch Force Value
        bbbbb is the Average Latch Force Value
        ccccc is the Maximum Latch Force Value
     
 
  <b><i><u>Examples:</u></i></b>
 
       Example #1:
       To measure the latch force 10 times (this is the default):
 
       F3 3>c
 
       Example #2:
       To measure the latch force 64 times:
 
       F3 3>c64
                                                
  <b><i><u>Revision History:</u></i></b>
<a name="MEASURE_LATCH_FORCE_REVISION_HISTORY"></a>
    0001.0000   Initial revision.

<a name="MEASURE_SEEK_ACCESS_TIME_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Measure Seek Access Time"></a><hr align=left width="75%"><b> Measure Seek Access Time (Levels 3, 4, 'D')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    Performs seek access time test on the current head. This diag supports two modes:
    1) Logical random-length seeks, 2) Logical fixed-length seeks.

  <b><i><u>Quick Help:</u></i></b>
<a name="MEASURE_SEEK_ACCESS_TIME_QUICK_HELP"></a>
    "MeasureSkAccessTime, D[SkLength],[SkType],[NumSks]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="MEASURE_SEEK_ACCESS_TIME_PARM"></a>
    0 - Seek Length.
    
          This parameter sets the seek length to be used during the seek access time testing.
          If set to zero, then the seeks performed will be of random lengths.  If the value
          entered exceeds the drive's max track, then the seek length will be set to the max
          track.
        
          Type:    Unsigned 32-bit decimal value (8 digits max)
    
          Range:   0 to Max Track
    
          Default: 0 (Random Seeks)
    
    1 - Seek Type.
    
        This parameter sets the type of seek to be performed during the seek access time
        testing.  The following are the valid seek types that this command accepts:
    
          0 - Read seeks: Specifies seeks to the read track follow position.
          1 - Write seeks: Specifies seeks to the write track follow position.
          2 - Write header seeks: Specifies seeks to the write header track follow position.
              (This positions the writer to the read track follow position, that is, to the
              negative reader/writer offset.)
    
          Type:    Unsigned 8-bit value
    
          Range:   0 to 2
    
          Default: 0 (Read Seeks)
    
    
    2 - Number of Seeks.
    
        This parameter specifies the number of seeks to perform during the seek access time
        testing.
    
          Type:    Unsigned 32-bit decimal value (5 digits max)
    
          Range:   1 to 99,999
    
          Default: 1000
    

  <b><i><u>Output Data:</u></i></b>
<a name="MEASURE_SEEK_ACCESS_TIME_STATUS"></a>
    If no error occurred and the Seek Access Time data was returned, the following message
    will be displayed.
    
          "Sk Length = _____"
          "SEEKTYPE"
          "Num Seeks = _____"
          "Avg Time usec = _____"
          "Min Time usec = _____"
          "Max time usec = _____"
    

  <b><i><u>Examples:</u></i></b>

    To perform 1000 random read seeks:
       F3 3>D0,0,1000
       F3 3>D         <-- This works because the defaults are 1000 random read seeks.

    To perform 10000 full-stroke write seeks:
       F3 3>D9999999,1,10000

    To perform 10000 random JIT 3 read seeks:
       F3 4>u1,3      <-- Sets the seek speed to JIT 3.
       F3 3>D,,10000  <-- No parameters 0 and 1 because the default is random read seeks.

  <b><i><u>Revision History:</u></i></b>
<a name="MEASURE_SEEK_ACCESS_TIME_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="MEASURE_THROUGHPUT_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Measure Throughput"></a><hr align=left width="75%"><b> Measure Throughput (Level 2 'T')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command is used to test the drive's read and write speed.

  <b><i><u>Quick Help:</u></i></b>
<a name="MEASURE_THROUGHPUT_QUICK_HELP"></a>
    "MeasureThroughput, T[Opts],[MinSkew],[MaxSkew],[SkewStep]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="MEASURE_THROUGHPUT_COMMAND_PARM"></a>
    0 - Command Flags
    
        This input sets read or write and determines disk access range.
        
          bit 15:     set      write
                      cleared  read
          bit 14:     set      scan entire full pack, ignore bits 0-13
                      cleared  sample first cylinders of zones specified below
          bit 13:     set      all zones, ignore bits 0-12
                      cleared  single zone
          bits 4-12   ignored
          bits 0-3    zone number
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: 0 (read zone zero)
    
    1 - Minimum skews
    
        This input establishes the minimum skews.
    
          bits 8-15: minimum cylinder skew
          bits 0-7:  minimum head skew
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: normal drive cylinder and head skew
    
    2 - Maximum Skews
    
        This input establishes the maximum skews.
    
          bits 8-15: maximum cylinder skew
          bits 0-7:  maximum head skew
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: normal drive cylinder and head skew
    
    3 - Skew Step Size
    
        This input establishes how much the skews
        increment between tests.
    
          Type:    Unsigned 16-bit value
    
          Range:   1 to DIAG_THROUGHPUT_MAX_SKEW_STEP ( 10 dec )
    
          Default: 1
    

  <b><i><u>Output Data:</u></i></b>
<a name="MEASURE_THROUGHPUT_COMMAND_DATA"></a>
    
    throughput KBS = kilobytes / second
    
    Example:
    
    F3 2>T9,1300,1700,1
    Min Max Cyl: 13 17
    Min Max Head: 0 0
     Zone 9   cyl skew 13  head skew 0   throughput KBS:    6.134
     Zone 9   cyl skew 14  head skew 0   throughput KBS:   10.589
     Zone 9   cyl skew 15  head skew 0   throughput KBS:   10.837
     Zone 9   cyl skew 16  head skew 0   throughput KBS:   10.832
     Zone 9   cyl skew 17  head skew 0   throughput KBS:   10.826
    

  <b><i><u>Revision History:</u></i></b>
<a name="MEASURE_THROUGHPUT_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="MEMORY_BLOCK_DISPLAY_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Memory Block Display"></a><hr align=left width="75%"><b> Memory Block Display (Level 1, F 'D')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    The Memory Block Display command reads and displays the contents of memory starting
    at the specified address.  Optionally, the memory data being displayed can be compared
    to a specified value, with miscomparing bytes displayed as highlighted text.  This
    command also optionally supports specifying the size of the memory unit to be addressed.
    It can support reading and displaying 8-bit, 16-bit, 32-bit, and 64-bit memory unit
    sizes.

    ************************************** NOTE *********************************************
    This command allows attempts to read addresses without validation.  But reading invalid
    addresses may hang the drive.  This command should be used with great caution if the
    option to override address validation is enabled.
    *****************************************************************************************

  <b><i><u>Quick Help:</u></i></b>
<a name="MEMORY_BLOCK_DISPLAY_QUICK_HELP"></a>
    "DisplayMemoryBlock, D[AddrHi],[AddrLo],[CompVal],[NumBytes],[Opts],[SizeInBytes]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="MEMORY_BLOCK_DISPLAY_PARM"></a>
    0 - Memory Address or Memory Address High.
    
        If parameter 1 is not entered, this parameter contains the 32-bit address of the
        first memory location to be read and displayed.  If parameter 1 is entered, this
        parameter contains the upper 16-bits of the address of the first memory location
        to be read and displayed.
    
          Type:    Unsigned 32-bit value, if parameter 1 is not entered
                   Unsigned 16-bit value, if parameter 1 is entered
    
          Range:   0 to 0xffff, if parameter 1 is not entered
                   0 to 0xffffffff, if parameter 1 is entered
    
          Default: 0
    
    1 - Memory Address Low.
    
        If entered, this parameter contains the lower 16-bits of the address of the first
        memory location to be read and displayed.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xffff
    
          Default: None.  If this parameter is not entered, parameter 0 is assumed to
                   specify the entire 32-bit address of the first memory location to be
                   read and displayed.
    
    2 - Data Compare Value.
    
        If entered, this parameter specifies a value that will be compared to the contents
        of the specified memory locations.  If the contents of the memory location are
        different than the specified value, they will be displayed in high-intensity mode,
        If the contents of the memory location are equal to the specified value, they will
        be displayed in low-intensity mode.  The value passed in this parameter must not be
        larger than number of bytes specified in parameter 5.
    
          Type:    Unsigned 8-bit, 16-bit, 32-bit, or 64-bit value
    
          Range:   If parameter 5 is 1: 0 to 0xFF
                   If parameter 5 is 2: 0 to 0xFFFF
                   If parameter 5 is 4: 0 to 0xFFFFFFFF
                   If parameter 5 is 8: 0 to 0xFFFFFFFFFFFFFFFF
    
          Default: None
    
    3 - Number of Bytes to display.
    
        This parameter specifies the number of memory bytes to be displayed.
    
          Type:    Unsigned 32-bit value
    
          Range:   1 to 0xFFFFFFFF
    
          Default: 0x200
    
    4 - Options.
    
        This parameter is a bit-significant value that selects the following options.
    
          Bits 31-2: not used
    
          Bit 1: Disable Validation of Memory Address
    
                 If this bit is cleared, the memory address will be validated. If this bit
                 is set, the input memory address will be used without checking with the
                 memory map.
    
          Bit 0: Disable pause after each block displayed.
    
                 If this bit is cleared, the display will pause after each 512-byte block
                 and wait for the user to enter a character.
    
                 If this bit is set, all of the requested bytes will be displayed without
                 pausing.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0x00000003
    
          Default: 0
    
    5 - Number Of Bytes Per Memory Access.
    
        This parameter indicates to the diagnostic command what memory unit size in bytes to
        use when reading the memory block.  The only valid values for this parameter are
        8, 4, 2, and 1.
    
          Type:    Unsigned 8-bit value
    
          Range:   Valid values are 8, 4, 2, and 1
    
          Default: 1
    

  <b><i><u>Output Data:</u></i></b>
<a name="PROCESSOR_MEMORY_BLOCK_DATA"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
        If no error occurred, the following header will be displayed.
    
              "Processor Memory at Addr cccccccc"                         or
              "Processor Memory at Addr cccccccc compared to dd hex"
    
           where
    
              cccccccc is the address of the first Processor Memory byte displayed
    
              dd is the byte to which the displayed data was compared
    
        If the memory data is being displayed as bytes, the following information will be
        displayed following the header.
    
              "  Addr    0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F"
              "eeeeeeee  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff"  (repeated)
    
        If the memory data is being displayed as half-words (2 bytes), the following
        information will be displayed following the header.
    
              "  Addr    0    2    4    6    8    A    C    E"
              "eeeeeeee  ffff ffff ffff ffff ffff ffff ffff ffff"  (repeated)
    
        If the memory data is being displayed as words (4 bytes), the following information
        will be displayed following the header.
    
              "  Addr    0        4        8        C"
              "eeeeeeee  ffffffff ffffffff ffffffff ffffffff"  (repeated)
    
        If the memory data is being displayed as double-words (8 bytes), the following
        information will be displayed following the header.
    
              "  Addr    0                8"
              "eeeeeeee  ffffffffffffffff ffffffffffffffff"  (repeated)
    
           where
    
              eeeeeeee is the address of the first byte in the row.
    
              ff is the memory data byte.
    
        If a displayed data is being compared to a reference byte, the bytes or symbols that
        are not equal to the reference will be displayed as highlighted text.
    

  <b><i><u>Examples:</u></i></b>

    Example #1: Display 512 bytes of memory starting at address 0 in 8-bit chunks

       F3 1>D
       F3 1>D0,,,200
       F3 1>D0,0,,200

    Example #2: Display 1024 bytes of memory starting at 04000000 in 16-bit chunks

       F3 1>D04000000,,,400,,2
       F3 1>D0400,0000,,400,,2

    Example #3: Display 512 bytes of memory from address 0 in 64-bit chunks and compare each
                element to the value 0xE580C000E12CC38E

       F3 1>D,,E580C000E12CC38E,,,8

  <b><i><u>Revision History:</u></i></b>
<a name="MEMORY_BLOCK_DISPLAY_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="MERGE_ALTERNATE_LIST_INTO_SLIP_LIST_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Merge Alternate List into Slip List"></a><hr align=left width="75%"><b> Merge Alternate List into Slip List (Level A 'P')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    The Merge Alternate List Into Slip List command merges all defects from the
    G list into the P list and then regenerates the alt and slip lists.  This in effect
    changes alternated sectors to slipped sectors.

  <b><i><u>Quick Help:</u></i></b>
<a name="MERGE_ALTERNATE_LIST_INTO_SLIP_LIST_QUICK_HELP"></a>
    "MergeAltListIntoSlipList, P";

  <b><i><u>Input Parameters:</u></i></b>
    None

  <b><i><u>Output Data:</u></i></b>
    The command's output is as follows.

          F3 A>P
          Command may take 10's of seconds, be patient...

    This is good advice.

  <b><i><u>Revision History:</u></i></b>
<a name="MERGE_ALTERNATE_LIST_INTO_SLIP_LIST_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="MODIFY_TRACK_DEFECT_LIST_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Modify Track Defect List"></a><hr align=left width="75%"><b> Modify Track Defect List (Level 2 'F')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    The Modify Track Defect List command modifies the defect list for the specified
    sector(s).

  <b><i><u>Quick Help:</u></i></b>
<a name="MODIFY_TRACK_DEFECT_LIST_QUICK_HELP"></a>
    "ModTrkDfctLst, F[PSctr/LBA],[Action]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="MODIFY_TRACK_DEFECT_LIST_PARM"></a>
    
    0 - Physical Sector or LBA to Modify.
    
        If Parameter 1 is A1, B1, C1, or F1, this value is an LBA.
        If parameter 1 is some other value, this parameter is the physical sector number
        of the block to be affected.  The cylinder and head come from the current address.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: 0
    
          Note:    The track and head used are the current track.  When working with sectors
                   that are already alted, it is best to use the LBA mode actions (B1 and C1
                   below) .
    
    
    1 - Defect List Action.
    
        Parameter 1 specifies the format action to be taken. The valid choices are:
          A - Add Sector to Alternated Sector List
          A1 - Add LBA to Alternated Sector List
          B - Add Sector to Pending Sector List
          B1 - Add LBA to Pending Sector List
          C1 - Remove LBA from Alternated Sector List
          F1 - Remove LBA from Alternated Sector List ( same as C1 above )
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: 0x0C1
    

  <b><i><u>Output Data:</u></i></b>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    

  <b><i><u>Examples:</u></i></b>

    Example #1:
    To remove LBA 1234 from the alt list:

       F3 2>F1234,f1

  <b><i><u>Revision History:</u></i></b>
<a name="MODIFY_TRACK_DEFECT_LIST_REVISION_HISTORY"></a>
    0001.0000 Initial Revision.
    0002.0000 Remove 2>Fx,F; add Fx,F1 to unalt by sector.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="ODD_EVEN_ENCROACHMENT_TEST_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Odd Even Encroachment Test"></a><hr align=left width="75%"><b> Odd Even Encroachment Test (Level T 'T')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command will read the specified range of tracks.  It will determine how many
    sectors fall into various ranges of retry counts.

  <b><i><u>Quick Help:</u></i></b>
<a name="ODD_EVEN_ENCROACHMENT_TEST_QUICK_HELP"></a>
    "OddEvenEncroachmentTest, T[strt tk],[end tk],[hd],[rtry thrshld][ECC thrshld";

  <b><i><u>Input Parameters:</u></i></b>
<a name="ODD_EVEN_ENCROACHMENT_TEST_PARM"></a>
    0 - Start Logical Cylinder
    
        This parameter specifies the first logical cylinder to be tested.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: none
    
    1 - End Logical Cylinder
    
        This parameter specifies the last logical cylinder to be tested.  Up to 100d tracks
        can be tested in one command.  Attempting to test more tracks will cause an error.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: none
    
    2 - Head
    
        This parameter specifies logical head to test.
    
          Type:    Unsigned 8-bit value
    
          Range:   0 to 0xFF
    
          Default: none
    
    3 - Retry Threshold
    
        This parameter specifies the boundary between two retry buckets.  Retries less
        than or equal to this value go into one bucket, retries greater than this value go
        into another bucket.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: 4
    
    4 - Ecc Level Threshold
    
        This parameter specifies how much ECC correction is done on the fly.  This ECC level
        defines the "no retries but corrected" retry bucket.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: 0xA
    

  <b><i><u>Output Data:</u></i></b>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
<a name="ODD_EVEN_ENCROACHMENT_TEST_DATA"></a>
    The list header displays the logical head number and the ECC threshold.  The column
    headings indicate the threshold value. The body of the list displays:
       Logical cylinder
       Number of sectors that required no retries and no ECC correction
       Number of sectors that required no retries but did require ECC correction
       Number of sectors that required at least one retry but less than of equal to the
       threshold number of retries
       Number of sectors that were readable but required more than the threshold number
       of retries
       Number of sectors that were unreadable

  <b><i><u>Examples:</u></i></b>
<a name="ODD_EVEN_ENCROACHMENT_TEST_EXAMPLE"></a>
    F3 T>T20,23,0,3,4
    Head 0  ECC threshold 4
    L Cyl  perfct OTF   <=3    >3   Unreadable
       20   789     7     0     0     0
       21   789     7     0     0     0
       22   78C     4     0     0     0
       23   78C     4     0     0     0
                                        
    F3 T>

  <b><i><u>Revision History:</u></i></b>
<a name="ODD_EVEN_ENCROACHMENT_TEST_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0002.0000   Added ECC level threshold
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="OFF_TRACK_CAPABILITY_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Off Track Capability"></a><hr align=left width="75%"><b> Off Track Capability (Level 7 'c')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command is used to test the drive's ability to read offtrack.

  <b><i><u>Quick Help:</u></i></b>
<a name="OFF_TRACK_CAPABILITY_QUICK_HELP"></a>
    "OffTrackCapability, c[Sec],[NumSecs],[SecIncrement],[Offset]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="OTC_COMMAND_PARM"></a>
    0 - Starting Sector
    
        This input is to set the starting physical sector number.
        
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: None
    
    1 - Sector Count
    
        This input is to set the number of sectors to test.
        
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: None
    
    2 - Sector Increment
    
        This input specifies how much to increment the sector
        number between each test.
        
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: None
    
    3 - Offset to one side
    
        This input specifies how far offtrack the test will start
        and finish.
        
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0x200
    
          Default: None
    

  <b><i><u>Output Data:</u></i></b>
<a name="OTC_COMMAND_DATA"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
    
    
        The first two lines show column headings:
           wedge    - data wedge where sector begins
           log      - logical sector number of wedge
           phy      - physical sector number of wedge
           8888
           048C etc - offset (read down, example shows 80, 84, 88 8C...)
    
        The following lines show the sector being tested, and the results at
        each offset.  The results are shown with character codes:
           .  -> Read OK
           *  -> Read error
           |  -> Read OK at track centerline
           +  -> Read error at track centerline
    
        The bottom line shows the average bathtub mid point, the average
        greatest readable offset, and the average loweset readable offset.
    
     F3 7>c1B,5,1,80
                                                                                                      
                      88889999AAAABBBBCCCCDDDDEEEEFFFF000011112222333344445555666677778
     wedge  log (phy) 048C048C048C048C048C048C048C048C048C048C048C048C048C048C048C048C0
       107 001B(001B) ***.............................|.......................********* FF8C   5C FFF4
       107 001C(001C) **.*............................|.......................*.******* FF88   5C FFF2
         0 001D(001D) ****............................|....................*.********** FF90   50 FFF0
         0 001E(001E) ***.............................|......................********** FF8C   58 FFF2
         0 001F(001F) ******..........................|....................**.********* FF98   50 FFF4
     Average FF8F   56 FFF3

  <b><i><u>Revision History:</u></i></b>
<a name="OFF_TRACK_CAPABILITY_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="PARTICLE_SWEEP_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Particle Sweep"></a><hr align=left width="75%"><b> Particle Sweep (Level 2 'J')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command performs the particle sweep operation. To perform particle sweep, a seek
    length is calculated to satisfy the conditions imposed by the input parameters. Seeks of
    this length are repeatedly issued to move the head from the Start Cylinder towards the
    End Cylinder, while pausing the specified dwell time between each successive seek. All
    seeks will be done using head 0, and will be of equal length, time, and dwell. The time
    needed to complete the particle sweep will be approximately equal to the time specified
    by the Duration parameter.
    
  <b><i><u>Quick Help:</u></i></b>
<a name="PARTICLE_SWEEP_QUICK_HELP"></a>
    "ParticleSweep, J[ Start Cyl ],[ End Cyl ],[ Duration mSec ],[ Dwell mSec ],[ JIT mode ]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="PARTICLE_SWEEP_INPUT_PARAMETER"></a>
    
    0 - Start Cylinder.
    
        This parameter is the cylinder from which the particle sweep will begin.
        Notes:
          1) if Start Cylinder and End Cylinder are the same, then the particle sweep range
          will default to the drive's Max and Min cylinders respectively.
          2) Start Cylinder may be greater than or less than End Cylinder.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to Maximum Cylinder
    
          Default: 0
    
    
    1 - End Cylinder.
    
        This parameter is the cylinder on which the particle sweep will end.
        Notes:
          1) if Start Cylinder and End Cylinder are the same, then the particle sweep range
          will default to the drive's Max and Min cylinders respectively.
          2) End Cylinder may be greater than or less than Start Cylinder.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to Maximum Cylinder
    
          Default: 0
    
    
    2 - Duration.
    
        This parameter specifies the time in milliseconds that the particle sweep
        will use to move from the Start Cylinder to the End Cylinder including the
        Dwell time.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: 5000 mSec
    
    
    3 - Dwell Time In Milliseconds.
          
        This parameter specifies the amount of time in milliseconds for the head to
        remain on track before the next seek is issued.
          
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: 1 Rev Time In mSec
    
    
    4 - Servo Seek Speed (JIT mode).
    
        This parameter specifies one of the servo JIT modes, which controls how fast the
        actuator can move from cylinder to cylinder.
        Note: if a JIT mode is requested that is slower than supported, then the
        slowest supported JIT mode will be used.
    
<a name="SEEK_SPEED"></a>
          0x00: RW_SEEK_SPEED_0 - Indicates normal seeks should be executed.
          0x01: RW_SEEK_SPEED_1 - If supported, indicates JIT1 seeks should be executed.
          0x02: RW_SEEK_SPEED_2 - If supported, indicates JIT2 seeks should be executed.
          0x03: RW_SEEK_SPEED_3 - If supported, indicates JIT3 seeks should be executed.
    
          Type:    Unsigned 8-bit value
    
          Range:   0 to 0xFF
    
          Default: Slowest JIT mode
    

  <b><i><u>Output Data:</u></i></b>
<a name="PARTICLE_SWEEP_OUTPUT_DATA"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
    
    If an error occurred, then the following will be displayed:
    
          DiagError aaaaaaaa
       
          where
          
             aaaaaaaa is the diagnostic error code detected
    
    If R/W status information is available upon completion of the diagnostic,
    then the following will be displayed:
    
          "Particle Sweep"
          "R/W Status c, R/W Error dddddddd
    
          where
    
             c is the status that was returned by the R/W subsystem
    
             dddddddd is the error code that was returned by the R/W subsystem
    

  <b><i><u>Examples:</u></i></b>
 
    Example #1:
    To do a particle sweep using the default conditions, i.e. Start Cylinder = Max Cylinder,
    End Cylinder = Min Cylinder, 5-second duration, 1-rev dwell, and slowest JIT mode:
       
       F3 2>J
 
    Example #2:
    To do a particle sweep using Start Cylinder = 10, End Cylinder = 1000, 6-second
    duration, 200 mSec dwell, and slowest JIT mode:

       F3 >J10,1000,6000,200
 
    Example #3:
    Error handling of an invalid cylinder entry:
 
       F3 2>Jfffffff
 
       DiagError   00003013
 
  <b><i><u>Revision History:</u></i></b>
<a name="PARTICLE_SWEEP_REVISION_HISTORY"></a>
    0001.0000   Initial revision.

<a name="PAUSE_INTERFACE_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Pause Interface Task"></a><hr align=left width="75%"><b> Pause Interface Task (Online Control S)</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    If Diagnostic Mode is not currently enabled, this command pauses the Interface Task
    and enables Diagnostic Mode.

  <b><i><u>Quick Help:</u></i></b>
<a name="PAUSE_INTERFACE_QUICK_HELP"></a>
    "PauseInterfaceTask";

  <b><i><u>Input Parameters:</u></i></b>
    None

  <b><i><u>Output Data:</u></i></b>
    None

  <b><i><u>Revision History:</u></i></b>
<a name="PAUSE_INTERFACE_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="PAUSE_OUTPUT_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Pause Output"></a><hr align=left width="75%"><b> Pause Output (Online Space)</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command pauses the output of a diagnostic command that is in progress.  Entering
    any character will cause the command output to continue.

  <b><i><u>Quick Help:</u></i></b>
<a name="PAUSE_OUTPUT_QUICK_HELP"></a>
    "PauseOutput";

  <b><i><u>Input Parameters:</u></i></b>
    None

  <b><i><u>Output Data:</u></i></b>
    None

  <b><i><u>Revision History:</u></i></b>
<a name="PAUSE_OUTPUT_REVISION_HISTORY"></a>
    0001.0000   Initial revision.

<a name="PEEK_MEMORY_BYTE_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Peek Memory Byte"></a><hr align=left width="75%"><b> Peek Memory Byte (All Levels '+')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    The Peek Memory Byte command reads and displays the specified byte (8-bits) of
    processor memory.

  <b><i><u>Quick Help:</u></i></b>
<a name="PEEK_MEMORY_BYTE_QUICK_HELP"></a>
    "PeekMemoryByte, +[AddrHi],[AddrLo],[Opts]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="PEEK_MEMORY_BYTE_PARM"></a>
    0 - Memory Address or Memory Address High.
    
        If parameter 1 is not entered, this parameter contains the 32-bit address
        of the memory location to be read and displayed.  If parameter 1 is entered,
        this parameter contains the upper 16-bits of the address of the memory
        location to be read and displayed.
    
          Type:    Unsigned 32-bit value, if parameter 1 is not entered
                   Unsigned 16-bit value, if parameter 1 is entered
    
          Range:   0 to 0xffff, if parameter 1 is not entered
                   0 to 0xffffffff, if parameter 1 is entered
    
          Default: 0
    
    1 - Memory Address Low.
    
        If entered, this parameter contains the lower 16-bits of the address of the
        memory location to be read and displayed
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xffff
    
          Default: None. If this parameter is not entered, parameter 0 is assumed
                   to specify the entire 32-bit address of the memory location to
                   be read and displayed.
    
    2 - Peek Memory Address Options.
    
        Parameter 2 bit 0 controls the validation of the processor memory address.
    
            Bit 15-1: not used
    
            Bit 0: Disable Validation of Memory Address
    
                   If this bit is cleared, the memory address will be validated. If this bit
                   is set, the input memory address will be used without checking with the
                   memory map.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0x0001
    
          Default: 0
    

  <b><i><u>Output Data:</u></i></b>
<a name="RW_MEMORY_DATA_BYTE"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
        If no error occurred, the memory data will be displayed as follows.
    
              "Adr cccccccc ( dddddddd ) = ee"
    
           where
    
              cccccccc is the byte offset from the start of the memory
    
              dddddddd is the processor address
    
              ee is an 8-bit value written to or read from memory
    

  <b><i><u>Revision History:</u></i></b>
<a name="PEEK_MEMORY_BYTE_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="PEEK_MEMORY_WORD_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Peek Memory Word"></a><hr align=left width="75%"><b> Peek Memory Word (All Levels '-')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    The Peek Memory Word command reads and displays the specified word (16-bits) of
    processor memory.

  <b><i><u>Quick Help:</u></i></b>
<a name="PEEK_MEMORY_WORD_QUICK_HELP"></a>
    "PeekMemoryWord, -[AddrHi],[AddrLo],[Opts]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="PEEK_MEMORY_WORD_PARM"></a>
    0 - Memory Address or Memory Address High.
    
        If parameter 1 is not entered, this parameter contains the 32-bit address
        of the memory location to be read and displayed.  If parameter 1 is entered,
        this parameter contains the upper 16-bits of the address of the memory
        location to be read and displayed.
    
          Type:    Unsigned 32-bit value, if parameter 1 is not entered
                   Unsigned 16-bit value, if parameter 1 is entered
    
          Range:   0 to 0xffff, if parameter 1 is not entered
                   0 to 0xfffffffe, if parameter 1 is entered
    
                   The specified address must be a multiple of 2.
    
          Default: 0
    
    1 - Memory Address Low.
    
        If entered, this parameter contains the lower 16-bits of the address of the
        memory location to be read and displayed
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xfffe
    
                   The specified address must be a multiple of 2.
    
          Default: None. If this parameter is not entered, parameter 0 is assumed
                   to specify the entire 32-bit address of the memory location to
                   be read and displayed.
    
    2 - Peek Memory Address Options.
    
        Parameter 2 bit 0 controls the validation of the processor memory address.
    
            Bit 15-1: not used
    
            Bit 0: Disable Validation of Memory Address
    
                   If this bit is cleared, the memory address will be validated. If this bit
                   is set, the input memory address will be used without checking with the
                   memory map.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0x0001
    
          Default: 0
    

  <b><i><u>Output Data:</u></i></b>
<a name="RW_MEMORY_DATA_WORD"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
        If no error occurred, the memory data will be displayed as follows.
    
              "Adr cccccccc ( dddddddd ) = ffff"
    
           where
    
              cccccccc is the byte offset from the start of the memory
    
              dddddddd is the processor address
    
              ffff is a 16-bit value written to or read from memory
    

  <b><i><u>Revision History:</u></i></b>
<a name="PEEK_MEMORY_WORD_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="POKE_MEMORY_BYTE_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Poke Memory Byte"></a><hr align=left width="75%"><b> Poke Memory Byte (All Levels '=')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    The Poke Memory Byte command writes the specified byte (8-bits) of processor
    memory with the specified data.

  <b><i><u>Quick Help:</u></i></b>
<a name="POKE_MEMORY_BYTE_QUICK_HELP"></a>
    "PokeMemoryByte, =[AddrHi],[AddrLo],[Data],[Opts]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="POKE_MEMORY_PARM"></a>
    0 - Memory Address or Memory Address High.
    
        If parameter 2 is not entered, this parameter contains the 32-bit address
        of the memory location to be written.  If parameter 2 is entered, this
        parameter contains the upper 16-bits of the address of the memory location
        to be written.
    
          Type:    Unsigned 32-bit value, if parameter 2 is not entered
                   Unsigned 16-bit value, if parameter 2 is entered
    
          Range:   0 to 0xffff, if parameter 2 is not entered
                   0 to 0xffffffff, if parameter 2 is entered
    
          Default: 0
    
    1 - Memory Address Low or Memory Data.
    
        If parameter 2 is not entered, this parameter contains the 8-bit data with
        which the memory location is to be written.  If parameter 2 is entered, this
        parameter contains the lower 16-bits of the address of the memory location
        to be written.
    
          Type:    Unsigned 8-bit value, if parameter 2 is not entered
                   Unsigned 16-bit value, if parameter 2 is entered
    
          Range:   0 to 0xff, if parameter 2 is not entered
                   0 to 0xffff, if parameter 2 is entered
    
          Default: 0
    
    2 - Memory Data.
    
        If entered, this parameter contains the 8-bit data with which the memory
        location is to be written.
    
          Type:    Unsigned 8-bit value
    
          Range:   0 to 0xff
    
          Default: None
    
    3 - Poke Memory Options.
    
        Parameter 3 bit 0 controls the validation of the processor memory address.
    
            Bit 15-1: not used
    
            Bit 0: Disable Validation of Memory Address
    
                   If this bit is cleared, the memory address will be validated. If this bit
                   is set, the input memory address will be used without checking with the
                   memory map.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0x0001
    
          Default: 0
    

  <b><i><u>Output Data:</u></i></b>
<a name="RW_MEMORY_DATA_BYTE"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
        If no error occurred, the memory data will be displayed as follows.
    
              "Adr cccccccc ( dddddddd ) = ee"
    
           where
    
              cccccccc is the byte offset from the start of the memory
    
              dddddddd is the processor address
    
              ee is an 8-bit value written to or read from memory
    

  <b><i><u>Revision History:</u></i></b>
<a name="POKE_MEMORY_BYTE_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="READ_CHS_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Read CHS"></a><hr align=left width="75%"><b> Read CHS (Levels 2, 7 'R')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command reads data from the disk starting at the specified sector on the target
    track for the specified number of sectors.  The data is read into the Diagnostic Read
    Buffer.

  <b><i><u>Quick Help:</u></i></b>
<a name="READ_CHS_QUICK_HELP"></a>
    "RdChs, R[Sec],[NumSecs],,[PhyOpt],[Opts]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="READ_CHS_PARM"></a>
     0 - Logical or Physical Sector Address.
    
         If any value is entered for Parameter 3, this parameter contains the physical
         sector address of the first sector to read, else this parameter contains the
         User Area logical sector address of the first sector to read.
    
           Type:    Unsigned 16-bit value
    
           Range:   0 to maximum logical or physical sector address on the target track
    
           Default: 0
    
     1 - Transfer Length.
    
         This parameter specifies the number of consecutive sectors to read.
    
           Type:    Unsigned 32-bit value
    
           Range:   0 to 0xFFFFFFFF
    
           Default: If the Sector Address was entered and the Transfer Length was not entered,
                    then only the specified sector will be read.
    
                    If both the Sector Address and Transfer Length are not entered, then the
                    Transfer Length will be set based on the Test Space that is selected.
                    If the Random Transfer Length option is selected, a random value will be
                    used that is less than or equal to the number of sectors remaining on the
                    track.  If the Random Transfer Length option is not selected, the number
                    of sectors remaining on the track will be read.
    
                    If a Transfer Length is entered, it will be limited to the number of
                    sectors remaining on the track.
    
    <font color=red>
     2 - not used.
    
           Type:    None
    
           Range:   None
    
           Default: None
    
    </font>
     3 - Physical Sector Address Flag.
    
         If any value is entered for this parameter, then Parameter 0 specifies a physical
         sector address, else Parameter 0 specifies a User Area logical sector address.
    
           Type:    Unsigned 16-bit value
    
           Range:   0 to 0xFFFF
    
           Default: None
    
     4 - Options.
    
         This parameter is a bit-significant value that allows the user to select the
         following options.
    
           Bits 15-5:  not used.
    
           Bit 4:      Read All Test Space Sectors.
    
                       If this bit is set, all of the sectors in the Test Space will be
                       read, else only the sectors specified by Parameters 0 and 1 will
                       be read.
    
           Bit 3:      not used.
     
           Bit 2:      Rotate Buffer Sector Offset.
     
                       If this bit is set, the Target Buffer Sector Offset will be rotated
                       by 1 prior to the execution of this diagnostic command.
                       This bit was originally added to help writing random data pattern
                       reduce execution time by not having to re-fill the diagnostic buffer
                       with new random data pattern, which takes great amount of time,
                       but just rotating the Target Buffer Sector Offset at every time this
                       diagnostic command is executed with this option set.
                       To see or change the current Targer Buffer Sector Offset, please refer
                       all Level 'A', Set Test Space, diagnostic command for detail how-to.
    
    <font color=red>
           Bit 1:      Enable Dynamic Sparing.
    
                       If this bit is set, sectors containing media defects that meet
                       the failure criteria will be spared.
    </font>
    
           Bit 0:      Continue On Error.
     
                       If this bit is set and an error occurs, the read operation will
                       continue and attempt to read all of the requested sectors.  Each
                       error encountered will be displayed.
    
           Type:    Unsigned 16-bit value
    
           Range:   0 to 0xFFFF
    
           Default: 0    (Read the requested sectors,
                          Stop On Error)
    

  <b><i><u>Output Data:</u></i></b>
<a name="RW_OP_STATUS_OUTPUT_DATA"></a>
        If an error occurred, the following information will be displayed.
    
              "DiagError aaaaaaaa R/W Status c R/W Error dddddddd"
    
           and
    
              "Next User LBA eeeeeeee LLL CHS ffffff.g.hhhh PLP CHS iiiiii.j.kkkk"
              "Remaining Transfer Length llllllll"
    
           or
    
              "Next System LBA eeeeeeee LLL CHS ffffff.g.hhhh PLP CHS iiiiii.j.kkkk"
              "Remaining Transfer Length llllllll"
    
           where
    
              aaaaaaaa is the Diagnostic Error Code
    
              c is the status returned by the R/W subsystem
    
                    0 = R/W request completed successfully with error recovery
                    1 = R/W request completed successfully (no error recovery performed)
                    2 = R/W request failed
    
              dddddddd is the error code returned by the R/W subsystem
    
              eeeeeeee is the Disk Logical Block Address of the sector in error
    
              ffffff is the Logical Cylinder Address of the sector in error
    
              g is the Logical Head Address of the sector in error
    
              hhhh is the Logical Sector Address of the sector in error
    
              iiiiii is the Physical Cylinder Address of the sector in error
    
              j is the Logical Head Address of the sector in error
    
              kkkk is the Physical Sector Address of the sector in error
    
              llllllll is the number of sectors remaining to be read or written
    
        If the Verbose Formatted ASCII Data Output Mode is selected, the Verbose Mode option
        bits will enable the following data to be output when set.
    
           Bit 0:      Enables the R/W Status and R/W Error to be displayed
           Bit 1:      Enable the Next Address to be displayed
           Bit 2:      Enables the Track Position and Track Follow Offset to be displayed
           Bit 3:      Enables the Target Address to be displayed
           Bit 4:      Enables the Recovery Status to be displayed
           Bit 5:      Enables the Fault Status to be displayed
           Bit 6:      Enables the Elapsed Time to be displayed
           Bits 31-7:  NA
    
        If Bit 0 is set, the R/W Status and R/W Error will be displayed even if no error
        occurred.  The data displayed will be formatted as shown above.
    
        If Bit 1 is set, the Next Address will be displayed even if no error occurred.  The
        data displayed will be formatted as shown above.
    
        If Bit 2 is set, the Track Position and Track Follow Offset will be displayed as
        follows.
    
              "Read Position, Persistent Offset m.m% Total Offset n.n%"          or
              "Write Position, Persistent Offset m.m% Total Offset n.n%"         or
              "Write Header Position, Persistent Offset m.m% Total Offset n.n%"
    
           where
    
              m.m is the Persistent Track Follow Offset in units of percentage of track width
    
              n.n is the Total Track Follow Offset in units of percentage of track width
    
        If Bit 3 is set, the Target Address will be displayed as follows.
    
              "Target User LBA pppppppp LLL CHS qqqqqq.r.ssss PLP CHS tttttt.u.vvvv"
              "Starting Transfer Length wwwwwwww"
    
           or
    
              "Target System LBA pppppppp LLL CHS qqqqqq.r.ssss PLP CHS tttttt.u.vvvv"
              "Starting Transfer Length wwwwwwww"
    
           where
    
              pppppppp is the starting Disk Logical Block Address
    
              qqqqqq is the starting Logical Cylinder Address
    
              r is the starting Logical Head Address
    
              ssss is the starting Logical Sector Address
    
              tttttt is the starting Physical Cylinder Address
    
              u is the starting Logical Head Address
    
              vvvv is the starting Physical Sector Address
    
              wwwwwwww is the starting Transfer Length
    
        If Bit 4 is set, the Recovery Status will be displayed as follows.
    
              "Recovered User LBA AAAAAAAA LLL CHS BBBBBB.C.DDDD PLP CHS EEEEEE.F.GGGG"
              "Recovery Flags HHHH Count II"
    
           or
    
              "Recovered System LBA AAAAAAAA LLL CHS BBBBBB.C.DDDD PLP CHS EEEEEE.F.GGGG"
              "Recovery Flags HHHH Count II"
    
           where
    
              AAAAAAAA is the Disk Logical Block Address of the last recovered sector
    
              BBBBBB is the Logical Cylinder Address of the last recovered sector
    
              C is the Logical Head Address of the last recovered sector
    
              DDDD is the Logical Sector Address of the last recovered sector
    
              EEEEEE is the Physical Cylinder Address of the last recovered sector
    
              F is the Logical Head Address of the last recovered sector
    
              GGGG is the Physical Sector Address of the last recovered sector
    
              HHHH are the Recovery Flags reported by the Read/Write code
    
              II is the Recovery Count reported by the Read/Write code
    
        If Bit 5 is set, the Fault Status will be displayed as follows.
    
              "Drive Fault Status JJJJ Preamp Fault Status KKKK"
    
           where
    
              JJJJ is the Drive Fault Status reported by the Read/Write code
    
              KKKK is the Preamp Fault Status reported by the Read/Write code
    
        If Bit 6 is set, the Elapsed Time for the read/write operation will be displayed.
<a name="ELAPSED_TIME"></a>
    
       "Elapsed Time a mins b secs"  or
       "Elapsed Time b.c secs"       or
       "Elapsed Time c.d msecs"
    
    where
    
       a is minutes
       b is seconds
       c is milliseconds
       d is microseconds
    
    

  <b><i><u>Examples:</u></i></b>
    Example #1:
       To read a single logical sector
       (in this case logical sector 23 on logical cylinder 45 head 1)

          F3 2>A0
          F3 2>S45,1
          F3 2>R23

    Example #2:
       To read multiple logical sectors
       (in this case logical sectors 23 to 26 on logical cylinder 45 head 1)

          F3 2>A0
          F3 2>S45,1
          F3 2>R23,4

    Example #3:
       To read all of the logical sectors on a track
       (in this case all logical sectors on logical cylinder 45 head 1)

          F3 2>A0
          F3 2>S45,1
          F3 2>R

    Example #4:
       To read all of the logical sectors on multiple tracks
       (in this case all logical sectors on logical cylinders 45 to 49 head 0)

       Note: You must seek to the track before the first one to be read.

          F3 2>A3
          F3 2>S44,0
          F3 2>L,5
          F3 2>R

    Example #5:
       To read all of the logical sectors on a track and continue on error
       (in this case all logical sectors on logical cylinder 45 head 0)

       Note: An error message will be displayed for each sector in error.

          F3 2>A0
          F3 2>S45,0
          F3 2>R,,,,1

    Example #6:
       To read all of the logical sectors in the test space and continue on error

       Note: The Test Space is selected by the all level 'A' command.  An error
       message will be displayed for each sector in error.

          F3 2>R,,,,11

    Example #7:
       To read a single physical sector
       (in this case physical sector 32 on physical cylinder 54 head 0)

          F3 2>A0
          F3 2>s54,0,22
          F3 2>R32,,,1

    Example #8:
       To read multiple physical sectors
       (in this case physical sectors 32 to 35 on physical cylinder 54 head 0)

          F3 2>A0
          F3 2>s54,0,22
          F3 2>R32,4,,1

    Example #9:
       To read all of the physical sectors on a track
       (in this case all physical sectors on physical cylinder 54 head 0)

          F3 2>A0
          F3 2>s54,0,22
          F3 2>R,,,1

    Example #10:
       To read a single logical sector to a specific sector offset in the diagnostic read
       buffer
       (in this case logical sector 23 on logical cylinder 45 head 1,
        to the sector offset of 5 in the diagnostic read buffer)

          F3 2>A0
          F3 2>AF,5
          F3 2>S45,1
          F3 2>R23

    Example #11:
       To rotate the buffer sector offset by 1 and read a single logical sector to the
       rotated sector offset in the diagnostic read buffer.
       (This example assumes user ran the Example #10 above right before this example,
        in this case logical sector 24 on logical cylinder 45 head 1,
        to the sector offset of 6 in the diagnostic read buffer)

          F3 2>R24,,,,4

  <b><i><u>Revision History:</u></i></b>
<a name="READ_CHS_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0001.0001   Eliminated the Enable ZAP Updates and Enable Track Skipping option.
    0001.0002   Moved the Enable Dynamic Sparing option from the parameter 2 to the bit 1 of
                the parameter 4.
                Added new Rotate Buffer Sector Offset option to the bit 2 of the parameter 4.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="READ_CURRENT_SERVO_DESTINATION_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Read Current Servo Destination"></a><hr align=left width="75%"><b> Read Current Servo Destination (Level 3,8 'R')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command will display the Current Servo Destination information. The firmware
    components that make up the current position will also be displayed. These include:
    Destination Track Id, Destination Position, Mr Jog Value, and Offset Value MrJog.

  <b><i><u>Quick Help:</u></i></b>
<a name="READ_CURRENT_SERVO_DESTINATION_QUICK_HELP"></a>
    "ReadCurrentServoDestination, R";

  <b><i><u>Input Parameters:</u></i></b>
    None.

  <b><i><u>Output Data:</u></i></b>
<a name="READ_CURRENT_SERVO_DESTINATION_DATA"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
        If no error occurred, the following will be displayed
    
           AAAAAAAA DestinationTrackId Q0
     
           BBBBBBBB DestinationPosition Q12
     
           CCCCCCCC MrJogValue Q8
     
           DDDDDDDD OffsetValueMrJog Q8
     
           EEEEE.EEE Current Servo Destination
     
          where
    
              AAAAAAAA is a Q0 number (whole integer) that represents the servo track number.
    
              BBBBBBBB is a Q12 number (12 bits of fractional position) that represents the
              offset from DestinationTrackID.  This offset includes the read-to-write offset
              (aka microjog, reader/writer offset, MR jog, etc.) and any commanded diagnostic
              offsets from all sources.  It can also span many tracks (there are 20 bits of
              whole track information).
     
              CCCCCCCC is the total contribution of offset in servo counts that is computed by
              servo to account for the read-to-write offsets.  It is a Q8 number
              (8 bits of fractional information).
     
              DDDDDDDD is a diagnostic offset that is almost exclusively used by self-test to
              perform microjog calibration.  It's a Q8 number (8 bits of fractional information).
     
              EEEEE.EEE the actual target track with fractional position information that servo
              uses for its reference.
     

  <b><i><u>Revision History:</u></i></b>
<a name="READ_CURRENT_SERVO_DESTINATION_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="READ_LBA_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Read LBA"></a><hr align=left width="75%"><b> Read LBA (Level A 'R')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command reads data from the disk starting at the specified LBA (Logical Block
    Address) for the specified number of LBAs.  The data is read into the Diagnostic Read
    Buffer.

  <b><i><u>Quick Help:</u></i></b>
<a name="READ_LBA_QUICK_HELP"></a>
    "RdLba, R[Lba],[NumLbas],,[Opts]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="READ_LBA_PARM"></a>
     0 - LBA.
    
         If Parameter 3 bit 5 is set, then this parameter specifies the address of the first
         System Area LBA to be read, else it specifies the address of the first User Area LBA
         to be read.
    
           Type:    Unsigned 32-bit value
    
           Range:   0 to maximum User Area LBA, if parameter 3 bit 5 is set
                    0 to maximum System Area LBA, if parameter 3 bit 5 is cleared
    
           Default: Current Target Address
    
     1 - Transfer Length.
    
         This parameter specifies the number of consecutive LBAs to read.
    
           Type:    Unsigned 32-bit value
    
           Range:   0 to 0xFFFFFFFF
    
           Default: If the LBA (Parameter 0) was entered and the Transfer Length (Parameter 1)
                    was not entered, then only the specified LBA will be read.
    
                    If both the LBA (Parameter 0) and Transfer Length (Parameter 1) are not
                    entered, then the Transfer Length will be set based on the Test Space
                    that is selected.  If the Random Transfer Length option is selected, a
                    random value will be used that is less than or equal to the number of LBAs
                    remaining in the Test Space.  If the Random Transfer Length option is not
                    selected, the number of LBAs remaining on the track containing the current
                    Target LBA will be read.
    
                    If a Transfer Length is entered, it will be limited to the number of
                    LBAs remaining in the Test Space.
    
    <font color=red>
     2 - not used.
    
         In the legacy ST10 code, entering this parameter enables a 512-byte block to be
         read even if it is marked as alternated or pending.  This feature was added
         as part of the support for block sizes greater than 512-bytes.  This feature is
         not currently supported by the platform architecture.
    
           Type:    None
    
           Range:   None
    
           Default: None
    
    </font>
     3 - Options.
    
         This parameter is a bit-significant value that allows the user to select the
         following options.
    
           Bits 15-6:  not used.
    
           Bit 5:      Read System Area LBAs.
    
                       If this bit is set, then parameter 0 specifies a System Area LBA,
                       else parameter 0 specifies a User Area LBA.
    
           Bit 4:      Read All Test Space LBAs.
    
                       If this bit is set, all of the LBAs in the Test Space will be
                       read, else only the LBAs specified by Parameters 0 and 1 will
                       be read.
    
           Bit 3:      not used.
     
           Bit 2:      Rotate Buffer Sector Offset.
     
                       If this bit is set, the Target Buffer Sector Offset will be rotated
                       by 1 prior to the execution of this diagnostic command.
                       This bit was originally added to help writing random data pattern
                       reduce execution time by not having to re-fill the diagnostic buffer
                       with new random data pattern, which takes great amount of time,
                       but just rotating the Target Buffer Sector Offset at every time this
                       diagnostic command is executed with this option set.
                       To see or change the current Targer Buffer Sector Offset, please refer
                       all Level 'A', Set Test Space, diagnostic command for detail how-to.
    
    <font color=red>
           Bit 1:      Enable Dynamic Sparing.
    
                       If this bit is set, sectors containing media defects that meet
                       the failure criteria will be spared.
    </font>
    
           Bit 0:      Continue On Error.
     
                       If this bit is set and an error occurs, the read operation will
                       continue and attempt to read all of the requested LBA.  Each error
                       encountered will be displayed.
    
           Type:    Unsigned 16-bit value
    
           Range:   0 to 0xFFFF
    
           Default: 0    (Read User Area LBAs,
                          Read the requested sectors,
                          Disable Dynamic Sparing,
                          Stop On Error)
    

  <b><i><u>Output Data:</u></i></b>
<a name="RW_OP_STATUS_OUTPUT_DATA"></a>
        If an error occurred, the following information will be displayed.
    
              "DiagError aaaaaaaa R/W Status c R/W Error dddddddd"
    
           and
    
              "Next User LBA eeeeeeee LLL CHS ffffff.g.hhhh PLP CHS iiiiii.j.kkkk"
              "Remaining Transfer Length llllllll"
    
           or
    
              "Next System LBA eeeeeeee LLL CHS ffffff.g.hhhh PLP CHS iiiiii.j.kkkk"
              "Remaining Transfer Length llllllll"
    
           where
    
              aaaaaaaa is the Diagnostic Error Code
    
              c is the status returned by the R/W subsystem
    
                    0 = R/W request completed successfully with error recovery
                    1 = R/W request completed successfully (no error recovery performed)
                    2 = R/W request failed
    
              dddddddd is the error code returned by the R/W subsystem
    
              eeeeeeee is the Disk Logical Block Address of the sector in error
    
              ffffff is the Logical Cylinder Address of the sector in error
    
              g is the Logical Head Address of the sector in error
    
              hhhh is the Logical Sector Address of the sector in error
    
              iiiiii is the Physical Cylinder Address of the sector in error
    
              j is the Logical Head Address of the sector in error
    
              kkkk is the Physical Sector Address of the sector in error
    
              llllllll is the number of sectors remaining to be read or written
    
        If the Verbose Formatted ASCII Data Output Mode is selected, the Verbose Mode option
        bits will enable the following data to be output when set.
    
           Bit 0:      Enables the R/W Status and R/W Error to be displayed
           Bit 1:      Enable the Next Address to be displayed
           Bit 2:      Enables the Track Position and Track Follow Offset to be displayed
           Bit 3:      Enables the Target Address to be displayed
           Bit 4:      Enables the Recovery Status to be displayed
           Bit 5:      Enables the Fault Status to be displayed
           Bit 6:      Enables the Elapsed Time to be displayed
           Bits 31-7:  NA
    
        If Bit 0 is set, the R/W Status and R/W Error will be displayed even if no error
        occurred.  The data displayed will be formatted as shown above.
    
        If Bit 1 is set, the Next Address will be displayed even if no error occurred.  The
        data displayed will be formatted as shown above.
    
        If Bit 2 is set, the Track Position and Track Follow Offset will be displayed as
        follows.
    
              "Read Position, Persistent Offset m.m% Total Offset n.n%"          or
              "Write Position, Persistent Offset m.m% Total Offset n.n%"         or
              "Write Header Position, Persistent Offset m.m% Total Offset n.n%"
    
           where
    
              m.m is the Persistent Track Follow Offset in units of percentage of track width
    
              n.n is the Total Track Follow Offset in units of percentage of track width
    
        If Bit 3 is set, the Target Address will be displayed as follows.
    
              "Target User LBA pppppppp LLL CHS qqqqqq.r.ssss PLP CHS tttttt.u.vvvv"
              "Starting Transfer Length wwwwwwww"
    
           or
    
              "Target System LBA pppppppp LLL CHS qqqqqq.r.ssss PLP CHS tttttt.u.vvvv"
              "Starting Transfer Length wwwwwwww"
    
           where
    
              pppppppp is the starting Disk Logical Block Address
    
              qqqqqq is the starting Logical Cylinder Address
    
              r is the starting Logical Head Address
    
              ssss is the starting Logical Sector Address
    
              tttttt is the starting Physical Cylinder Address
    
              u is the starting Logical Head Address
    
              vvvv is the starting Physical Sector Address
    
              wwwwwwww is the starting Transfer Length
    
        If Bit 4 is set, the Recovery Status will be displayed as follows.
    
              "Recovered User LBA AAAAAAAA LLL CHS BBBBBB.C.DDDD PLP CHS EEEEEE.F.GGGG"
              "Recovery Flags HHHH Count II"
    
           or
    
              "Recovered System LBA AAAAAAAA LLL CHS BBBBBB.C.DDDD PLP CHS EEEEEE.F.GGGG"
              "Recovery Flags HHHH Count II"
    
           where
    
              AAAAAAAA is the Disk Logical Block Address of the last recovered sector
    
              BBBBBB is the Logical Cylinder Address of the last recovered sector
    
              C is the Logical Head Address of the last recovered sector
    
              DDDD is the Logical Sector Address of the last recovered sector
    
              EEEEEE is the Physical Cylinder Address of the last recovered sector
    
              F is the Logical Head Address of the last recovered sector
    
              GGGG is the Physical Sector Address of the last recovered sector
    
              HHHH are the Recovery Flags reported by the Read/Write code
    
              II is the Recovery Count reported by the Read/Write code
    
        If Bit 5 is set, the Fault Status will be displayed as follows.
    
              "Drive Fault Status JJJJ Preamp Fault Status KKKK"
    
           where
    
              JJJJ is the Drive Fault Status reported by the Read/Write code
    
              KKKK is the Preamp Fault Status reported by the Read/Write code
    
        If Bit 6 is set, the Elapsed Time for the read/write operation will be displayed.
<a name="ELAPSED_TIME"></a>
    
       "Elapsed Time a mins b secs"  or
       "Elapsed Time b.c secs"       or
       "Elapsed Time c.d msecs"
    
    where
    
       a is minutes
       b is seconds
       c is milliseconds
       d is microseconds
    
    

  <b><i><u>Examples:</u></i></b>
    Example #1:
       To read a single LBA
       (in this case LBA 51237)

          F3 A>R51237

    Example #2:
       To read multiple LBAs
       (in this case LBAs 51237 to 51247)

          F3 A>R51237,11

    Example #3:
       To read all of the LBAs remaining on the track containing the target LBA
       (in this case all LBAs remaining on the cylinder that contains LBA 51237)

          F3 A>S51237
          F3 A>R

    Example #4:
       To read all of the LBAs remaining on the track containing the target LBA
       and continue on error
       (in this case all LBAs remaining on the cylinder that contains LBA 51237)

       Note: An error message will be displayed for each LBA in error.

          F3 A>S51237
          F3 A>R,,,1

    Example #5:
       To read all of the LBAs in the test space and continue on error

       Note: The Test Space is selected by the all level 'A' command.  An error
       message will be displayed for each LBA in error.

          F3 A>R,,,11

    Example #6:
       To read a single system LBA
       (in this case system LBA 1237)

          F3 A>R1237,,,20

    Example #7:
       To read multiple system LBAs
       (in this case system LBAs 1237 to 1247)

          F3 A>R1237,11,,20

    Example #8:
       To read all of the LBAs remaining on the track containing the target system LBA
       (in this case all LBAs remaining on the cylinder that contains LBA 1237)

          F3 A>S1237,,,,,1
          F3 A>R,,,20

    Example #9:
       To read a single LBA to a specific sector offset in the diagnostic read buffer
       (in this case LBA 51237 to the sector offset of 5 in the diagnostic read buffer)

          F3 2>AF,5
          F3 A>R51237,,,4

    Example #10:
       To rotate the buffer sector offset by 1 and read a single LBA to the rotated sector
       offset in the diagnostic read buffer
       (This example assumes user ran the Example #9 above right before this example,
        in this case LBA 51238 to the sector offset of 6 in the diagnostic read buffer)

          F3 A>R51238,,,4

  <b><i><u>Revision History:</u></i></b>
<a name="READ_LBA_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0001.0001   Eliminated the Enable ZAP Updates and Enable Track Skipping option.
    0001.0002   Modified to read only the LBAs remaining on the track containing the
                target LBA, if the LBA and Transfer Length are not entered by the user.
    0001.0003   Added new Rotate Buffer Sector Offset option to the bit 2 of the parameter 3.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="READ_LONG_OR_SYSTEM_CHS_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Read Long CHS or Read System CHS"></a><hr align=left width="75%"><b> Read Long CHS or Read System CHS (Level 2 'r')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command performs either a read long of the specified sectors or a System Area
    read starting at the specified sector on the target track for the specified number
    of sectors.  For a read long operation, the data and ECC bytes will be read into
    the Diagnostic Read Buffer.  For a System Area read, the data will be read into
    the Diagnostic Read Buffer.

  <b><i><u>Quick Help:</u></i></b>
<a name="READ_LONG_OR_SYSTEM_CHS_QUICK_HELP"></a>
    "RdLongOrSystemChs, r[LongSec],[LongSecsOrSysSec],[SysSecs],[LongPhySecOpt],[LongOpts],[SysOpts]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="READ_LONG_OR_SYSTEM_CHS_PARM"></a>
     0 - Read Long Starting Logical or Physical Sector Address.
    
         If this parameter is entered, a Read Long operation will be performed starting
         at the sector address specified by this parameter.  If any value is entered for
         Parameter 3, this parameter contains a physical sector address, else it contains
         a User Area logical sector address.
    
         If this parameter is not entered, a System Area Read operation will be performed.
    
           Type:    Unsigned 16-bit value
    
           Range:   0 to maximum logical or physical sector address on the target track
    
           Default: none
    
     1 - Read Long Transfer Length / System Area Read Starting Logical Sector Address.
    
         If Parameter 0 is entered, this parameter is the number of consecutive sectors
         to read long.
    
         If Parameter 0 is not entered, then this parameter contains the address of the
         first logical sector to be read on the System Area target track.
    
           Type:    Unsigned 32-bit value
    
           Range:   0 to 0xFFFFFFFF
    
           Default: For a Read Long operation, the default Transfer Length is 1.
    
                    For a System Area Read operation, the default starting Logical
                    Sector Address is 0.
    
     2 - System Area Read Transfer Length.
    
         If Parameter 0 is entered, this parameter is not used.
    
         If Parameter 0 is not entered, this parameter is the number of consecutive
         System Area sectors to read.
    
           Type:    Unsigned 32-bit value
    
           Range:   0 to 0xFFFFFFFF
    
           Default: If the System Area Logical Sector Address was entered and the Transfer
                    Length was not entered, then only the specified sector will be read.
    
                    If both the System Area Logical Sector Address and Transfer Length are
                    not entered, then the Transfer Length will be set based on the Test
                    Space that is selected.  If the Random Transfer Length option is
                    selected, a random value will be used that is less than or equal to
                    the number of sectors remaining on the track.  If the Random Transfer
                    Length option is not selected, the number of sectors remaining on the
                    track will be read.
    
                    If a Transfer Length is entered, it will be limited to the number of
                    sectors remaining on the track.
    
     3 - Read Long Physical Sector Address Flag.
    
         If Parameter 0 is entered and any value is entered for this parameter, then
         Parameter 0 specifies a physical sector address.  If Parameter 0 is entered
         and this parameter is not entered, then Parameter 0 specifies a User Area
         logical sector address.
    
         If Parameter 0 is not entered, then this parameter is not used.
    
           Type:    Unsigned 16-bit value
    
           Range:   0 to 0xFFFF
    
           Default: None
    
     4 - Read Long Options.
    
         If Parameter 0 is not entered, this parameter is not used.
    
         If Parameter 0 is entered, this parameter is a bit-significant value that specifies
         the following options for a Read Long operation.
    
           Bits 15-1:  not used.
    
           Bit 0:      Enable ECC Correction for Read Long.
       
                       If this bit is set ECC Correction will be enabled for the read
                       long operation, else ECC Correction will be disabled.
    
           Type:    Unsigned 16-bit value
    
           Range:   0 to 0xFFFF
    
           Default: 0 (ECC Correction disabled)
    
     5 - System Area Read Options.
    
         If Parameter 0 is entered, this parameter is not used.
    
         If Parameter 0 is not entered, this parameter is a bit-significant value that
         allows the user to select the following options for a System Area Read operation.
    
           Bits 15-5:  not used.
    
           Bit 4:      Read All Test Space Sectors.
    
                       If this bit is set, all of the System Area Sectors in the Test
                       Space will be read, else only the System Area Sectors specified
                       by Parameters 1 and 2 will be read.
    
           Bit 3:      not used.
     
           Bit 2:      Rotate Buffer Sector Offset.
     
                       If this bit is set, the Target Buffer Sector Offset will be rotated
                       by 1 prior to the execution of this diagnostic command.
                       This bit was originally added to help writing random data pattern
                       reduce execution time by not having to re-fill the diagnostic buffer
                       with new random data pattern, which takes great amount of time,
                       but just rotating the Target Buffer Sector Offset at every time this
                       diagnostic command is executed with this option set.
                       To see or change the current Targer Buffer Sector Offset, please refer
                       all Level 'A', Set Test Space, diagnostic command for detail how-to.
    
    <font color=red>
           Bit 1:      Enable Dynamic Sparing.
    
                       If this bit is set, sectors containing media defects that meet
                       the failure criteria will be spared.
    </font>
    
           Bit 0:      Continue On Error.
    
                       If this bit is set and an error occurs, the read operation will
                       continue and attempt to read all of the requested sectors.  Each
                       error encountered will be displayed.
    
           Type:    Unsigned 16-bit value
    
           Range:   0 to 0xFFFF
    
           Default: 0    (Read the requested sectors,
                          Disable Dynamic Sparing,
                          Stop On Error)
    

  <b><i><u>Output Data:</u></i></b>
<a name="RW_OP_STATUS_OUTPUT_DATA"></a>
        If an error occurred, the following information will be displayed.
    
              "DiagError aaaaaaaa R/W Status c R/W Error dddddddd"
    
           and
    
              "Next User LBA eeeeeeee LLL CHS ffffff.g.hhhh PLP CHS iiiiii.j.kkkk"
              "Remaining Transfer Length llllllll"
    
           or
    
              "Next System LBA eeeeeeee LLL CHS ffffff.g.hhhh PLP CHS iiiiii.j.kkkk"
              "Remaining Transfer Length llllllll"
    
           where
    
              aaaaaaaa is the Diagnostic Error Code
    
              c is the status returned by the R/W subsystem
    
                    0 = R/W request completed successfully with error recovery
                    1 = R/W request completed successfully (no error recovery performed)
                    2 = R/W request failed
    
              dddddddd is the error code returned by the R/W subsystem
    
              eeeeeeee is the Disk Logical Block Address of the sector in error
    
              ffffff is the Logical Cylinder Address of the sector in error
    
              g is the Logical Head Address of the sector in error
    
              hhhh is the Logical Sector Address of the sector in error
    
              iiiiii is the Physical Cylinder Address of the sector in error
    
              j is the Logical Head Address of the sector in error
    
              kkkk is the Physical Sector Address of the sector in error
    
              llllllll is the number of sectors remaining to be read or written
    
        If the Verbose Formatted ASCII Data Output Mode is selected, the Verbose Mode option
        bits will enable the following data to be output when set.
    
           Bit 0:      Enables the R/W Status and R/W Error to be displayed
           Bit 1:      Enable the Next Address to be displayed
           Bit 2:      Enables the Track Position and Track Follow Offset to be displayed
           Bit 3:      Enables the Target Address to be displayed
           Bit 4:      Enables the Recovery Status to be displayed
           Bit 5:      Enables the Fault Status to be displayed
           Bit 6:      Enables the Elapsed Time to be displayed
           Bits 31-7:  NA
    
        If Bit 0 is set, the R/W Status and R/W Error will be displayed even if no error
        occurred.  The data displayed will be formatted as shown above.
    
        If Bit 1 is set, the Next Address will be displayed even if no error occurred.  The
        data displayed will be formatted as shown above.
    
        If Bit 2 is set, the Track Position and Track Follow Offset will be displayed as
        follows.
    
              "Read Position, Persistent Offset m.m% Total Offset n.n%"          or
              "Write Position, Persistent Offset m.m% Total Offset n.n%"         or
              "Write Header Position, Persistent Offset m.m% Total Offset n.n%"
    
           where
    
              m.m is the Persistent Track Follow Offset in units of percentage of track width
    
              n.n is the Total Track Follow Offset in units of percentage of track width
    
        If Bit 3 is set, the Target Address will be displayed as follows.
    
              "Target User LBA pppppppp LLL CHS qqqqqq.r.ssss PLP CHS tttttt.u.vvvv"
              "Starting Transfer Length wwwwwwww"
    
           or
    
              "Target System LBA pppppppp LLL CHS qqqqqq.r.ssss PLP CHS tttttt.u.vvvv"
              "Starting Transfer Length wwwwwwww"
    
           where
    
              pppppppp is the starting Disk Logical Block Address
    
              qqqqqq is the starting Logical Cylinder Address
    
              r is the starting Logical Head Address
    
              ssss is the starting Logical Sector Address
    
              tttttt is the starting Physical Cylinder Address
    
              u is the starting Logical Head Address
    
              vvvv is the starting Physical Sector Address
    
              wwwwwwww is the starting Transfer Length
    
        If Bit 4 is set, the Recovery Status will be displayed as follows.
    
              "Recovered User LBA AAAAAAAA LLL CHS BBBBBB.C.DDDD PLP CHS EEEEEE.F.GGGG"
              "Recovery Flags HHHH Count II"
    
           or
    
              "Recovered System LBA AAAAAAAA LLL CHS BBBBBB.C.DDDD PLP CHS EEEEEE.F.GGGG"
              "Recovery Flags HHHH Count II"
    
           where
    
              AAAAAAAA is the Disk Logical Block Address of the last recovered sector
    
              BBBBBB is the Logical Cylinder Address of the last recovered sector
    
              C is the Logical Head Address of the last recovered sector
    
              DDDD is the Logical Sector Address of the last recovered sector
    
              EEEEEE is the Physical Cylinder Address of the last recovered sector
    
              F is the Logical Head Address of the last recovered sector
    
              GGGG is the Physical Sector Address of the last recovered sector
    
              HHHH are the Recovery Flags reported by the Read/Write code
    
              II is the Recovery Count reported by the Read/Write code
    
        If Bit 5 is set, the Fault Status will be displayed as follows.
    
              "Drive Fault Status JJJJ Preamp Fault Status KKKK"
    
           where
    
              JJJJ is the Drive Fault Status reported by the Read/Write code
    
              KKKK is the Preamp Fault Status reported by the Read/Write code
    
        If Bit 6 is set, the Elapsed Time for the read/write operation will be displayed.
<a name="ELAPSED_TIME"></a>
    
       "Elapsed Time a mins b secs"  or
       "Elapsed Time b.c secs"       or
       "Elapsed Time c.d msecs"
    
    where
    
       a is minutes
       b is seconds
       c is milliseconds
       d is microseconds
    
    

  <b><i><u>Examples:</u></i></b>
    Example #1:
       To read a single logical system sector
       (in this case logical sector 23 on logical system cylinder 45 head 1)

          F3 2>A0
          F3 2>S45,1,,,,1
          F3 2>r,23

    Example #2:
       To read multiple logical system sectors
       (in this case logical sectors 23 to 26 on logical system cylinder 45 head 1)

          F3 2>A0
          F3 2>S45,1,,,,1
          F3 2>r,23,4

    Example #3:
       To read all of the logical system sectors on a track
       (in this case all logical sectors on logical system cylinder 45 head 1)

          F3 2>A0
          F3 2>S45,1,,,,1
          F3 2>r

    Example #4:
       To read all of the logical system sectors on multiple tracks
       (in this case all logical sectors on logical system cylinders 45 to 49 head 0)

       Note: You must seek to the track before the first one to be read.

          F3 2>A3
          F3 2>S44,0,,,,1
          F3 2>L,5
          F3 2>r

    Example #5:
       To read all of the logical system sectors on a track and continue on error
       (in this case all logical sectors on logical cylinder 45 head 0)

       Note: An error message will be displayed for each sector in error.

          F3 2>A0
          F3 2>S45,0,,,,1
          F3 2>r,,,,,1

    Example #6:
       To read all of the logical system sectors in the test space and continue on error

       Note: The Test Space is selected by the all level 'A' command.  An error
       message will be displayed for each sector in error.

          F3 2>r,,,,,11

    Example #7:
       To read long a single logical sector
       (in this case logical sector 32 on logical cylinder 54 head 0)

          F3 2>A0
          F3 2>S54,0
          F3 2>r32

    Example #8:
       To read long multiple logical sectors
       (in this case logical sectors 32 to 33 on logical cylinder 54 head 0)

          F3 2>A0
          F3 2>S54,0
          F3 2>r32,2

    Example #9:
       To read long a single physical sector
       (in this case physical sector 32 on physical cylinder 54 head 0)

          F3 2>A0
          F3 2>s54,0,22
          F3 2>r32,,,1

    Example #10:
       To read long multiple physical sectors
       (in this case physical sectors 32 to 33 on physical cylinder 54 head 0)

          F3 2>A0
          F3 2>s54,0,22
          F3 2>r32,2,,1

    Example #11:
       To read a single logical system sector to a specific sector offset in the diagnostic
       read buffer
       (in this case logical sector 23 on logical system cylinder 45 head 1,
        to the sector offset of 5 in the diagnostic read buffer)

          F3 2>A0
          F3 2>AF,5
          F3 2>S45,1,,,,1
          F3 2>r,23

    Example #12:
       To rotate the buffer sector offset by 1 and read a single logical system sector to the
       rotated sector offset in the diagnostic read buffer
       (This example assumes user ran the Example #11 above right before this example,
        in this case logical sector 24 on logical system cylinder 45 head 1,
        to the sector offset of 6 in the diagnostic read buffer)

          F3 2>r,24,,,,4

  <b><i><u>Revision History:</u></i></b>
<a name="READ_LONG_OR_SYSTEM_CHS_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0001.0001   Eliminated the Enable ZAP Updates and Enable Track Skipping option.
    0001.0002   Added new Rotate Buffer Sector Offset option to the bit 2 of the parameter 5.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="READ_NON_VOLATILE_ADAPTIVE_PARMS_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Read Non-Volatile Adaptive Parameters"></a><hr align=left width="75%"><b> Read Non-Volatile Adaptive Parameters (Level 7 'r' and Level T 'R')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command reads the specified adaptive parameters from non-volatile memory.

  <b><i><u>Quick Help:</u></i></b>
<a name="READ_NON_VOLATILE_ADAPTIVE_PARMS_QUICK_HELP"></a>
       Level 7
    "RdNonVolatileAdaptiveParms, r[Opts]";
       Level T
    "RdNonVolatileAdaptiveParms, R[Opts]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="READ_NON_VOLATILE_ADAPTIVE_PARMS_PARM"></a>
     0 - Read Adaptive Parameter Options.
    
         This parameter is a bit significant value that specifies which adaptive
         parameters are to be read from non-volatile memory.
    
           Bits 31-3: not used
    
    <font color=red>
           Bit 2: Read SAP.
    
                  If this bit is set the Servo Adaptive Parameters (SAP) will be read
                  from non-volatile memory.
    </font>
    
           Bit 1: Read RAP.
    
                  If this bit is set the Read/Write Adaptive Parameters (RAP) will be
                  read from non-volatile memory.
    
    <font color=red>
           Bit 0: Read CAP.
    
                  If this bit is set the Controller Adaptive Parameters (CAP) will be
                  read from non-volatile memory.
    </font>
    
           Type:    Unsigned 32-bit value
    
           Range:   0 to 0xffffffff,
    
           Default: 0x7 (Read the SAP, RAP and CAP)
    

  <b><i><u>Output Data:</u></i></b>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    

  <b><i><u>Revision History:</u></i></b>
<a name="READ_NON_VOLATILE_ADAPTIVE_PARMS_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="READ_PERIPHERAL_REG_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Read Peripheral Register - channel or preamp"></a><hr align=left width="75%"><b> Read Peripheral Register - channel or preamp (Level 7 't')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command reads and displays the contents from the specified register(s) from the
    specified peripheral device.

  <b><i><u>Quick Help:</u></i></b>
<a name="READ_PERIPHERAL_REG_QUICK_HELP"></a>
    "RdPeripheralReg, t[OpType],[RegAddr],[NumRegs],[RegMask],[RegPagAddr]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="READ_PERIPHERAL_REG_PARM"></a>
    0 - Operation Type.
    
        This parameter selects the type of peripheral device operation to be performed.
    
             0 = Read Preamp Register
             1 = Read Read Channel Register
    
          Type:    Unsigned 8-bit value
    
          Range:   0 or 1
    
          Default: 1 (Read Read Channel Register)
    
    1 - Register Address Offset.
    
        This parameter specifies the address offset of the peripheral register to be
        read.  If the peripheral registers has the page address mode, this parameter
        specifies the address offset in the page, which has been specified by the
        parameter 1, Register Page Address. Otherwise, it simply specifies the register
        address offset in the whole range of the register address.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: 0
    
    2 - Number of Registers to Read.
    
        This parameter specifies the number of consecutive peripheral registers to read
        and display.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: 1
    
    3 - Register Mask.
    
        This parameter specifies the bit mask with which the specified field of the
        register value is to be read from the register, when Parameter 3, Number of
        Registers to Read, is equal to one.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: 0xFFFF
    
    4 - Register Page Address.
    
        This parameter specifies the page address of the peripheral register to be
        read.  If the peripheral registers do not have page address in its address
        mode, this input parameter is not needed and its defaul value does not affect
        the read from the peripheral register.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: 0
    

  <b><i><u>Output Data:</u></i></b>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
<a name="RD_PREAMP_REG_DATA"></a>
    If a single Preamp register was read, the following information will be displayed.
    
          "Preamp Reg cc = dd"
    
       where
    
          cc is the address of the register that was read
    
          dd is the value that was read from the register
    
    If multiple Preamp registers were read, the following information will be displayed.
    
          "Preamp"
          "    0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F"
          "cc: dd dd dd dd dd dd dd dd dd dd dd dd dd dd dd dd"
    
       where
    
          cc is the address of the first register in the row
    
          dd is the value that was read from the register
    
<a name="RD_READ_CHANNEL_REG_DATA"></a>
    If a single Read Channel register was read, the following information will be displayed.
    
          "Read Channel Reg cccc = dddd"
    
       where
    
          cccc is the address of the register that was read
    
          dddd is the value that was read from the register
    
    If multiple Read Channel registers were read, the following information will be
    displayed.
    
        "Read Channel"
        "      0    1    2    3    4    5    6    7    8    A    B    C    D    E    F"
        "cccc: dddd dddd dddd dddd dddd dddd dddd dddd dddd dddd dddd dddd dddd dddd dddd"
    
       where
    
          cccc is the address of the first register in the row
    
          dddd is the value that was read from the register
    

  <b><i><u>Revision History:</u></i></b>
<a name="READ_PERIPHERAL_REG_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="READ_SERVO_RAM_AT_ADDR_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Read Servo RAM at Address"></a><hr align=left width="75%"><b> Read Servo RAM at Address (Level 5 'R')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    The Read Servo RAM at Address command reads and displays the data contained in the
    specified Servo RAM locations.

  <b><i><u>Quick Help:</u></i></b>
<a name="READ_SERVO_RAM_AT_ADDR_QUICK_HELP"></a>
    "RdServoRamAtAddr, R[Addr],[NumBytes]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="READ_SERVO_RAM_AT_ADDR_PARM"></a>
    0 - Servo RAM Address.
      
        This parameter specifies the address of the first servo RAM byte to be read.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: None
    
    1 - Number of Bytes.
    
        This parameter specifies the number of servo RAM bytes to be read and displayed.
    
          Type:    Unsigned 8-bit value
    
          Range:   1, 2 and 4 are the allowed values
    
          Default: 2
    

  <b><i><u>Output Data:</u></i></b>
<a name="SERVO_RAM_DATA_AT_ADDR"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
        If no error occurred, the following information will be displayed.
    
              "Servo Data RAM Addr cccccccc RAM Data dd"            or
              "Servo Data RAM Addr cccccccc RAM Data eeee"          or
              "Servo Data RAM Addr cccccccc RAM Data ffffffff"
    
           where
    
              cccccccc is the address of the first servo RAM byte that was read
    
              dd is an 8-bit value that was read from servo RAM
    
              eeee is a 16-bit value that was read from servo RAM
    
              ffffffff is a 32-bit value that was read from servo RAM
    

  <b><i><u>Revision History:</u></i></b>
<a name="READ_SERVO_RAM_AT_ADDR_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="READ_SERVO_RAM_AT_INDEX_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Read Servo RAM at Index"></a><hr align=left width="75%"><b> Read Servo RAM at Index (Level 5 'r')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    The Read Servo RAM at Index command reads and displays data contained in Servo RAM.
    The base address of the Servo RAM location to be read is retrieved from the Servo Symbol
    Table at the specified index and an optional byte offset is added to it.

  <b><i><u>Quick Help:</u></i></b>
<a name="READ_SERVO_RAM_AT_INDEX_QUICK_HELP"></a>
    "RdServoRamAtIndex, r[Index],[NumBytes],[ByteOffset]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="READ_SERVO_RAM_AT_INDEX_PARM"></a>
    0 - Servo Symbol Table Index.
    
        This parameter specifies the index of the Servo Symbol Table entry that contains
        the base address of the Servo RAM location to be read.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: None
    
    1 - Number of Bytes.
    
        This parameter specifies the number of servo RAM bytes to be read and displayed.
    
          Type:    Unsigned 8-bit value
    
          Range:   1, 2 and 4 are the allowed values
    
          Default: 2
    
    2 - Byte offset from base address.
    
        This parameter is an optional byte offset which will be added to the address of the
        servo RAM location to be read.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: 0
    

  <b><i><u>Output Data:</u></i></b>
<a name="SERVO_RAM_DATA_AT_INDEX"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
        If no error occurred, the following information will be displayed.
    
              "Servo Symbol Table Index cccc RAM Data dd"           or
              "Servo Symbol Table Index cccc RAM Data eeee"         or
              "Servo Symbol Table Index cccc RAM Data ffffffff"
    
           where
    
              cccccccc is the index of the Servo Symbol Table entry that contains the address
              of the Servo RAM location to be read.
    
              dd is an 8-bit value that was read from servo RAM
    
              eeee is a 16-bit value that was read from servo RAM
    
              ffffffff is a 32-bit value that was read from servo RAM
    

  <b><i><u>Revision History:</u></i></b>
<a name="READ_SERVO_RAM_AT_INDEX_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="READ_SERVO_SYMBOL_TABLE_AT_INDEX_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Read Servo Symbol Table at Index"></a><hr align=left width="75%"><b> Read Servo Symbol Table at Index (Level 5 'i')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    The Read Servo Symbol Table at Index command reads and displays the Servo Symbol Table
    entry at the specified index.

  <b><i><u>Quick Help:</u></i></b>
<a name="READ_SERVO_SYMBOL_TABLE_AT_INDEX_QUICK_HELP"></a>
    "RdServoSymbolTableAtIndex, i[Index]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="READ_SERVO_SYMBOL_TABLE_AT_INDEX_PARM"></a>
    0 - Servo Symbol Table Index.
    
        This parameter specifies the index of the Servo Symbol Table entry to be read.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: None
    

  <b><i><u>Output Data:</u></i></b>
<a name="SERVO_SYMBOL_TABLE_DATA_AT_INDEX"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
        If no error occurred, the follwing information will be displayed.
    
              "Servo Symbol Table Index cccc Value dddddddd"
    
           where
    
              cccccccc is the index of the Servo Symbol Table entry that was read
    
              dddddddd is the data that was read from the Servo Symbol Table
    

  <b><i><u>Revision History:</u></i></b>
<a name="READ_SERVO_SYMBOL_TABLE_AT_INDEX_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="READ_SYSTEM_CHS_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Read System CHS"></a><hr align=left width="75%"><b> Read System CHS (Level F 'r')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command reads data from the disk starting at the specified sector on the System
    Area target track for the specified number of sectors.  The data is read into the
    Diagnostic Read Buffer.

  <b><i><u>Quick Help:</u></i></b>
<a name="READ_SYSTEM_CHS_QUICK_HELP"></a>
    "RdSystemChs, r[LogSec],[NumSecs],[Opts]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="READ_SYSTEM_CHS_PARM"></a>
     0 - System Area Logical Sector Address.
    
         This parameter contains the System Area logical sector address of the first sector
         to read.
    
           Type:    Unsigned 16-bit value
    
           Range:   0 to maximum logical sector address on the target track
    
           Default: 0
    
     1 - Transfer Length.
    
         This parameter specifies the number of consecutive sectors to read.
    
           Type:    Unsigned 32-bit value
    
           Range:   0 to 0xFFFFFFFF
    
           Default: If the Sector Address was entered and the Transfer Length was not entered,
                    then only the specified sector will be read.
    
                    If both the Sector Address and Transfer Length are not entered, then the
                    Transfer Length will be set based on the Test Space that is selected.
                    If the Random Transfer Length option is selected, a random value will be
                    used that is less than or equal to the number of sectors remaining on the
                    track.  If the Random Transfer Length option is not selected, the number
                    of sectors remaining on the track will be read.
    
                    If a Transfer Length is entered, it will be limited to the number of
                    sectors remaining on the track.
    
     2 - Options.
    
         This parameter is a bit-significant value that allows the user to select the
         following options.
    
           Bits 15-5:  not used.
    
           Bit 4:      Read All Test Space Sectors.
    
                       If this bit is set, all of the sectors in the Test Space will be
                       read, else only the sectors specified by Parameters 0 and 1 will
                       be read.
    
           Bit 3:      not used.
     
           Bit 2:      Rotate Buffer Sector Offset.
     
                       If this bit is set, the Target Buffer Sector Offset will be rotated
                       by 1 prior to the execution of this diagnostic command.
                       This bit was originally added to help writing random data pattern
                       reduce execution time by not having to re-fill the diagnostic buffer
                       with new random data pattern, which takes great amount of time,
                       but just rotating the Target Buffer Sector Offset at every time this
                       diagnostic command is executed with this option set.
                       To see or change the current Targer Buffer Sector Offset, please refer
                       all Level 'A', Set Test Space, diagnostic command for detail how-to.
    
    <font color=red>
           Bit 1:      Enable Dynamic Sparing.
    
                       If this bit is set, sectors containing media defects that meet
                       the failure criteria will be spared.
    </font>
    
           Bit 0:      Continue On Error.
     
                       If this bit is set and an error occurs, the read operation will
                       continue and attempt to read all of the requested sectors.  Each
                       error encountered will be displayed.
    
           Type:    Unsigned 16-bit value
    
           Range:   0 to 0xFFFF
    
           Default: 0    (Read the requested sectors,
                          Disable Dynamic Sparing,
                          Stop On Error)
    

  <b><i><u>Output Data:</u></i></b>
<a name="RW_OP_STATUS_OUTPUT_DATA"></a>
        If an error occurred, the following information will be displayed.
    
              "DiagError aaaaaaaa R/W Status c R/W Error dddddddd"
    
           and
    
              "Next User LBA eeeeeeee LLL CHS ffffff.g.hhhh PLP CHS iiiiii.j.kkkk"
              "Remaining Transfer Length llllllll"
    
           or
    
              "Next System LBA eeeeeeee LLL CHS ffffff.g.hhhh PLP CHS iiiiii.j.kkkk"
              "Remaining Transfer Length llllllll"
    
           where
    
              aaaaaaaa is the Diagnostic Error Code
    
              c is the status returned by the R/W subsystem
    
                    0 = R/W request completed successfully with error recovery
                    1 = R/W request completed successfully (no error recovery performed)
                    2 = R/W request failed
    
              dddddddd is the error code returned by the R/W subsystem
    
              eeeeeeee is the Disk Logical Block Address of the sector in error
    
              ffffff is the Logical Cylinder Address of the sector in error
    
              g is the Logical Head Address of the sector in error
    
              hhhh is the Logical Sector Address of the sector in error
    
              iiiiii is the Physical Cylinder Address of the sector in error
    
              j is the Logical Head Address of the sector in error
    
              kkkk is the Physical Sector Address of the sector in error
    
              llllllll is the number of sectors remaining to be read or written
    
        If the Verbose Formatted ASCII Data Output Mode is selected, the Verbose Mode option
        bits will enable the following data to be output when set.
    
           Bit 0:      Enables the R/W Status and R/W Error to be displayed
           Bit 1:      Enable the Next Address to be displayed
           Bit 2:      Enables the Track Position and Track Follow Offset to be displayed
           Bit 3:      Enables the Target Address to be displayed
           Bit 4:      Enables the Recovery Status to be displayed
           Bit 5:      Enables the Fault Status to be displayed
           Bit 6:      Enables the Elapsed Time to be displayed
           Bits 31-7:  NA
    
        If Bit 0 is set, the R/W Status and R/W Error will be displayed even if no error
        occurred.  The data displayed will be formatted as shown above.
    
        If Bit 1 is set, the Next Address will be displayed even if no error occurred.  The
        data displayed will be formatted as shown above.
    
        If Bit 2 is set, the Track Position and Track Follow Offset will be displayed as
        follows.
    
              "Read Position, Persistent Offset m.m% Total Offset n.n%"          or
              "Write Position, Persistent Offset m.m% Total Offset n.n%"         or
              "Write Header Position, Persistent Offset m.m% Total Offset n.n%"
    
           where
    
              m.m is the Persistent Track Follow Offset in units of percentage of track width
    
              n.n is the Total Track Follow Offset in units of percentage of track width
    
        If Bit 3 is set, the Target Address will be displayed as follows.
    
              "Target User LBA pppppppp LLL CHS qqqqqq.r.ssss PLP CHS tttttt.u.vvvv"
              "Starting Transfer Length wwwwwwww"
    
           or
    
              "Target System LBA pppppppp LLL CHS qqqqqq.r.ssss PLP CHS tttttt.u.vvvv"
              "Starting Transfer Length wwwwwwww"
    
           where
    
              pppppppp is the starting Disk Logical Block Address
    
              qqqqqq is the starting Logical Cylinder Address
    
              r is the starting Logical Head Address
    
              ssss is the starting Logical Sector Address
    
              tttttt is the starting Physical Cylinder Address
    
              u is the starting Logical Head Address
    
              vvvv is the starting Physical Sector Address
    
              wwwwwwww is the starting Transfer Length
    
        If Bit 4 is set, the Recovery Status will be displayed as follows.
    
              "Recovered User LBA AAAAAAAA LLL CHS BBBBBB.C.DDDD PLP CHS EEEEEE.F.GGGG"
              "Recovery Flags HHHH Count II"
    
           or
    
              "Recovered System LBA AAAAAAAA LLL CHS BBBBBB.C.DDDD PLP CHS EEEEEE.F.GGGG"
              "Recovery Flags HHHH Count II"
    
           where
    
              AAAAAAAA is the Disk Logical Block Address of the last recovered sector
    
              BBBBBB is the Logical Cylinder Address of the last recovered sector
    
              C is the Logical Head Address of the last recovered sector
    
              DDDD is the Logical Sector Address of the last recovered sector
    
              EEEEEE is the Physical Cylinder Address of the last recovered sector
    
              F is the Logical Head Address of the last recovered sector
    
              GGGG is the Physical Sector Address of the last recovered sector
    
              HHHH are the Recovery Flags reported by the Read/Write code
    
              II is the Recovery Count reported by the Read/Write code
    
        If Bit 5 is set, the Fault Status will be displayed as follows.
    
              "Drive Fault Status JJJJ Preamp Fault Status KKKK"
    
           where
    
              JJJJ is the Drive Fault Status reported by the Read/Write code
    
              KKKK is the Preamp Fault Status reported by the Read/Write code
    
        If Bit 6 is set, the Elapsed Time for the read/write operation will be displayed.
<a name="ELAPSED_TIME"></a>
    
       "Elapsed Time a mins b secs"  or
       "Elapsed Time b.c secs"       or
       "Elapsed Time c.d msecs"
    
    where
    
       a is minutes
       b is seconds
       c is milliseconds
       d is microseconds
    
    

  <b><i><u>Examples:</u></i></b>
    Example #1:
       To read a single logical system sector
       (in this case logical sector 23 on logical system cylinder 45 head 1)

          F3 2>A0
          F3 2>S45,1,,,,1
          F3 2>/F
          F3 F>r23

    Example #2:
       To read multiple logical system sectors
       (in this case logical sectors 23 to 26 on logical system cylinder 45 head 1)

          F3 2>A0
          F3 2>S45,1,,,,1
          F3 2>/F
          F3 F>r23,4

    Example #3:
       To read all of the logical system sectors on a track
       (in this case all logical sectors on logical system cylinder 45 head 1)

          F3 2>A0
          F3 2>S45,1,,,,1
          F3 2>/F
          F3 F>r

    Example #4:
       To read all of the logical system sectors on multiple tracks
       (in this case all logical sectors on logical system cylinders 45 to 49 head 0)

       Note: You must seek to the track before the first one to be read.

          F3 2>A3
          F3 2>S44,0,,,,1
          F3 2>/F
          F3 F>L,5
          F3 F>r

    Example #5:
       To read all of the logical system sectors on a track and continue on error
       (in this case all logical sectors on logical cylinder 45 head 0)

       Note: An error message will be displayed for each sector in error.

          F3 2>A0
          F3 2>S45,0,,,,1
          F3 2>/F
          F3 F>r,,1

    Example #6:
       To read all of the logical system sectors in the test space and continue on error

       Note: The Test Space is selected by the all level 'A' command.  An error
       message will be displayed for each sector in error.

          F3 F>r,,11

    Example #7:
       To read a single logical system sector to a specific sector offset in the diagnostic
       read buffer
       (in this case logical sector 23 on logical system cylinder 45 head 1,
        to the sector offset of 5 in the diagnostic read buffer)

          F3 2>A0
          F3 2>AF,5
          F3 2>S45,1,,,,1
          F3 2>/F
          F3 F>r23

    Example #8:
       To rotate the buffer sector offset by 1 and read a single logical system sector to the
       rotated sector offset in the diagnostic read buffer
       (This example assumes user ran the Example #7 above right before this example,
        in this case logical sector 24 on logical system cylinder 45 head 1,
        to the sector offset of 6 in the diagnostic read buffer)

          F3 F>r24,,4

  <b><i><u>Revision History:</u></i></b>
<a name="READ_SYSTEM_CHS_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0001.0001   Eliminated the Enable ZAP Updates and Enable Track Skipping option.
    0001.0002   Added new Rotate Buffer Sector Offset option to the bit 2 of the parameter 2.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="READ_UNLOCK_DDR_BUFFER_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Read / Unlock DDR Buffer"></a><hr align=left width="75%"><b> Read / Unlock DDR Buffer (Level 5 'D')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command is used to either read the entire DDR data from DDR buffer, or unlock DDR
    buffer to resume DDR data collection.

  <b><i><u>Quick Help:</u></i></b>
<a name="READ_UNLOCK_DDR_BUFFER_QUICK_HELP"></a>
    "ReadUnlockDdrBuffer, B[OperateCode]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="READ_UNLOCK_DDR_BUFFER_PARM"></a>
    0 - Operate code to determine if this is a read or unlock command
    
       When this parameter is entered as the value of 0FFFFh, it is an Unlock DDR Buffer
       command. The purpose is to resume DDR data collection in servo.
    
       When this parameter is not entered or entered as a valid value other than 0FFFFh,
       it is a Read Entire DDR Data from DDR Buffer command.
    
          Type: Unsigned 16-bit value
    
          Range: 0 to 0xFFFF
    
          Default: 0.

  <b><i><u>Output Data:</u></i></b>
<a name="READ_UNLOCK_DDR_BUFFER_DATA"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
    
     When this is an Unlock DDR Buffer command, the result is
        DDR buffer is unlocked
    
     When this is a Read Entire DDR Buffer command, the result is
        DDR buffer locked: a
        Total Revs:        bbbbb
        Revs after Event:  ccccc
        Data per Servo:    ddddd
        Servos per Rev:    eeeee
         ffff gggg hhhh ...
         ...
         xxxx yyyy zzzz ...
    
        where
           a is either 0 or 1. 0 means DDR buffer is not locked and 1 means DDR buffer is locked.
           bbbbb is the total revs of data stored in DDR buffer (in decimal format)
           ccccc is the revs of data after the DDR event (in decimal format)
           ddddd is the number of DDR data per servo wedge (in decimal format)
           eeeee is the number of servo wedges per rev (in decimal format)
           ffff, gggg, hhhh, ... , xxxx, yyyy, and zzzz are autual DDR data (in hex format)
              The DDR data are displayed in the way that all DDR data from the same servo
              wedge are at the same line. So the total number of lines of actual DDR data =
              Total Revs (bbbbb) * Servos per Rev (eeee).

  <b><i><u>Revision History:</u></i></b>
<a name="READ_UNLOCK_DDR_BUFFER_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="READ_VERIFY_CHS_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Read Verify CHS"></a><hr align=left width="75%"><b> Read Verify CHS (Level 2 'V')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command reads data from the disk starting at the specified sector on the target
    track for the specified number of sectors.  The data is read into the Diagnostic Read
    Buffer and is compared to the data contained in the specified buffer.

  <b><i><u>Quick Help:</u></i></b>
<a name="READ_VERIFY_CHS_QUICK_HELP"></a>
    "RdVerifyChs, V[Sec],[NumSecs],[CompareBlk],[Opts]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="READ_VERIFY_CHS_PARM"></a>
     0 - Logical or Physical Sector Address.
    
         If Parameter 3 bit 5 is set, this parameter contains the physical sector address
         of the first sector to read, else this parameter contains the User Area logical
         sector address of the first sector to read.
    
           Type:    Unsigned 16-bit value
    
           Range:   0 to maximum logical or physical sector address on the target track
    
           Default: 0
    
     1 - Transfer Length.
    
         This parameter specifies the number of consecutive sectors to read.
    
           Type:    Unsigned 32-bit value
    
           Range:   0 to 0xFFFFFFFF
    
           Default: If the Sector Address was entered and the Transfer Length was not entered,
                    then only the specified sector will be read.
    
                    If both the Sector Address and Transfer Length are not entered, then the
                    Transfer Length will be set based on the Test Space that is selected.
                    If the Random Transfer Length option is selected, a random value will be
                    used that is less than or equal to the number of sectors remaining on the
                    track.  If the Random Transfer Length option is not selected, the number
                    of sectors remaining on the track will be read.
    
                    If a Transfer Length is entered, it will be limited to the number of
                    sectors remaining on the track.
    
    <font color=red>
     2 - Compare Buffer Block Number.
    
         This parameter specifies the number of the buffer block that contains the data to be
         compared to the data that is read.
    
           Type:    Unsigned 16-bit value
    
           Range:   0 to 0xFFFF
    
           Default: If a Compare Buffer Block Number is not specified, the data read will be
                    compared to the data contained in the Diagnostic Write Buffer.
    
    </font>
     3 - Options.
    
         This parameter is a bit-significant value that allows the user to select the
         following options.
    
           Bits 15-6:  not used.
    
           Bit 5:      Read and Verify Physical Sectors.
    
                       If this bit is set, Parameter 0 specifies a physical sector address,
                       else it specifies a User Area logical sector address.
    
           Bit 4:      Read All Test Space Sectors.
    
                       If this bit is set, all of the sectors in the Test Space will be
                       read, else only the System Area Sectors specified by Parameters 0
                       and 1 will be read.
    
           Bit 3:      not used.
     
           Bit 2:      Rotate Buffer Sector Offset.
     
                       If this bit is set, the Target Buffer Sector Offset will be rotated
                       by 1 prior to the execution of this diagnostic command.
                       This bit was originally added to help writing random data pattern
                       reduce execution time by not having to re-fill the diagnostic buffer
                       with new random data pattern, which takes great amount of time,
                       but just rotating the Target Buffer Sector Offset at every time this
                       diagnostic command is executed with this option set.
                       To see or change the current Targer Buffer Sector Offset, please refer
                       all Level 'A', Set Test Space, diagnostic command for detail how-to.
    
    <font color=red>
           Bit 1:      Enable Dynamic Sparing.
    
                       If this bit is set, sectors containing media defects that meet
                       the failure criteria will be spared.
    </font>
    
           Bit 0:      Continue On Error.
     
                       If this bit is set and an error occurs, the read operation will
                       continue and attempt to read all of the requested sectors.  Each
                       error encountered will be displayed.
    
           Type:    Unsigned 16-bit value
    
           Range:   0 to 0xFFFF
    
           Default: 0    (Read and Verify Logical User Area Sectors,
                          Read the requested sectors,
                          Disable Dynamic Sparing,
                          Stop On Error)
    

  <b><i><u>Output Data:</u></i></b>
<a name="RW_OP_STATUS_OUTPUT_DATA"></a>
        If an error occurred, the following information will be displayed.
    
              "DiagError aaaaaaaa R/W Status c R/W Error dddddddd"
    
           and
    
              "Next User LBA eeeeeeee LLL CHS ffffff.g.hhhh PLP CHS iiiiii.j.kkkk"
              "Remaining Transfer Length llllllll"
    
           or
    
              "Next System LBA eeeeeeee LLL CHS ffffff.g.hhhh PLP CHS iiiiii.j.kkkk"
              "Remaining Transfer Length llllllll"
    
           where
    
              aaaaaaaa is the Diagnostic Error Code
    
              c is the status returned by the R/W subsystem
    
                    0 = R/W request completed successfully with error recovery
                    1 = R/W request completed successfully (no error recovery performed)
                    2 = R/W request failed
    
              dddddddd is the error code returned by the R/W subsystem
    
              eeeeeeee is the Disk Logical Block Address of the sector in error
    
              ffffff is the Logical Cylinder Address of the sector in error
    
              g is the Logical Head Address of the sector in error
    
              hhhh is the Logical Sector Address of the sector in error
    
              iiiiii is the Physical Cylinder Address of the sector in error
    
              j is the Logical Head Address of the sector in error
    
              kkkk is the Physical Sector Address of the sector in error
    
              llllllll is the number of sectors remaining to be read or written
    
        If the Verbose Formatted ASCII Data Output Mode is selected, the Verbose Mode option
        bits will enable the following data to be output when set.
    
           Bit 0:      Enables the R/W Status and R/W Error to be displayed
           Bit 1:      Enable the Next Address to be displayed
           Bit 2:      Enables the Track Position and Track Follow Offset to be displayed
           Bit 3:      Enables the Target Address to be displayed
           Bit 4:      Enables the Recovery Status to be displayed
           Bit 5:      Enables the Fault Status to be displayed
           Bit 6:      Enables the Elapsed Time to be displayed
           Bits 31-7:  NA
    
        If Bit 0 is set, the R/W Status and R/W Error will be displayed even if no error
        occurred.  The data displayed will be formatted as shown above.
    
        If Bit 1 is set, the Next Address will be displayed even if no error occurred.  The
        data displayed will be formatted as shown above.
    
        If Bit 2 is set, the Track Position and Track Follow Offset will be displayed as
        follows.
    
              "Read Position, Persistent Offset m.m% Total Offset n.n%"          or
              "Write Position, Persistent Offset m.m% Total Offset n.n%"         or
              "Write Header Position, Persistent Offset m.m% Total Offset n.n%"
    
           where
    
              m.m is the Persistent Track Follow Offset in units of percentage of track width
    
              n.n is the Total Track Follow Offset in units of percentage of track width
    
        If Bit 3 is set, the Target Address will be displayed as follows.
    
              "Target User LBA pppppppp LLL CHS qqqqqq.r.ssss PLP CHS tttttt.u.vvvv"
              "Starting Transfer Length wwwwwwww"
    
           or
    
              "Target System LBA pppppppp LLL CHS qqqqqq.r.ssss PLP CHS tttttt.u.vvvv"
              "Starting Transfer Length wwwwwwww"
    
           where
    
              pppppppp is the starting Disk Logical Block Address
    
              qqqqqq is the starting Logical Cylinder Address
    
              r is the starting Logical Head Address
    
              ssss is the starting Logical Sector Address
    
              tttttt is the starting Physical Cylinder Address
    
              u is the starting Logical Head Address
    
              vvvv is the starting Physical Sector Address
    
              wwwwwwww is the starting Transfer Length
    
        If Bit 4 is set, the Recovery Status will be displayed as follows.
    
              "Recovered User LBA AAAAAAAA LLL CHS BBBBBB.C.DDDD PLP CHS EEEEEE.F.GGGG"
              "Recovery Flags HHHH Count II"
    
           or
    
              "Recovered System LBA AAAAAAAA LLL CHS BBBBBB.C.DDDD PLP CHS EEEEEE.F.GGGG"
              "Recovery Flags HHHH Count II"
    
           where
    
              AAAAAAAA is the Disk Logical Block Address of the last recovered sector
    
              BBBBBB is the Logical Cylinder Address of the last recovered sector
    
              C is the Logical Head Address of the last recovered sector
    
              DDDD is the Logical Sector Address of the last recovered sector
    
              EEEEEE is the Physical Cylinder Address of the last recovered sector
    
              F is the Logical Head Address of the last recovered sector
    
              GGGG is the Physical Sector Address of the last recovered sector
    
              HHHH are the Recovery Flags reported by the Read/Write code
    
              II is the Recovery Count reported by the Read/Write code
    
        If Bit 5 is set, the Fault Status will be displayed as follows.
    
              "Drive Fault Status JJJJ Preamp Fault Status KKKK"
    
           where
    
              JJJJ is the Drive Fault Status reported by the Read/Write code
    
              KKKK is the Preamp Fault Status reported by the Read/Write code
    
        If Bit 6 is set, the Elapsed Time for the read/write operation will be displayed.
<a name="ELAPSED_TIME"></a>
    
       "Elapsed Time a mins b secs"  or
       "Elapsed Time b.c secs"       or
       "Elapsed Time c.d msecs"
    
    where
    
       a is minutes
       b is seconds
       c is milliseconds
       d is microseconds
    
    

    or

<a name="RD_MISCOMPARE_DATA"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
           If a data miscompare was detected during a read compare operation, the followed
           information will be displayed.
    
              "DiagError aaaaaaaa"
    
           followed by
    
              "User LBA cccccccc LLL CHS dddddd.e.ffff PLP CHS gggggg.h.iiii"
              "Byte Offset = jjjj Expected = kk Actual = ll"
    
           or
    
              "System LBA cccccccc LLL CHS dddddd.e.ffff PLP CHS gggggg.h.iiii"
              "Byte Offset = jjjj Expected = kk Actual = ll"
    
           where
    
              aaaaaaaa is the Diagnostic Error Code
    
              cccccccc is the Disk Logical Block Address of the sector that miscompared
    
              dddddd is the Logical Cylinder Address of the sector that miscompared
    
              e is the Logical Head Address of the sector that miscompared
    
              ffff is the Logical Sector Address of the sector that miscompared
    
              gggggg is the Physical Cylinder Address of the sector that miscompared
    
              h is the Logical Head Address of the sector that miscompared
    
              iiii is the Physical Sector Address of the sector that miscompared
    
              jjjj is the byte offset from the start of the sector to the byte that miscompared
    
              kk is the expected byte value
    
              ll is the actual byte value
    

  <b><i><u>Examples:</u></i></b>
    Example #1:
       To read and verify a single logical sector
       (in this case logical sector 23 on logical cylinder 45 head 1)

          F3 2>A0
          F3 2>S45,1
          F3 2>V23

    Example #2:
       To read and verify multiple logical sectors
       (in this case logical sectors 23 to 26 on logical cylinder 45 head 1)

          F3 2>A0
          F3 2>S45,1
          F3 2>V23,4

    Example #3:
       To read and verify all of the logical sectors on a track
       (in this case all logical sectors on logical cylinder 45 head 1)

          F3 2>A0
          F3 2>S45,1
          F3 2>V

    Example #4:
       To read and verify all of the logical sectors on multiple tracks
       (in this case all logical sectors on logical cylinders 45 to 49 head 0)

       Note: You must seek to the track before the first one to be read.

          F3 2>A3
          F3 2>S44,0
          F3 2>L,5
          F3 2>V

    Example #5:
       To read and verify all of the logical sectors on a track and continue on error
       (in this case all logical sectors on logical cylinder 45 head 0)

       Note: An error message will be displayed for each sector in error.

          F3 2>A0
          F3 2>S45,0
          F3 2>V,,,1

    Example #6:
       To read and verify all of the logical sectors in the test space and continue on error

       Note: The Test Space is selected by the all level 'A' command.  An error
       message will be displayed for each sector in error.

          F3 2>V,,,11

    Example #7:
       To read and verify a single physical sector
       (in this case physical sector 32 on physical cylinder 54 head 0)

          F3 2>A0
          F3 2>s54,0,22
          F3 2>V32,,,20

    Example #8:
       To read and verify multiple physical sectors
       (in this case physical sectors 32 to 35 on physical cylinder 54 head 0)

          F3 2>A0
          F3 2>s54,0,22
          F3 2>V32,4,,20

    Example #9:
       To read and verify all of the physical sectors on a track
       (in this case all physical sectors on physical cylinder 54 head 0)

          F3 2>A0
          F3 2>s54,0,22
          F3 2>V,,,20

    Example #10:
       To read a single logical sector to a specific sector offset in the diagnostic read
       buffer, then compare the data at the sector offset in the diagnostic read buffer
       against the data at the same sector offset in the diagnostic write buffer to verity
       the data
       (in this case logical sector 23 on logical cylinder 45 head 1,
        to the sector offset of 5 in the diagnostic read buffer)

          F3 2>A0
          F3 2>AF,5
          F3 2>S45,1
          F3 2>V23

    Example #11:
       To rotate the buffer sector offset by 1 and read a single logical sector to the
       rotated sector offset in the diagnostic read buffer, then compare the data at the
       sector offset in the diagnostic read buffer against the data at the same sector offset
       in the diagnostic write buffer to verity the data
       (This example assumes user ran the Example #10 above right before this example,
        in this case logical sector 24 on logical cylinder 45 head 1,
        to the sector offset of 6 in the diagnostic read buffer)

          F3 2>V24,,,4

  <b><i><u>Revision History:</u></i></b>
<a name="READ_VERIFY_CHS_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0001.0001   Eliminated the Enable ZAP Updates and Enable Track Skipping option.
    0001.0002   Added new Rotate Buffer Sector Offset option to the bit 2 of the parameter 3.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="READ_WEDGE_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Read Wedge"></a><hr align=left width="75%"><b> Read Wedge (Level 2 'j' or Level E 'C')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command reads data from the disk starting at the specified data wedge for the
    specified number of data wedges.  The data is read into the Diagnostic Read Buffer.
    At meanwhile the channel registers are sampled, if the register address are
    specified.

  <b><i><u>Quick Help:</u></i></b>
<a name="READ_WEDGE_QUICK_HELP"></a>
       Level 2
    "RdWedge, j[WedgeAddr],[NumWedges],[NumSkipedWedges],[TranSize],[Opts],[RegAddr0],...,[RegAddr13]";
       Level E
    "RdWedge, C[WedgeAddr],[NumWedges],[NumSkipedWedges],[TranSize],[Opts],[RegAddr0],...,[RegAddr13]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="READ_WEDGE_PARM"></a>
     0 - Wedge Address.
    
         This parameter specifies the address of the first wedge to be read.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to maximum Wedge Address
    
          Default: 0
    
     1 - Transfer Length.
    
         This parameter specifies the number of wedges to be read.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: If the Wedge Address is entered and the Transfer Length is not
                   entered, then only the specified wedge will be read.
    
                   If both the Wedge Address and Transfer Length are not entered,
                   then the Transfer Length will be set based on the Test Space
                   that is selected.  If the Random Transfer Length option is
                   selected, a random value will be used that is less than or
                   equal to the number of wedges remaining on the track.  If the
                   Random Transfer Length option is not selected, the number of
                   wedges remaining on the track will be read.
    
                   If a Transfer Length is entered, it will be limited to the
                   number of wedges remaining on the track.
    
     2 - Skipped Wedges.
    
         This parameter specifies the number of wedges to skip after each wedge read.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: 0 (Disable wedge skipping)
    
     3 - Wedge Size in NRZ Symbols.
    
         This parameter specifies the number of NRZ symbols to be transfered from
         each wedge.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: 0 (Use native (max) wedge size)
    
     4 - Options.
    
         This parameter is a bit significant value that selects the following options:
    
             Bit 1 - Continue on Sync Error.
    
                     If this bit is equal to 1, the wedge read operation will not stop when
                     a sync error occurs.
    
             Bit 0 - Formatted Wedge Read.
    
                     If this bit is equal to 1, a formatted wedge read operation will be
                     performed.  If this bit is equal to 0, an unformatted wedge read operation
                     will be performed.  A formatted wedge read attempts to detect a sync mark
                     preceeding the wedge data.  An unfomatted wedge read does not attempt to
                     detect a sync mark before the wedge data.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: 0x00000001 (Stop on Sync Error, Formatted Wedge Read)
    
     5 - Channel Register Address.
    
         This parameter specifies the address of the 1st Read Channel register
         to be read for data collection.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: None
    
     6 - Channel Register Address.
    
         This parameter specifies the address of the 2nd Read Channel register
         to be read for data collection.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: None
    
     7 - Channel Register Address.
    
         This parameter specifies the address of the 3rd Read Channel register
         to be read for data collection.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: None
    
     8 - Channel Register Address.
    
         This parameter specifies the address of the 4th Read Channel register
         to be read for data collection.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: None
    
     9 - Channel Register Address.
    
         This parameter specifies the address of the 5th Read Channel register
         to be read for data collection.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: None
    
    10 - Channel Register Address.
    
         This parameter specifies the address of the 6th Read Channel register
         to be read for data collection.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: None
    
    11 - Channel Register Address.
    
         This parameter specifies the address of the 7th Read Channel register
         to be read for data collection.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: None
    
    12 - Channel Register Address.
    
         This parameter specifies the address of the 8th Read Channel register
         to be read for data collection.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: None
    
    13 - Channel Register Address.
    
         This parameter specifies the address of the 9th Read Channel register
         to be read for data collection.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: None
    
    14 - Channel Register Address.
    
         This parameter specifies the address of the 10th Read Channel register
         to be read for data collection.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: None
    
    15 - Channel Register Address.
    
         This parameter specifies the address of the 11th Read Channel register
         to be read for data collection.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: None
    
    16 - Channel Register Address.
    
         This parameter specifies the address of the 12th Read Channel register
         to be read for data collection.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: None
    
    17 - Channel Register Address.
    
         This parameter specifies the address of the 13th Read Channel register
         to be read for data collection.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: None
    
    18 - Channel Register Address.
    
         This parameter specifies the address of the 14th Read Channel register
         to be read for data collection.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: None
    

  <b><i><u>Output Data:</u></i></b>
<a name="RW_WEDGE_DATA"></a>
    
       If no error occurred and one or more read channel register was specified for data
       collection, the following information will be displayed.
    
             "  RegAddr      aaaa      aaaa      aaaa      ... aaaa"
             "  Min          bbbbbbbb  bbbbbbbb  bbbbbbbb  ... bbbbbbbb"
             "  Max          cccccccc  cccccccc  cccccccc  ... cccccccc"
             "  Mean         dddddddd  dddddddd  dddddddd  ... ddddddddd"
             "  StdDev       eeeeee.ee eeeeee.ee eeeeee.ee ... eeeeee.ee"
    
          where
    
             aaaa is the address of the channel register that was read
    
             bbbbbbbb is the minimum value that was read from the channel register
    
             cccccccc is the maximum value that was read from the channel register
    
             dddddddd is the mean of the values read from the channel register
    
             eeeeee.ee is the standard deviation of the values read from the channel register
    
    
       If no error occurred, one or more read channel register was specified for data
       collection and Raw ASCII output mode is selected, the following additional
       information will be displayed for each wedge and channel register for which data
       was collected.
    
             "Wedge ffff  RegAddr gggg  RegData hhhhhhhh  Error ii"
    
          where
    
             ffff is the wedge address
    
             gggg is the address of the channel register that was read
    
             hhhhhhhh is the value read from the channel register
    
             ii is the error that was logged for the wedge
    
                   00 = No Error
                   04 = Sync Error
    
    
       If no error occurred, no read channel registers were specified for data collection
       and the Continue On Sync Error option was selected, the following additional
       information will be displayed.
    
             "Wedges with Sync Errors: jjjj jjjj jjjj ... jjjj"
    
          where
    
             jjjj is the address of a wedge with a sync error
    
    
<a name="RW_OP_STATUS_OUTPUT_DATA"></a>
        If an error occurred, the following information will be displayed.
    
              "DiagError aaaaaaaa R/W Status c R/W Error dddddddd"
    
           and
    
              "Next User LBA eeeeeeee LLL CHS ffffff.g.hhhh PLP CHS iiiiii.j.kkkk"
              "Remaining Transfer Length llllllll"
    
           or
    
              "Next System LBA eeeeeeee LLL CHS ffffff.g.hhhh PLP CHS iiiiii.j.kkkk"
              "Remaining Transfer Length llllllll"
    
           where
    
              aaaaaaaa is the Diagnostic Error Code
    
              c is the status returned by the R/W subsystem
    
                    0 = R/W request completed successfully with error recovery
                    1 = R/W request completed successfully (no error recovery performed)
                    2 = R/W request failed
    
              dddddddd is the error code returned by the R/W subsystem
    
              eeeeeeee is the Disk Logical Block Address of the sector in error
    
              ffffff is the Logical Cylinder Address of the sector in error
    
              g is the Logical Head Address of the sector in error
    
              hhhh is the Logical Sector Address of the sector in error
    
              iiiiii is the Physical Cylinder Address of the sector in error
    
              j is the Logical Head Address of the sector in error
    
              kkkk is the Physical Sector Address of the sector in error
    
              llllllll is the number of sectors remaining to be read or written
    
        If the Verbose Formatted ASCII Data Output Mode is selected, the Verbose Mode option
        bits will enable the following data to be output when set.
    
           Bit 0:      Enables the R/W Status and R/W Error to be displayed
           Bit 1:      Enable the Next Address to be displayed
           Bit 2:      Enables the Track Position and Track Follow Offset to be displayed
           Bit 3:      Enables the Target Address to be displayed
           Bit 4:      Enables the Recovery Status to be displayed
           Bit 5:      Enables the Fault Status to be displayed
           Bit 6:      Enables the Elapsed Time to be displayed
           Bits 31-7:  NA
    
        If Bit 0 is set, the R/W Status and R/W Error will be displayed even if no error
        occurred.  The data displayed will be formatted as shown above.
    
        If Bit 1 is set, the Next Address will be displayed even if no error occurred.  The
        data displayed will be formatted as shown above.
    
        If Bit 2 is set, the Track Position and Track Follow Offset will be displayed as
        follows.
    
              "Read Position, Persistent Offset m.m% Total Offset n.n%"          or
              "Write Position, Persistent Offset m.m% Total Offset n.n%"         or
              "Write Header Position, Persistent Offset m.m% Total Offset n.n%"
    
           where
    
              m.m is the Persistent Track Follow Offset in units of percentage of track width
    
              n.n is the Total Track Follow Offset in units of percentage of track width
    
        If Bit 3 is set, the Target Address will be displayed as follows.
    
              "Target User LBA pppppppp LLL CHS qqqqqq.r.ssss PLP CHS tttttt.u.vvvv"
              "Starting Transfer Length wwwwwwww"
    
           or
    
              "Target System LBA pppppppp LLL CHS qqqqqq.r.ssss PLP CHS tttttt.u.vvvv"
              "Starting Transfer Length wwwwwwww"
    
           where
    
              pppppppp is the starting Disk Logical Block Address
    
              qqqqqq is the starting Logical Cylinder Address
    
              r is the starting Logical Head Address
    
              ssss is the starting Logical Sector Address
    
              tttttt is the starting Physical Cylinder Address
    
              u is the starting Logical Head Address
    
              vvvv is the starting Physical Sector Address
    
              wwwwwwww is the starting Transfer Length
    
        If Bit 4 is set, the Recovery Status will be displayed as follows.
    
              "Recovered User LBA AAAAAAAA LLL CHS BBBBBB.C.DDDD PLP CHS EEEEEE.F.GGGG"
              "Recovery Flags HHHH Count II"
    
           or
    
              "Recovered System LBA AAAAAAAA LLL CHS BBBBBB.C.DDDD PLP CHS EEEEEE.F.GGGG"
              "Recovery Flags HHHH Count II"
    
           where
    
              AAAAAAAA is the Disk Logical Block Address of the last recovered sector
    
              BBBBBB is the Logical Cylinder Address of the last recovered sector
    
              C is the Logical Head Address of the last recovered sector
    
              DDDD is the Logical Sector Address of the last recovered sector
    
              EEEEEE is the Physical Cylinder Address of the last recovered sector
    
              F is the Logical Head Address of the last recovered sector
    
              GGGG is the Physical Sector Address of the last recovered sector
    
              HHHH are the Recovery Flags reported by the Read/Write code
    
              II is the Recovery Count reported by the Read/Write code
    
        If Bit 5 is set, the Fault Status will be displayed as follows.
    
              "Drive Fault Status JJJJ Preamp Fault Status KKKK"
    
           where
    
              JJJJ is the Drive Fault Status reported by the Read/Write code
    
              KKKK is the Preamp Fault Status reported by the Read/Write code
    
        If Bit 6 is set, the Elapsed Time for the read/write operation will be displayed.
<a name="ELAPSED_TIME"></a>
    
       "Elapsed Time a mins b secs"  or
       "Elapsed Time b.c secs"       or
       "Elapsed Time c.d msecs"
    
    where
    
       a is minutes
       b is seconds
       c is milliseconds
       d is microseconds
    
    
    

  <b><i><u>Examples:</u></i></b>
    Example #1:
       To read a single wedge
       (in this case wedge 23 on logical cylinder 45 head 1)

          F3 2>A0
          F3 2>S45,1
          F3 2>j23

    Example #2:
       To read multiple wedges
       (in this case wedges 23 to 26 on logical cylinder 45 head 1)

          F3 2>A0
          F3 2>S45,1
          F3 2>j23,4

    Example #3:
       To read all of the wedges on a track
       (in this case all wedges on logical cylinder 45 head 1)

          F3 2>A0
          F3 2>S45,1
          F3 2>j

    Example #4:
       To read all of the wedges on multiple tracks
       (in this case all wedges on logical cylinders 45 to 49 head 0)

       Note: You must seek to the track before the first one to be read.

          F3 2>A3
          F3 2>S44,0
          F3 2>L,5
          F3 2>j

    Example #5:
       To read all of the wedges on a track and continue on sync errors
       (in this case all logical sectors on logical cylinder 45 head 0)

       Note: An error message will be displayed for each sector in error.

          F3 2>A0
          F3 2>S45,0
          F3 2>j,,,,2

  <b><i><u>Revision History:</u></i></b>
<a name="READ_WEDGE_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0001.0001   Increase the number of channel registers for the data collection.
    0002.0000   Added Continue on Sync Error and Formatted Wedge Read options.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="READ_ZAP_FROM_DISC_TO_TABLE_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Read Zap from Disc to Table"></a><hr align=left width="75%"><b> Read Zap from Disc to Table (Level 5 'Z')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    The Read Zap from Disc to Table command reads ZAP data from disc into ZAP table in Servo
    ZAP Table.

  <b><i><u>Quick Help:</u></i></b>
<a name="READ_ZAP_FROM_DISC_TO_TABLE_QUICK_HELP"></a>
    "RdZapFromDiscToTable, Z";

  <b><i><u>Input Parameters:</u></i></b>
    None

  <b><i><u>Output Data:</u></i></b>
    None

  <b><i><u>Revision History:</u></i></b>
<a name="READ_ZAP_FROM_DISC_TO_TABLE_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="REAL_TIME_SERVO_TRACE_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Real Time Servo Trace"></a><hr align=left width="75%"><b> Real Time Servo Trace (Level 3 'f')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    The Real Time Servo Trace command executes the specified Real Time Servo Data Collection
    function which collects specified data at every servo burst and then sends out the result
    in binary data format.

    3>f0 collects PES (16-bits) data at the current track for the speficied revs (or until
    the maximum data allowed).

    3>f2 seeks for the spefified length, reads/writes one sector at the target track, and
    collects 3 words in the following order: Servo Loop Code, 16-bit PES, and Servo Unsafe
    status. The collection is from the beginning of the seek until specified extra revs after
    the head is settled. (Note: 2 extra 0FFFFh are added at the end of data collected).
    Note: The high byte of this sub-command ID is used to determine if this is a read or
    write seek. When the high byte is 1, it is a write seek. When the high byte is 0, it
    is a read seek. So 3>f102 is a write seek and 3>f2 is a read seek.

    3>f3 writes the full track at the current location and collects 4 words in the following
    order: Servo Loop Code, PES (16-bits), Servo Burst Number, and Servo Unsafe Code for
    the whole writing process. (Note: 2 extra 0FFFFh are added at the end of data collected).

  <b><i><u>Quick Help:</u></i></b>
<a name="REAL_TIME_SERVO_TRACE_QUICK_HELP"></a>
    "RealTimeServoTrace, f[SubCmd],[SubCmdParm0],[SubCmdParm1]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="REAL_TIME_SERVO_TRACE_PARM"></a>
    0 - Sub-command ID.
    
        The low byte of this parameter specifies the ID of the Real Time Servo Trace command
        to be executed and the hugh byte is used to determine operation type that will be
        perform before collecting servo data.
    
            0 = PES Collection
    
            2 = Seek Profile (High byte value of 1 means a write seek and high byte value
                of 0 means a read seek. So 3>f102 is a write seek and 3>f2 is a read seek)
    
            3 = Write And Collect Servo Data
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: 0
    

    If Parameter 0's low byte is equal to 0 (PES Collection)
<a name="PES_COLLECTION_PARM"></a>
       1 - Revs to Collect.
       
           This parameter specifies the revs to collect the PES data.  If this parameter is
           not entered, the default value is 100 revs.
       
             Type:    Unsigned 16-bit value
       
             Range:   0 to 0xffff
       
             Default: 100
       

    If Parameter 0's low byte is equal to 2 (Seek Profile)
<a name="SEEK_PROFILE_PARM"></a>
       1 - Seek Length
       
           This parameter specifies the seek length for the seek operation.
        
             Type:    Signed 32-bit value
       
             Range:   0x80000000 to 0x7fffffff
       
             Default: 0
       
       2 - Number of extra revs to be collected after the head is settled
       
           This parameter specifies the number of extra revs to be collected after the head
           is settled. When this parameter is not entered, 3 extra revs of data will be
           collected after the head is settled.
        
             Type:    Unsigned 16-bit value
       
             Range:   0x0000 to 0xffff
       
             Default: 3
       

  <b><i><u>Output Data:</u></i></b>
<a name="BINARY_OUTPUT_SERVO_DATA"></a>
       
       The following data will be displayed:
       
          [[[xxxxxxxx...]]]
       
       Where:
          xx is a continuous stream of binary data.  The data is delimited by triple opening
             and closing brackets.
       

  <b><i><u>Revision History:</u></i></b>
<a name="REAL_TIME_SERVO_TRACE_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).
    0012.0000   Changed the output of 3>f2 command from 2 words (Servo Loop Code and PES) to
                3 words (Servo Loop Code, PES, and Servo Unsafe Status).

<a name="RESUME_INTERFACE_TASK_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Resume Interface Task"></a><hr align=left width="75%"><b> Resume Interface Task (Online Control Q)</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    If the Interface Task was previously paused by the Online Control S command, this
    command resumes execution of the Interface Task.

  <b><i><u>Quick Help:</u></i></b>
<a name="RESUME_INTERFACE_TASK_QUICK_HELP"></a>
    "ResumeInterfaceTask";

  <b><i><u>Input Parameters:</u></i></b>
    None

  <b><i><u>Output Data:</u></i></b>
    None

  <b><i><u>Revision History:</u></i></b>
<a name="RESUME_INTERFACE_TASK_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="RUN_BATCH_FILE_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Run Batch File"></a><hr align=left width="75%"><b> Run Batch File (Level 6 'B')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command runs the specified Diagnostic Batch File.  A Batch File is sequence
    of Diagnostic Commands entered by the user via the serial port interface.

  <b><i><u>Quick Help:</u></i></b>
<a name="RUN_BATCH_FILE_QUICK_HELP"></a>
    "RunBatchFile, B[BatchFileNum],[DisplayOpt]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="RUN_BATCH_FILE_PARM"></a>
    0 - Batch File Number.
    
        This parameter specifies the number of the Batch File to be executed.
    
          Type:    Unsigned 8-bit value
    
          Range:   0 to 0xFF
    
          Default: 0
    
    1 - Options Mask.
    
        This parameter is a bit significant value that selects the following options:
    
             0x08  Continue Predefined Batch File Sequence On Failure.
    
                   Continue executing the predefined batch file sequence when a
                   failure occurs.
    
             0x04  Run Predefined Batch File Sequence.
    
                   Starting with the predefined batch file specified by Parameter 0,
                   execute the predefined batch files in sequence.  If Parameter 0
                   is not entered, start with the first predefined batch file and
                   execute all of the predefined batch files in sequence.
       
             0x02  Single Step.
    
                   Execute the batch file one command at a time, pausing and waiting
                   for a character to be input between commands.
    
             0x01  Display Batch File Commands.
    
          Type:    Unsigned 8-bit value
    
          Range:   0 to 0x01
    
          Default: 0x01 ( Display batch file commands )
    

  <b><i><u>Output Data:</u></i></b>
    None

  <b><i><u>Revision History:</u></i></b>
<a name="RUN_BATCH_FILE_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="RW_POWER_ASIC_REG_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Read or Write Power ASIC Register"></a><hr align=left width="75%"><b> Read or Write Power ASIC Register (Level 3 'V')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command reads or writes the specified Power ASIC registers.

  <b><i><u>Quick Help:</u></i></b>
<a name="RW_POWER_ASIC_REG_QUICK_HELP"></a>
    "RwPowerAsicReg, V[RegAddr],[RegValue],[WrOpt]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="RW_POWER_ASIC_REG_PARM"></a>
    0 - Register Address.
    
        This parameter specifies the address of the Power ASIC register to be read
        or written.  If this parameter is not entered, all Power ASIC registers will
        be read and displayed.
    
          Type:    Unsigned 8-bit value
    
          Range:   0 to 0xFF
    
          Default: Read and display all Power ASIC registers
    
    1 - Write Register Value.
    
        If entered, this parameter specifies the value with which the Power ASIC register
        is to be written.  If this value is not entered, the specified Power ASIC register
        will be read and its value displayed.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: None
    
    2 - Write Register Valid Command Key.
    
        For register writes, this parameter must be equal to 1.  This parameter is not
        used for register reads.
    
          Type:    Unsigned 8-bit value
    
          Range:   0 to 0xFF
    
          Default: None
    

  <b><i><u>Output Data:</u></i></b>
<a name="RD_POWER_ASIC_REG_DATA"></a>
    If a single Power ASIC register was read, the following information will be displayed.
    
       "Power ASIC Reg cc = dddd"
    
       where
    
          cc is the address of the register that was read
    
          dddd is the value that was read from the register
    
    If multiple Power ASIC registers were read, the following information will be displayed.
    
       "Power ASIC"
       "    0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F"
       "cc: dddd dddd dddd dddd dddd dddd dddd dddd dddd dddd dddd dddd dddd dddd dddd dddd"
    
       where
    
          cc is the address of the first register in the row
    
          dddd is the value that was read from the register
    
<a name="WR_POWER_ASIC_REG_DATA"></a>
    If a Power ASIC register was written, the following information will be displayed.
    
       "Power ASIC Reg cc = dddddddd"
    
       where
    
          cc is the address of the register that was written
    
          dddddddd is the data with which the register was written
    

  <b><i><u>Revision History:</u></i></b>
<a name="RW_POWER_ASIC_REG_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="SATA_DEBUG_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="SATA Debug SPI SSIP"></a><hr align=left width="75%"><b> SATA Debug SPI SSIP (Level F 'z')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    The SATA Debug command executes the specified SATA Debug function for SPI SSIP.

  <b><i><u>Input Parameters:</u></i></b>
<a name="SATA_DEBUG_PARM"></a>
    0 - Sub-command ID.
    
        This parameter specifies the ID of the SATA Debug sub-command to be executed.
    
            0 = Peek/Poke SATA registers
    
            1 = Dump SATA registers
    
            2 = Toggle Phy
    
            3 = Send ALIGN pattern
    
            4 = Send High Frequency (D10.2) pattern
    
            5 = Send Mid Frequency (D24.3) pattern
    
            6 = Send Lone Bit pattern
    
            7 = Send Low Frequency (K28.7) pattern
    
            8 = Send User Specified pattern
    
            9 = Send PRBS pattern
    
            A = Enable PRBS checker and watch the results
                (Note: This sub-command never returns.)
    
            B = Toggle TX SSC
    
            C = Wait for OOB
    
            D = Toggle speed
    
            E = Set OOB Chirp style
    
            F = Enable Test Muxes
    
            10 = Phy Power Mode
    
            11 = Loopback Mode
        
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: None
    
    If Parameter 0 is equal to 0 (Peek / Poke SATA Registers)

<a name="PEEK_POKE_SATA_REGS_PARM"></a>
       1 - not used.
       
           In the Super10 code this parameter selected the register group (Normal SATA
           registers or SSPI registers) to be read or written.  In the Super10 Yuma
           architecture these registers shared the same address space and a page bit
           determined which registers were being accessed.  In the Delta architecture
           each register group has its own, unique address space, so this parameter is
           no longer needed.
        
             Type:    NA
       
             Range:   NA
       
             Default: NA
       
       2 - Register Offset.
       
           This parameter specifies the byte offset from the start of the SATA registers
           to the register to be read or written.
       
             Type:    Unsigned 32-bit value
       
             Range:   0 to 0xffffffff
       
             Default: None
       
       3 - Register Data.
       
           This parameter specifies the data to be written to the specified register.  If
           this parameter is not entered, the register will be read and its value displayed.
       
             Type:    Unsigned 16-bit value
       
             Range:   0 to 0xffff
       
             Default: None
       
    If Parameter 0 is equal to 8 (Send User Pattern)

<a name="SEND_USER_PATTERN_PARM"></a>
       1 - Pattern.
       
           This parameter specifies the 16-bit pattern to be sent.
        
             Type:    Unsigned 16-bit value
       
             Range:   0 to 0xffff
       
             Default: None
       
    If Parameter 0 is equal to 0xE (Set OOB Type)

<a name="SET_OOB_TYPE_PARM"></a>
       1 - OOB Type.
       
           This parameter specifies the OOB Type to be set.
       
                1 = Normal ALIGN
                2 = Normal D24.3
                3 = Bit Doubled ALIGN
                4 = Bit Doubled D24.3
        
             Type:    Unsigned 8-bit value
       
             Range:   1 to 4
       
             Default: None
       

  <b><i><u>Output Data:</u></i></b>
    If Parameter 0 is equal to 0 (Peek / Poke SATA Registers)

<a name="SATA_RW_REG_DATA"></a>
       If no error occurred and the SATA register was read, the following information will
       be displayed.
       
             "    cccc (dddddddd) eeee"
       
          where
       
             cccc is the offset of the SATA register that was read
       
             dddddddd is the address of the SATA register that was read
       
             eeee is the register value
       
       If no error occurred and the SATA register was written, the following information
       will be displayed.
       
             "    gggg (hhhhhhhh) iiii --> jjjj = llll"
       
          where
       
             gggg is the offset of the register that was written
       
             hhhhhhhh is the address of the register that was written
       
             iiii is the value read from the register before it was written
       
             jjjj the value with which the register was written
       
             llll is the value read from the register after it was written
       
    If Parameter 0 is equal to 1 (Dump SATA registers)

<a name="SATA_REG_DUMP"></a>
       If no error occurred, the following information will be displayed.
       
             "ATA registers"
             "cccc:  dddd dddd dddd ... dddd"  (repeated)
       
             "SATA SSIP registers"
             "cccc:  dddd dddd dddd ... dddd"  (repeated)
       
             "SATA Vis Mux registers"
             "cccc:  dddd dddd dddd ... dddd"  (repeated)
       
             "SATA Core TXB registers"
             "cccc:  dddd dddd dddd ... dddd"  (repeated)
       
             "SATA Core TXW registers"
             "cccc:  dddd dddd dddd ... dddd"  (repeated)
       
             "SATA Core TXWB registers"
             "cccc:  dddd dddd dddd ... dddd"  (repeated)
       
             "SATA Core Test registers"
             "cccc:  dddd dddd dddd ... dddd"  (repeated)
       
          where
       
             cccc is the address of the first register in the row
       
             dddd is the register value
       
    If Parameter 0 is equal to 2 (Toggle Phy)

<a name="SATA_PHY_STATE"></a>
       If no error occurred, the following information will be displayed.
       
          "Phy Disabled"                         or
          "Phy Enabled - force from initial"     or
          "Invalid Phy State"
       
    If Parameter 0 is equal to 3 (Send ALIGN pattern) or
                               4 (Send High Frequency pattern) or
                               5 (Send Mid Frequency pattern) or
                               6 (Send Lone Bit pattern) or
                               7 (Send Low Frequency pattern) or
                               8 (Send User Specified pattern) or
                               9 (Send PRBS pattern)

<a name="SATA_SEND_PATTERN_DATA"></a>
       If no error occurred, the following information will be displayed.
       
          "Phy spew ALIGN primitives"
          "Cycle power to end"                      or
       
          "Phy spew High freq pattern (D10.2)"
          "Cycle power to end"                      or
       
          "Phy spew Mid freq pattern (D24.3)"
          "Cycle power to end"                      or
       
          "Phy spew Lone Bit pattern (0x0C8B)"
          "Cycle power to end"                      or
       
          "Phy spew Low freq pattern (K28.7)"
          "Cycle power to end"                      or
       
          "Phy spew Generic pattern"
          "Cycle power to end"                      or
       
          "Phy spew PRBS pattern"
       
          "Phy spew Invalid pattern"
       
    If Parameter 0 is equal to A (Enable PRBS checker and watch the results)

<a name="SATA_WATCH_PRBS_DATA"></a>
       If no error occurred, the following information will be displayed.
       
             "PRBS Checker enabled"
             "Cycle power to end"
             "Press CTRL/Z to return"
             "PRBS loop ccccc: ***...*"    (repeated)
       
          where
       
             ccccc is the number of times the Error Count saturated and was reset to zero
                   and a '*' is output for each error that is detected.
       
    If Parameter 0 is equal to B (Toggle TX SSC)

<a name="SATA_SSC_STATE"></a>
       If no error occurred, the following information will be displayed.
       
          "Enable SSC"      or
          "Disable SSC"
       
    If Parameter 0 is equal to C (Wait for OOB)

<a name="SATA_OOB_STATE"></a>
       If no error occurred, the following information will be displayed.
       
          "OOB Test"                                      and
          "Waiting for COMRESET"                          and / or
          "Phy went not ready, probably saw COMRESET"     and / or
          "COMRESET detected"                             and / or
          "Waiting for COMWAKE"                           and / or
          "COMWAKE detected"                              and / or
          "Invalid OOB State"
       
    If Parameter 0 is equal to D (Toggle speed)

<a name="SATA_SPEED"></a>
       If no error occurred, the following information will be displayed.
       
          "Speed: 1.5gbit"     or
          "Speed: 3.0gbit"
       
    If Parameter 0 is equal to 0xE (Set OOB Type)

<a name="OOB_TYPE"></a>
       If no error occurred, the following information will be displayed.
       
          "Normal ALIGN"          or
          "Normal D24.3"          or
          "Bit doubled ALIGN"     or
          "Bit doubled D24.3"     or
          "Invalid OOB Type"
       
    Else

<a name="GENERIC_ERROR"></a>
       If an error occurred, the following information will be displayed.
       
             "DiagError aaaaaaaa "
       
          where
       
             aaaaaaaa is the Diagnostic Error Code
       

  <b><i><u>Revision History:</u></i></b>
<a name="SATA_DEBUG_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="SATA_DEBUG_CMD_DESCRIPTION_365"></a>
<!--SUBSECTION--><a name="SATA Debug Athos MiPhy 365"></a><hr align=left width="75%"><b> SATA Debug Athos MiPhy 365 (Level F 'z')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    The SATA Debug command executes the specified SATA Debug function for the Athos MiPhy365.

  <b><i><u>Input Parameters:</u></i></b>
<a name="SATA_DEBUG_PARM_365"></a>
    0 - Sub-command ID.
    
        This parameter specifies the ID of the SATA Debug sub-command to be executed.
    
            0 = Peek/Poke SATA registers
    
            1 = Dump SATA registers
    
            2 = Toggle Phy
    
            3 = Send ALIGN pattern
    
            4 = Send High Frequency (D10.2) pattern
    
            5 = Send Mid Frequency (D24.3) pattern
    
            6 = Send Lone Bit pattern
    
            7 = Send Low Frequency (K28.7) pattern
    
            8 = Send User Specified pattern
    
            9 = Send PRBS pattern
    
            A = Enable PRBS checker and watch the results
                (Note: This sub-command never returns.)
    
            B = Toggle TX SSC
    
            C = Wait for OOB
    
            D = Toggle speed
    
            E = Set OOB Chirp style
    
            F = Enable Test Muxes
    
            10 = Phy Power Mode
    
            11 = Loopback Mode
    
            12 = Eye Diagram data
        
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: None
    

    If Parameter 0 is equal to 0 (Peek / Poke SATA Registers)

<a name="PEEK_POKE_SATA_REGS_PARM_365"></a>
       0 - Peek/Poke SATA registers sub-command (0)
       
             Type:    Unsigned 16-bit value
       
             Range:   0
       
             Default: None
       1 - Register group
       
           In the Super10 code this parameter selected the register group (Normal SATA
           registers or SSPI registers) to be read or written.  In the Super10 Yuma
           architecture these registers shared the same address space and a page bit
           determined which registers were being accessed.  In the Delta architecture
           each register group has its own, unique address space, so this parameter is
           no longer needed.
        
             Type:    Unsigned 16 bit
       
             Range:   1 - 2
       
             Default: NA
       
       2 - Register Offset.
       
           This parameter specifies the byte offset from the start of the SATA registers
           to the register to be read or written.
       
             Type:    Unsigned 32-bit value
       
             Range:   0 to 0xffffffff
       
             Default: None
       
       3 - Register Data.
       
           This parameter specifies the data to be written to the specified register.  If
           this parameter is not entered, the register will be read and its value displayed.
       
             Type:    Unsigned 16-bit value
       
             Range:   0 to 0xffff
       
             Default: None
       

    If Parameter 0 is equal to 8 (Send User Pattern)

<a name="SEND_USER_PATTERN_PARM_365"></a>
       0 - Send User Specified pattern sub-command (8)
       
             Type:    Unsigned 16-bit value
       
             Range:   8
       
             Default: None
       1 - Pattern.
       
           This parameter specifies the 16-bit pattern to be sent.
        
             Type:    Unsigned 16-bit value
       
             Range:   0 to 0xffff
       
             Default: None
       

    If Parameter 0 is equal to 0xE (Set OOB Type)

<a name="SET_OOB_TYPE_PARM_365"></a>
       0 - Set OOB Chirp style sub-command (0xE)
       
             Type:    Unsigned 16-bit value
       
             Range:   0xE
       
             Default: None
       1 - OOB Type.
       
           This parameter specifies the OOB Type to be set.
       
                1 = Normal ALIGN
                2 = Normal D24.3
                3 = Bit Doubled ALIGN
                4 = Bit Doubled D24.3
        
             Type:    Unsigned 8-bit value
       
             Range:   1 to 4
       
             Default: None
       

  <b><i><u>Output Data:</u></i></b>
    If Parameter 0 is equal to 0 (Peek / Poke SATA Registers)

<a name="SATA_RW_REG_DATA_365"></a>
       If no error occurred and the SATA register was read, the following information will
       be displayed.
       
             "    SATA dddddddd eeee"
             "    Phy  dddd ee"
       
          where
       
             SATA/Phy is the type of the SATA register that was read
       
             dddddddd or dddd is the address of the SATA or Phy register that was read
       
             eeee or ee is the register value
       
       If no error occurred and the SATA register was written, the following information
       will be displayed.
       
             "    SATA hhhhhhhh iiii --> jjjj = llll"
             "    Phy  hhhh iiii --> jj = ll"
       
          where
       
             gggg or gg is the offset of the register that was written
       
             hhhhhhhh or hhhh is the address of the register that was written
       
             iiii or ii is the value read from the register before it was written
       
             jjjj or jj the value with which the register was written
       
             llll or ll is the value read from the register after it was written
       
    If Parameter 0 is equal to 1 (Dump SATA registers)

<a name="SATA_REG_DUMP_365"></a>
       If no error occurred, the following information will be displayed.
       
             "ATA registers"
             "cccc:  dddd dddd dddd ... dddd"  (repeated)
       
             "SATA SSIP registers"
             "cccc:  dddd dddd dddd ... dddd"  (repeated)
       
             "SATA Vis Mux registers"
             "cccc:  dddd dddd dddd ... dddd"  (repeated)
       
             "SATA Core TXB registers"
             "cccc:  dddd dddd dddd ... dddd"  (repeated)
       
             "SATA Core TXW registers"
             "cccc:  dddd dddd dddd ... dddd"  (repeated)
       
             "SATA Core TXWB registers"
             "cccc:  dddd dddd dddd ... dddd"  (repeated)
       
             "SATA Core Test registers"
             "cccc:  dddd dddd dddd ... dddd"  (repeated)
       
          where
       
             cccc is the address of the first register in the row
       
             dddd is the register value
       
    If Parameter 0 is equal to 2 (Toggle Phy)

<a name="SATA_PHY_STATE_365"></a>
       If no error occurred, the following information will be displayed.
       
          "Phy Disabled"                         or
          "Phy Enabled - force from initial"     or
          "Invalid Phy State"
       
    If Parameter 0 is equal to 3 (Send ALIGN pattern) or
                               4 (Send High Frequency pattern) or
                               5 (Send Mid Frequency pattern) or
                               6 (Send Lone Bit pattern) or
                               7 (Send Low Frequency pattern) or
                               8 (Send User Specified pattern) or
                               9 (Send PRBS pattern)

<a name="SATA_SEND_PATTERN_DATA_365"></a>
       If no error occurred, the following information will be displayed.
       
          "Phy spew ALIGN primitives"
          "Cycle power to end"                      or
       
          "Phy spew High freq pattern (D10.2)"
          "Cycle power to end"                      or
       
          "Phy spew Mid freq pattern (D24.3)"
          "Cycle power to end"                      or
       
          "Phy spew Lone Bit pattern (0x0C8B)"
          "Cycle power to end"                      or
       
          "Phy spew Low freq pattern (K28.7)"
          "Cycle power to end"                      or
       
          "Phy spew Generic pattern"
          "Cycle power to end"                      or
       
          "Phy spew PRBS pattern"
       
          "Phy spew Invalid pattern"
       
    If Parameter 0 is equal to A (Enable PRBS checker and watch the results)

<a name="SATA_WATCH_PRBS_DATA_365"></a>
       If no error occurred, the following information will be displayed.
       
             "PRBS Checker enabled"
             "Cycle power to end"
             "Press CTRL/Z to return"
             "PRBS loop ccccc: ***...*"    (repeated)
       
          where
       
             ccccc is the number of times the Error Count saturated and was reset to zero
                   and a '*' is output for each error that is detected.
       
    If Parameter 0 is equal to B (Toggle TX SSC)

<a name="SATA_SSC_STATE_365"></a>
       If no error occurred, the following information will be displayed.
       
          "Enable SSC"      or
          "Disable SSC"
       
    If Parameter 0 is equal to C (Wait for OOB)

<a name="SATA_OOB_STATE_365"></a>
       If no error occurred, the following information will be displayed.
       
          "OOB Test"                                      and
          "Waiting for COMRESET"                          and / or
          "Phy went not ready, probably saw COMRESET"     and / or
          "COMRESET detected"                             and / or
          "Waiting for COMWAKE"                           and / or
          "COMWAKE detected"                              and / or
          "Invalid OOB State"
       
    If Parameter 0 is equal to D (Toggle speed)

<a name="SATA_SPEED_365"></a>
       If no error occurred, the following information will be displayed.
       
          "Speed: 1.5gbit"     or
          "Speed: 3.0gbit"
       
    If Parameter 0 is equal to 0xE (Set OOB Type)

<a name="OOB_TYPE_365"></a>
       If no error occurred, the following information will be displayed.
       
          "Normal ALIGN"          or
          "Normal D24.3"          or
          "Bit doubled ALIGN"     or
          "Bit doubled D24.3"     or
          "Invalid OOB Type"
       
    Else

<a name="GENERIC_ERROR"></a>
       If an error occurred, the following information will be displayed.
       
             "DiagError aaaaaaaa "
       
          where
       
             aaaaaaaa is the Diagnostic Error Code
       

  <b><i><u>Revision History:</u></i></b>
<a name="SATA_DEBUG_REVISION_HISTORY_365"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="SATA_DEBUG_CMD_DESCRIPTION_390"></a>
<!--SUBSECTION--><a name="SATA Debug Athos Shanghai 390"></a><hr align=left width="75%"><b> SATA Debug Athos Shanghai 390 (Level F 'z')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    The SATA Debug command executes the specified SATA Debug function for the Athos
    Shanghai 390.

  <b><i><u>Input Parameters:</u></i></b>
<a name="SATA_DEBUG_PARM_390"></a>
    0 - Sub-command ID.
    
        This parameter specifies the ID of the SATA Debug sub-command to be executed.
    
            0 = Peek/Poke SATA registers
    
            1 = Dump SATA registers
    
            2 = Toggle Phy
    
            3 = Send ALIGN pattern
    
            4 = Send High Frequency (D10.2) pattern
    
            5 = Send Mid Frequency (D24.3) pattern
    
            6 = Send Lone Bit pattern
    
            7 = Send Low Frequency (K28.7) pattern
    
            8 = Send User Specified pattern
    
            9 = Send PRBS pattern
    
            A = Enable PRBS checker and watch the results
                (Note: This sub-command never returns.)
    
            B = Toggle TX SSC
    
            C = Wait for OOB
    
            D = Toggle speed
    
            E = Set OOB Chirp style
    
            F = Enable Test Muxes
    
            10 = Phy Power Mode
    
            11 = Loopback Mode
    
            12 = EyeQ data
        
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: None
    
    If Parameter 0 is equal to 0 (Peek / Poke SATA Registers)

<a name="PEEK_POKE_SATA_REGS_PARM_390"></a>
       0 - Peek/Poke SATA registers sub-command (0)
       
             Type:    Unsigned 16-bit value
       
             Range:   0
       
             Default: None
       1 - Register group
       
           In the Super10 code this parameter selected the register group (Normal SATA
           registers or SSPI registers) to be read or written.  In the Super10 Yuma
           architecture these registers shared the same address space and a page bit
           determined which registers were being accessed.  In the Delta architecture
           each register group has its own, unique address space, so this parameter is
           no longer needed.
        
             Type:    Unsigned 16 bit
       
             Range:   1 - 2
       
             Default: NA
       
       2 - Register Offset.
       
           This parameter specifies the byte offset from the start of the SATA registers
           to the register to be read or written.
       
             Type:    Unsigned 32-bit value
       
             Range:   0 to 0xffffffff
       
             Default: None
       
       3 - Register Data.
       
           This parameter specifies the data to be written to the specified register.  If
           this parameter is not entered, the register will be read and its value displayed.
       
             Type:    Unsigned 16-bit value
       
             Range:   0 to 0xffff
       
             Default: None
       
    If Parameter 0 is equal to 8 (Send User Pattern)

<a name="SEND_USER_PATTERN_PARM_390"></a>
       0 - Send User Specified pattern sub-command (8)
       
             Type:    Unsigned 16-bit value
       
             Range:   8
       
             Default: None
       1 - Pattern.
       
           This parameter specifies the 16-bit pattern to be sent.
        
             Type:    Unsigned 16-bit value
       
             Range:   0 to 0xffff
       
             Default: None
       
    If Parameter 0 is equal to 0xE (Set OOB Type)

<a name="SET_OOB_TYPE_PARM_390"></a>
       0 - Set OOB Chirp style sub-command (0xE)
       
             Type:    Unsigned 16-bit value
       
             Range:   0xE
       
             Default: None
       1 - OOB Type.
       
           This parameter specifies the OOB Type to be set.
       
                1 = Normal ALIGN
                2 = Normal D24.3
                3 = Bit Doubled ALIGN
                4 = Bit Doubled D24.3
        
             Type:    Unsigned 8-bit value
       
             Range:   1 to 4
       
             Default: None
       

  <b><i><u>Output Data:</u></i></b>
    If Parameter 0 is equal to 0 (Peek / Poke SATA Registers)

<a name="SATA_RW_REG_DATA_390"></a>
       If no error occurred and the SATA register was read, the following information will
       be displayed.
       
             "    SATA dddddddd eeee"
             "    Phy  dddd ee"
       
          where
       
             SATA/Phy is the type of the SATA register that was read
       
             dddddddd or dddd is the address of the SATA or Phy register that was read
       
             eeee or ee is the register value
       
       If no error occurred and the SATA register was written, the following information
       will be displayed.
       
             "    SATA hhhhhhhh iiii --> jjjj = llll"
             "    Phy  hhhh iiii --> jj = ll"
       
          where
       
             gggg or gg is the offset of the register that was written
       
             hhhhhhhh or hhhh is the address of the register that was written
       
             iiii or ii is the value read from the register before it was written
       
             jjjj or jj the value with which the register was written
       
             llll or ll is the value read from the register after it was written
       
    If Parameter 0 is equal to 1 (Dump SATA registers)

<a name="SATA_REG_DUMP_390"></a>
       If no error occurred, the following information will be displayed.
       
             "ATA registers"
             "cccc:  dddd dddd dddd ... dddd"  (repeated)
       
             "SATA SSIP registers"
             "cccc:  dddd dddd dddd ... dddd"  (repeated)
       
             "SATA Vis Mux registers"
             "cccc:  dddd dddd dddd ... dddd"  (repeated)
       
             "SATA Core TXB registers"
             "cccc:  dddd dddd dddd ... dddd"  (repeated)
       
             "SATA Core TXW registers"
             "cccc:  dddd dddd dddd ... dddd"  (repeated)
       
             "SATA Core TXWB registers"
             "cccc:  dddd dddd dddd ... dddd"  (repeated)
       
             "SATA Core Test registers"
             "cccc:  dddd dddd dddd ... dddd"  (repeated)
       
          where
       
             cccc is the address of the first register in the row
       
             dddd is the register value
       
    If Parameter 0 is equal to 2 (Toggle Phy)

<a name="SATA_PHY_STATE_390"></a>
       If no error occurred, the following information will be displayed.
       
          "Phy Disabled"                         or
          "Phy Enabled - force from initial"     or
          "Invalid Phy State"
       
    If Parameter 0 is equal to 3 (Send ALIGN pattern) or
                               4 (Send High Frequency pattern) or
                               5 (Send Mid Frequency pattern) or
                               6 (Send Lone Bit pattern) or
                               7 (Send Low Frequency pattern) or
                               8 (Send User Specified pattern) or
                               9 (Send PRBS pattern)

<a name="SATA_SEND_PATTERN_DATA_390"></a>
       If no error occurred, the following information will be displayed.
       
          "Phy spew ALIGN primitives"
          "Cycle power to end"                      or
       
          "Phy spew High freq pattern (D10.2)"
          "Cycle power to end"                      or
       
          "Phy spew Mid freq pattern (D24.3)"
          "Cycle power to end"                      or
       
          "Phy spew Lone Bit pattern (0x0C8B)"
          "Cycle power to end"                      or
       
          "Phy spew Low freq pattern (K28.7)"
          "Cycle power to end"                      or
       
          "Phy spew Generic pattern"
          "Cycle power to end"                      or
       
          "Phy spew PRBS pattern"
       
          "Phy spew Invalid pattern"
       
    If Parameter 0 is equal to A (Enable PRBS checker and watch the results)

<a name="SATA_WATCH_PRBS_DATA_390"></a>
       If no error occurred, the following information will be displayed.
       
             "PRBS Checker enabled"
             "Cycle power to end"
             "Press CTRL/Z to return"
             "PRBS loop ccccc: ***...*"    (repeated)
       
          where
       
             ccccc is the number of times the Error Count saturated and was reset to zero
                   and a '*' is output for each error that is detected.
       
    If Parameter 0 is equal to B (Toggle TX SSC)

<a name="SATA_SSC_STATE_390"></a>
       If no error occurred, the following information will be displayed.
       
          "Enable SSC"      or
          "Disable SSC"
       
    If Parameter 0 is equal to C (Wait for OOB)

<a name="SATA_OOB_STATE_390"></a>
       If no error occurred, the following information will be displayed.
       
          "OOB Test"                                      and
          "Waiting for COMRESET"                          and / or
          "Phy went not ready, probably saw COMRESET"     and / or
          "COMRESET detected"                             and / or
          "Waiting for COMWAKE"                           and / or
          "COMWAKE detected"                              and / or
          "Invalid OOB State"
       
    If Parameter 0 is equal to D (Toggle speed)

<a name="SATA_SPEED_390"></a>
       If no error occurred, the following information will be displayed.
       
          "Speed: 1.5gbit"     or
          "Speed: 3.0gbit"
       
    If Parameter 0 is equal to 0xE (Set OOB Type)

<a name="OOB_TYPE_390"></a>
       If no error occurred, the following information will be displayed.
       
          "Normal ALIGN"          or
          "Normal D24.3"          or
          "Bit doubled ALIGN"     or
          "Bit doubled D24.3"     or
          "Invalid OOB Type"
       
    Else

<a name="GENERIC_ERROR"></a>
       If an error occurred, the following information will be displayed.
       
             "DiagError aaaaaaaa "
       
          where
       
             aaaaaaaa is the Diagnostic Error Code
       

  <b><i><u>Revision History:</u></i></b>
<a name="SATA_DEBUG_REVISION_HISTORY_390"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="SAVE_ADAPTIVES_TO_FLASH_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Save Adaptives To Flash"></a><hr align=left width="75%"><b> Save Adaptives To Flash (Level 7 'w' or Level T 'W')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    The Save Adaptives To Flash command writes the adaptives currently in memory to flash.
    This command takes about 10 seconds to complete.

  <b><i><u>Quick Help:</u></i></b>
<a name="SAVE_ADAPTIVES_TO_FLASH_QUICK_HELP"></a>
    "SaveAdaptivesToFlash, w[Seg],,22";
    "SaveAdaptivesToFlash, W[Seg],,22";

  <b><i><u>Input Parameters:</u></i></b>
<a name="SAVE_ADAPTIVES_TO_FLASH_PARM"></a>
     0 - Which adaptive set to save
    
         This parameter specifies which adaptives set to save.
    <font color=red>
         NOTE: If you specifiy an adaptive set that the drive does not have in its flash,
               the drive will flash LED.
         NOTE: This command will only work once per power cycle.
    </font>
    
         0 CAP   Controller adaptive parameters
         1 SAP   Servo adaptive parameters
         2 RAP   Read / write adaptive parameters
         3 IAP   Interface Adaptive parameters
    
           Type:    Unsigned 32-bit value
    
           Range:   0 to 0xFFFFFFFF
    
           Default: 0
    
     1 - Not used.
    
     2 - Valid Command Key.
    
         This value must be 0x22 for the command to execute.
    
           Range:   0x22
    
           Default: None
    

  <b><i><u>Output Data:</u></i></b>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    

  <b><i><u>Examples:</u></i></b>

    Example #1:
    To save current RAP values to flash:

          F3 7>w2,,22
       or F3 T>W2,,22

    Example #2:
    To save current CAP values to flash:
          
          F3 7>w0,,22
       or F3 T>W0,,22

  <b><i><u>Revision History:</u></i></b>
<a name="SAVE_ADAPTIVES_TO_FLASH_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0002.0000   Add valid command key protection.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="SCAN_TRACK_FOR_SERVO_DEFECTS_AND_ZAP_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Scan Track for Servo Defects and ZAP"></a><hr align=left width="75%"><b> Scan Track for Servo Defects and ZAP (Level 4 'l')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command scans the target track for servo defects and ZAPs.

  <b><i><u>Quick Help:</u></i></b>
<a name="SCAN_TRACK_FOR_SERVO_DEFECTS_AND_ZAP_QUICK_HELP"></a>
    "ScanTrackForServoDefectsAndZap, l[RdPositionOpt]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="SCAN_TRACK_FOR_SERVO_DEFECTS_AND_ZAP_PARM"></a>
    0 - Scan at Read Position option.
    
        If this parameter is entered, the scan will be performed at the read position,
        else the scan will be performed at the write position.
    
          Type:    Unsigned 8-bit value
    
          Range:   0 to 0xFF
    
          Default: None
    

  <b><i><u>Output Data:</u></i></b>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    

  <b><i><u>Revision History:</u></i></b>
<a name="SCAN_TRACK_FOR_SERVO_DEFECTS_AND_ZAP_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="SEEK_CYL_TO_CYL_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Seek Repeatedly Between Physical Cylinders"></a><hr align=left width="75%"><b> Seek Repeatedly Between Physical Cylinders (Level 2 or 3 'O')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    The Seek From Cyl To Cyl commmand seeks repeatedly from the cylinder in parameter 0 to
    the cylinder in parameter 1 for the specified number of 2-seek cycles or the specified
    duration.

    The Butterfly Seek Test commmand performs the following seeks on the specified head:

    1) Seek to specified 1st ( minimum cyl addr , OD ) cylinder, then to specified
       2nd ( maximum cyl addr , ID ) cylinder.
    2) Repeat Steps 1) until test duration or desired number
       seeks is complete.

  <b><i><u>Quick Help:</u></i></b>
<a name="SEEK_CYL_TO_CYL_QUICK_HELP"></a>
    "SeekFromCylToCyl, O[StartPhyCyl0],[StartPhyCyl1],[NumSkPairs],[NumSeconds],[Hd]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="BUTTERFLY_OR_CYL_TO_CYL_SEEK_TEST_PARM"></a>
    
    0 - Starting first Physical cylinder of seek
          Expected to be OD-most bound, but code functions correctly with either OD or ID .
    
          Type:    Signed 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: Minimum ( OD ) physical cylinder for current head
    
    
    1 - Starting Second Physical cylinder of seek
          Expected to be ID-most bound, but code functions correctly with either OD or ID .
    
          Type:    Signed 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: Maximum ( ID ) physical cylinder for current head
    
    
    2 - Number of seek pairs ( a seek to "second" cylinder, then  to "first" ) to do
          for this test if Parameter 3 not entered,
        ELSE time in seconds to run seek test
        ELSE if == 0 , continue test for large arbitrary time .
    
          Type:    Unigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: 5 ( Seconds )
    
    
    
    3 - Select test duration to be time or number of seek pairs. If not entered ,
        perform Parameter 2 seek pairs .  If entered, run seeks for Parameter 2 seconds,
        for "forever", or for number of seconds specified by parameter 2 .
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: 0 ( Perform counted seeks, not timed )
    
    
    4 - Head on which to perform seek test
    
          Type:    Unsigned 8-bit value
    
          Range:   0 to 0xFF
    
          Default: 0
    

  <b><i><u>Output Data:</u></i></b>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    

  <b><i><u>Revision History:</u></i></b>
<a name="SEEK_CYL_TO_CYL_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="SEEK_TO_LBA_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Seek to LBA"></a><hr align=left width="75%"><b> Seek to LBA (Level A 'S')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command performs a seek to the specified User or System Area LBA (Logical Block
    Address).  If no address is specified, this command will seek to the next Test Space
    LBA.

  <b><i><u>Quick Help:</u></i></b>
<a name="SEEK_TO_LBA_QUICK_HELP"></a>
    "SkToLba, S[LbaHi],[LbaLo],[Offset],[OffsetUnitsOpt],[SkType],[Options]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="SEEK_TO_LBA_PARM"></a>
    0 - LBA or LBA High.
    
        If Parameter 1 is not entered, then this parameter contains the 32-bit LBA to
        which the seek is to be performed.  If Parameter 1 is entered, then this parameter
        contains the upper 16-bits of the LBA to which the seek is to be performed.
    
        If Parameter 4 is entered, then the specified LBA is located in the System
        Area, else it's located in the User Area.
    
          Type:    Unsigned 32-bit value, if Parameter 1 is not entered
                   Unsigned 16-bit value, if Parameter 1 is entered
    
          Range:   0 to 0xffffffff, if Parameter 1 is not entered
                   0 to 0xffff, if Parameter 1 is entered
    
          Default: None.  If this parameter is not entered and Parameter 1 is entered,
                   the upper 16-bits of the LBA will be set equal to zero and the lower
                   16-bits of the LBA will be set equal to the Parameter 1 value.  If
                   both Parameter 0 and 1 are not entered, the LBA will be set to the
                   next LBA in the test space.
    
    1 - LBA Low.
    
        This parameter contains the lower 16-bits of the LBA to which the seek is to be
        performed.
    
        If Parameter 4 is entered, then the specified LBA is located in the System Area,
        else it's located in the User Area.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xffff
    
          Default: None.  If this parameter is not entered and Parameter 0 is entered,
                   the 32-bit LBA will be set equal to the Parameter 0 value.  If both
                   Parameter 0 and 1 are not entered, the LBA will be set to the next
                   LBA in the test space.
    
    2 - Track Follow Offset value.
    
        This parameter is a signed 16-bit number representing the amount of tracking
        offset to apply in the servo system.  If Parameter 3 is equal to 0, the specified
        offset will be in units of 1/256th of the servo track width.  If Parameter 3 is
        equal to 1, the specified offset will be in units of 0.1% of the data track width.
    
          Type:    Signed 16-bit value
    
          Range:   0x8000 to 0x7FFF
    
          Default: 0
    
    3 - Track Follow Offset Units option.
      
        This parameter specifies the units of the Track Follow Offset value.  If this
        parameter is equal to 0, the specified offset will be in units of 1/256th of the
        servo track width.  If this parameter is equal to 1, the specified offset will
        be in units of 0.1% of the data track width.
    
          Type:    Unsigned 8-bit value
    
          Range:   0 or 1
    
          Default: 0 (Offset is in units of 1/256th of the servo track width)
    
    4 - Seek Type.
    
        This parameter specifies whether the seek should be performed to the read, write
        or write header track follow position.
    
            0 = Seek to the read track follow position
            1 = Seek to the write track follow position
            2 = Seek to the write header track follow position
    
          Type:    Unsigned 8-bit value
    
          Range:   0 to 0xFF
    
          Default: Seek to the read track follow position
    
    5 - Options.
    
        This parameter is a bit-significant value that allows the user to select the
        following options.
    
          Bits 15-2:  not used.
    
          Bit 1:      Disable Reload Channel Parameters With Seek Flag.
    
                      If this bit is set, the channel parameters will not be reloaded
                      into the channel registers with the seek, else the channel
                      parameters will be reloaded into the channel registers.
    
          Bit 0:      System Area Flag.
    
                      If this bit is set, Parameter 0 specifies a System Area LBA,
                      else Parameter 0 specifies a User Area LBA.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: 0    (Reload the channel paramters,
                         Seek to user area)
    

  <b><i><u>Output Data:</u></i></b>
<a name="RW_SEEK_OP_STATUS"></a>
        If an error occurred, the following information will be displayed.
    
              "DiagError aaaaaaaa R/W Status c R/W Error dddddddd"
    
           and
    
              "Target User LBA eeeeeeee LLL CHS ffffff.g.hhhh PLP CHS iiiiii.j.kkkk"
    
           or
    
              "Target System LBA eeeeeeee LLL CHS ffffff.g.hhhh PLP CHS iiiiii.j.kkkk"
    
           where
    
              aaaaaaaa is the Diagnostic Error Code
    
              c is the status returned by the R/W subsystem
    
              dddddddd is the error code returned by the R/W subsystem
    
              eeeeeeee is a Disk Logical Block Address on the track to which the seek was
              performed
    
              ffffff is the Logical Cylinder Address of the track to which the seek was
              performed
    
              g is the Logical Head Address of the track to which the seek was performed
    
              hhhh is a Logical Sector Address on the track to which the seek was performed
    
              iiiiii is the Physical Cylinder Address of the track to which the seek was
              performed
    
              j is the Logical Head Address of the track to which the seek was performed
    
              kkkk is a Physical Sector Address on the track to which the seek was performed
    
        If the Verbose Formatted ASCII Data Output Mode is selected, the Verbose Mode option
        bits will enable the following data to be output when set.
    
           Bit 0:      Enables the R/W Status and R/W Error to be displayed
           Bit 1:      NA
           Bit 2:      Enables the Track Position and Track Follow Offset to be displayed
           Bit 3:      Enables the Target Address to be displayed
           Bit 4:      NA
           Bit 5:      NA
           Bit 6:      Enables the Elapsed Time to be displayed
           Bits 31-7:  NA
    
        If Bit 0 is set, the R/W Status and R/W Error will be displayed even if no error
        occurred.  The data displayed will be formatted as shown above.
    
        If Bit 2 is set, the Track Position and Track Follow Offset will be displayed as
        follows.
    
              "Read Position, Persistent Offset m.m% Total Offset n.n%"          or
              "Write Position, Persistent Offset m.m% Total Offset n.n%"         or
              "Write Header Position, Persistent Offset m.m% Total Offset n.n%"
    
           where
    
              m.m is the Persistent Track Follow Offset in units of percentage of track width
    
              n.n is the Total Track Follow Offset in units of percentage of track width
    
        If Bit 3 is set, the Target Address will be displayed even if no error occurred.
        The data displayed will be formatted as shown above.
    
        If Bit 6 is set, the Elapsed Time for the seek operation will be displayed.
<a name="ELAPSED_TIME"></a>
    
       "Elapsed Time a mins b secs"  or
       "Elapsed Time b.c secs"       or
       "Elapsed Time c.d msecs"
    
    where
    
       a is minutes
       b is seconds
       c is milliseconds
       d is microseconds
    
    
<a name="RW_SEEK_FILTER_OUTPUT"></a>
    Regardless of verbose mode status, the following output may occur:
    
    If a seek mode was specified, the Elapsed Time for the seek operation will be displayed.
    The data displayed will be formatted as shown above, under Bit 6 of verbose mode.
    
    Some commands use an output control bit flag (specified in the input parameters above).
    
    If "Output Control Flag- Data Track Width" is set, the following information will be displayed:
    
          "Data Track Width wwww"
    
       where
    
          wwww is the width of a data track, in units of servo position. Q14 scaling,
             so 0x4000 is the width of a data track at nominal TPI (before VTPI and warping).
             Hexadecimal output.
    

  <b><i><u>Revision History:</u></i></b>
<a name="SEEK_TO_LBA_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="SEEK_TO_LOGICAL_CYL_AND_HD_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Seek to Logical Cylinder and Head"></a><hr align=left width="75%"><b> Seek to Logical Cylinder and Head (Levels 2, 3, 4, 7, 8, H 'S')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This commmand performs a seek operation to the specified User or System Area logical
    cylinder and logical head address.  If no address is specified, this command will
    seek to the next logical track in the Test Space.

  <b><i><u>Quick Help:</u></i></b>
<a name="SEEK_TO_LOGICAL_CYL_AND_HD_QUICK_HELP"></a>
    "SkToLogCyl, S[Cyl],[Hd],[Offset],[OffsetUnitsOpt],[SkType],[Options]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="SEEK_TO_LOGICAL_CHS_PARM"></a>
    0 - Logical Cylinder Address.
    
        If Parameter 4 is not entered, this parameter is the address of the User Area
        logical cylinder to which the seek is to be performed.  If Parameter 4 is
        entered, this parameter is the address of the System Area logical cylinder to
        which the seek is to be performed.  If both Parameter 0 and 1 are not entered,
        a seek will be performed to the next logical track in the Test Space.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: None
    
    1 - Logical Head Address.
    
        If entered, this parameter contains the address of the logical head to which the
        seek is to be performed.  If both Parameter 0 and 1 are not entered, a seek will
        be performed to the next logical track in the Test Space.
    
          Type:    Unsigned 8-bit value
    
          Range:   0 to 0xFF
    
          Default: None
    
    2 - Track Follow Offset value.
    
        This parameter is a signed 16-bit number representing the amount of tracking
        offset to apply in the servo system.  If Parameter 3 is equal to 0, the specified
        offset will be in units of 1/256th of the servo track width.  If Parameter 3 is
        equal to 1, the specified offset will be in units of 0.1% of the data track width.
    
          Type:    Signed 16-bit value
    
          Range:   0x8000 to 0x7FFF
    
          Default: 0
    
    3 - Track Follow Offset Units option.
      
        This parameter specifies the units of the Track Follow Offset value.  If this
        parameter is equal to 0, the specified offset will be in units of 1/256th of the
        servo track width.  If this parameter is equal to 1, the specified offset will
        be in units of 0.1% of the data track width.
    
          Type:    Unsigned 8-bit value
    
          Range:   0 or 1
    
          Default: 0 (Offset is in units of 1/256th of the servo track width)
    
    4 - Seek Type.
    
        This parameter specifies whether the seek should be performed to the read, write
        or write header track follow position.
    
            0 = Seek to the read track follow position
            1 = Seek to the write track follow position
            2 = Seek to the write header track follow position
    
          Type:    Unsigned 8-bit value
    
          Range:   0 to 0xFF
    
          Default: Seek to the read track follow position
    
    5 - Options.
    
        This parameter is a bit-significant value that allows the user to select the
        following options.
    
          Bits 15-3:  not used.
    
          Bit 2:      Display the Data Track Width.
    
                      If this bit is set, the width of the destination track will be displayed
                      in Q14 servo counts.
    
          Bit 1:      Disable Reload Channel Parameters With Seek Flag.
    
                      If this bit is set, the channel parameters will not be reloaded into the
                      channel registers with the seek, else the channel parameters will be
                      reloaded into the channel registers.
    
          Bit 0:      System Area Flag.
    
                      If this bit is set, Parameter 0 specifies a System Area logical
                      cylinder, else Parameter 0 specifies a User Area logical cylinder.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: 0    (Reload the channel paramters,
                         Seek to user area)
    

  <b><i><u>Output Data:</u></i></b>
<a name="RW_SEEK_OP_STATUS"></a>
        If an error occurred, the following information will be displayed.
    
              "DiagError aaaaaaaa R/W Status c R/W Error dddddddd"
    
           and
    
              "Target User LBA eeeeeeee LLL CHS ffffff.g.hhhh PLP CHS iiiiii.j.kkkk"
    
           or
    
              "Target System LBA eeeeeeee LLL CHS ffffff.g.hhhh PLP CHS iiiiii.j.kkkk"
    
           where
    
              aaaaaaaa is the Diagnostic Error Code
    
              c is the status returned by the R/W subsystem
    
              dddddddd is the error code returned by the R/W subsystem
    
              eeeeeeee is a Disk Logical Block Address on the track to which the seek was
              performed
    
              ffffff is the Logical Cylinder Address of the track to which the seek was
              performed
    
              g is the Logical Head Address of the track to which the seek was performed
    
              hhhh is a Logical Sector Address on the track to which the seek was performed
    
              iiiiii is the Physical Cylinder Address of the track to which the seek was
              performed
    
              j is the Logical Head Address of the track to which the seek was performed
    
              kkkk is a Physical Sector Address on the track to which the seek was performed
    
        If the Verbose Formatted ASCII Data Output Mode is selected, the Verbose Mode option
        bits will enable the following data to be output when set.
    
           Bit 0:      Enables the R/W Status and R/W Error to be displayed
           Bit 1:      NA
           Bit 2:      Enables the Track Position and Track Follow Offset to be displayed
           Bit 3:      Enables the Target Address to be displayed
           Bit 4:      NA
           Bit 5:      NA
           Bit 6:      Enables the Elapsed Time to be displayed
           Bits 31-7:  NA
    
        If Bit 0 is set, the R/W Status and R/W Error will be displayed even if no error
        occurred.  The data displayed will be formatted as shown above.
    
        If Bit 2 is set, the Track Position and Track Follow Offset will be displayed as
        follows.
    
              "Read Position, Persistent Offset m.m% Total Offset n.n%"          or
              "Write Position, Persistent Offset m.m% Total Offset n.n%"         or
              "Write Header Position, Persistent Offset m.m% Total Offset n.n%"
    
           where
    
              m.m is the Persistent Track Follow Offset in units of percentage of track width
    
              n.n is the Total Track Follow Offset in units of percentage of track width
    
        If Bit 3 is set, the Target Address will be displayed even if no error occurred.
        The data displayed will be formatted as shown above.
    
        If Bit 6 is set, the Elapsed Time for the seek operation will be displayed.
<a name="ELAPSED_TIME"></a>
    
       "Elapsed Time a mins b secs"  or
       "Elapsed Time b.c secs"       or
       "Elapsed Time c.d msecs"
    
    where
    
       a is minutes
       b is seconds
       c is milliseconds
       d is microseconds
    
    
<a name="RW_SEEK_FILTER_OUTPUT"></a>
    Regardless of verbose mode status, the following output may occur:
    
    If a seek mode was specified, the Elapsed Time for the seek operation will be displayed.
    The data displayed will be formatted as shown above, under Bit 6 of verbose mode.
    
    Some commands use an output control bit flag (specified in the input parameters above).
    
    If "Output Control Flag- Data Track Width" is set, the following information will be displayed:
    
          "Data Track Width wwww"
    
       where
    
          wwww is the width of a data track, in units of servo position. Q14 scaling,
             so 0x4000 is the width of a data track at nominal TPI (before VTPI and warping).
             Hexadecimal output.
    

  <b><i><u>Examples:</u></i></b>
    Example #1:
       To seek to a logical cylinder and head at the read track follow position
       (in this case logical cylinder 45 head 1)

          F3 2>S45,1

    Example #2:
       To seek to a logical cylinder and head at the write track follow position
       (in this case logical cylinder 45 head 1)

          F3 2>S45,1,,,1

    Example #3:
       To seek to a logical cylinder and head at the write header track follow position
       (in this case logical cylinder 45 head 1)

          F3 2>S45,1,,,2

    Example #4:
       To seek to a logical cylinder and head at the read track follow position with
       an additional offset specified in servo counts
       (in this case logical cylinder 45 head 1 at an offset of plus 100/256ths of
       the servo track width)

          F3 2>S45,1,64

    Example #5:
       To seek to a logical cylinder and head at the read track follow position with
       an additional offset specified in percent of data track width
       (in this case logical cylinder 45 head 1 at an offset of -10% of the data track
       width)

          F3 2>S45,1,FFF6,1

    Example #6:
       To seek to a logical cylinder and head at the read track follow position and
       display the data track width in Q14 servo counts
       (in this case logical cylinder 45 head 1)

          F3 2>S45,1,,,,4

    Example #7:
       To seek to a logical cylinder and head at the read track follow position and
       disable reloading of the channel parameters by the seek
       (in this case logical cylinder 45 head 1)

          F3 2>S45,1,,,,2

    Example #8:
       To seek to a system logical cylinder and head at the read track follow position
       (in this case logical system cylinder 54 head 0)

          F3 2>S54,0,,,,1

  <b><i><u>Revision History:</u></i></b>
<a name="SEEK_TO_LOGICAL_CYL_AND_HD_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0001.0001   Changed the parameters to allow some fine output control. Added a new
                parameter to allow the output of the data track width of the destination
                track, in Q14 servo counts.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="SEEK_TO_PHYSICAL_CYL_AND_HD_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Seek to Physical Cylinder and Head"></a><hr align=left width="75%"><b> Seek to Physical Cylinder and Head (Levels 2, 3, F 's')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This commmand performs a seek operation to the specified physical cylinder and logical
    head address. If no address is specified, this command will seek to the next physical
    track in the Test Space.

  <b><i><u>Quick Help:</u></i></b>
<a name="SEEK_TO_PHYSICAL_CYL_AND_HD_QUICK_HELP"></a>
    "SkToPhyCyl, s[Cyl],[Hd],[ValidKey],[Offset],[OffsetUnitsOpt],[SkType],[Options]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="SEEK_TO_PHYSICAL_CHS_PARM"></a>
    0 - Physical Cylinder Address.
    
        If entered, this parameter is the address of the physical cylinder to which the
        seek is to be performed.  If both Parameter 0 and 1 are not entered, a seek will
        be performed to the next physical track in the Test Space.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: None
    
    1 - Logical Head Address.
    
        If entered, this parameter is the address of the logical head to which the seek
        is to be performed.  If both Parameter 0 and 1 are not entered, a seek will be
        performed to the next physical track in the Test Space.
    
          Type:    Unsigned 8-bit value
    
          Range:   0 to 0xFF
    
          Default: None
    
    2 - Valid Command Key.
    
        This parameter must be equal to 22 Hex.
    
          Type:    Unsigned 8-bit value
    
          Range:   0x22
    
          Default: None
    
    3 - Track Follow Offset value.
    
        This parameter is a signed 16-bit number representing the amount of tracking
        offset to apply in the servo system.  If Parameter 4 is equal to 0, the specified
        offset will be in units of 1/256th of the servo track width.  If Parameter 4 is
        equal to 1, the specified offset will be in units of 0.1% of the data track width.
    
          Type:    Signed 16-bit value
    
          Range:   0x8000 to 0x7FFF
    
          Default: 0
    
    4 - Track Follow Offset Units option.
      
        This parameter specifies the units of the Track Follow Offset value.  If this
        parameter is equal to 0, the specified offset will be in units of 1/256th of the
        servo track width.  If this parameter is equal to 1, the specified offset will
        be in units of 0.1% of the data track width.
    
          Type:    Unsigned 8-bit value
    
          Range:   0 or 1
    
          Default: 0 (Offset is in units of 1/256th of the servo track width)
    
    5 - Seek Type.
    
        This parameter specifies whether the seek should be performed to the read, write or
        write header track follow position.
    
            0 = Seek to the read track follow position
            1 = Seek to the write track follow position
            2 = Seek to the write header track follow position
    
          Type:    Unsigned 8-bit value
    
          Range:   0 to 0xFF
    
          Default: Seek to the read track follow position
    
    6 - Options.
    
        This parameter is a bit-significant value that allows the user to select the
        following options.
    
          Bits 15-1:  not used.
    
          Bit 0:      Disable Reload Channel Parameters With Seek Flag.
    
                      If this bit is set, the channel parameters will not be reloaded
                      into the channel registers with the seek, else the channel
                      parameters will be reloaded into the channel registers.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: 0    (Reload the channel paramters)
    

  <b><i><u>Output Data:</u></i></b>
<a name="RW_SEEK_OP_STATUS"></a>
        If an error occurred, the following information will be displayed.
    
              "DiagError aaaaaaaa R/W Status c R/W Error dddddddd"
    
           and
    
              "Target User LBA eeeeeeee LLL CHS ffffff.g.hhhh PLP CHS iiiiii.j.kkkk"
    
           or
    
              "Target System LBA eeeeeeee LLL CHS ffffff.g.hhhh PLP CHS iiiiii.j.kkkk"
    
           where
    
              aaaaaaaa is the Diagnostic Error Code
    
              c is the status returned by the R/W subsystem
    
              dddddddd is the error code returned by the R/W subsystem
    
              eeeeeeee is a Disk Logical Block Address on the track to which the seek was
              performed
    
              ffffff is the Logical Cylinder Address of the track to which the seek was
              performed
    
              g is the Logical Head Address of the track to which the seek was performed
    
              hhhh is a Logical Sector Address on the track to which the seek was performed
    
              iiiiii is the Physical Cylinder Address of the track to which the seek was
              performed
    
              j is the Logical Head Address of the track to which the seek was performed
    
              kkkk is a Physical Sector Address on the track to which the seek was performed
    
        If the Verbose Formatted ASCII Data Output Mode is selected, the Verbose Mode option
        bits will enable the following data to be output when set.
    
           Bit 0:      Enables the R/W Status and R/W Error to be displayed
           Bit 1:      NA
           Bit 2:      Enables the Track Position and Track Follow Offset to be displayed
           Bit 3:      Enables the Target Address to be displayed
           Bit 4:      NA
           Bit 5:      NA
           Bit 6:      Enables the Elapsed Time to be displayed
           Bits 31-7:  NA
    
        If Bit 0 is set, the R/W Status and R/W Error will be displayed even if no error
        occurred.  The data displayed will be formatted as shown above.
    
        If Bit 2 is set, the Track Position and Track Follow Offset will be displayed as
        follows.
    
              "Read Position, Persistent Offset m.m% Total Offset n.n%"          or
              "Write Position, Persistent Offset m.m% Total Offset n.n%"         or
              "Write Header Position, Persistent Offset m.m% Total Offset n.n%"
    
           where
    
              m.m is the Persistent Track Follow Offset in units of percentage of track width
    
              n.n is the Total Track Follow Offset in units of percentage of track width
    
        If Bit 3 is set, the Target Address will be displayed even if no error occurred.
        The data displayed will be formatted as shown above.
    
        If Bit 6 is set, the Elapsed Time for the seek operation will be displayed.
<a name="ELAPSED_TIME"></a>
    
       "Elapsed Time a mins b secs"  or
       "Elapsed Time b.c secs"       or
       "Elapsed Time c.d msecs"
    
    where
    
       a is minutes
       b is seconds
       c is milliseconds
       d is microseconds
    
    
<a name="RW_SEEK_FILTER_OUTPUT"></a>
    Regardless of verbose mode status, the following output may occur:
    
    If a seek mode was specified, the Elapsed Time for the seek operation will be displayed.
    The data displayed will be formatted as shown above, under Bit 6 of verbose mode.
    
    Some commands use an output control bit flag (specified in the input parameters above).
    
    If "Output Control Flag- Data Track Width" is set, the following information will be displayed:
    
          "Data Track Width wwww"
    
       where
    
          wwww is the width of a data track, in units of servo position. Q14 scaling,
             so 0x4000 is the width of a data track at nominal TPI (before VTPI and warping).
             Hexadecimal output.
    

  <b><i><u>Revision History:</u></i></b>
<a name="SEEK_TO_PHYSICAL_CYL_AND_HD_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="SELECT_DATA_OUTPUT_MODE_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Select Data Output Mode"></a><hr align=left width="75%"><b> Select Data Output Mode (Level T 'O')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command selects the specified Data Output Mode.

  <b><i><u>Quick Help:</u></i></b>
<a name="SELECT_DATA_OUTPUT_MODE_QUICK_HELP"></a>
    "SelectDataOutputMode, O[Mode],[VerboseOpts]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="SELECT_DATA_OUTPUT_MODE_PARM"></a>
    0 - Data Output Mode.
    
        This parameter specifies the data output mode to be selected.
    
          0 = Quiet Mode.  This mode disables the outputting of all diagnostic status.
    
          1 = Raw Binary Mode.  This mode outputs the status packets returned by the
              diagnostic functions as raw binary data.
    
          2 = Raw ASCII Mode.  This function outputs an ASCII representation of the
              raw data returned in the status packets by the diagnostic functions.
    
          3 = Formatted ASCII Mode.  This function formats the data returned in the
              status packets by the diagnostic functions and outputs it as ASCII.
    
          4 = Verbose Formatted ASCII Mode.  This function formats the data returned in
              the status packets by the diagnostic functions and outputs it as ASCII.
              This mode will output additional information that is not typically output
              by the standard Formatted ASCII Mode.
    
          5 = Simplified Formatted ASCII Mode.  This function formats the data returned
              in the status packets by the diagnostic functions and outputs it as ASCII.
              This mode will simplfy the output information that is normally output by
              the standard Formatted ASCII Mode.
    
          Type:    Unsigned 8-bit value
    
          Range:   0 to 5
    
          Default: 3 (Formatted ASCII Mode)
    
    1 - Verbose Formatted ASCII Mode Options.
    
        This parameter is a bit-significant value that can be used to enable / disable
        the outputting of various verbose mode data.  Setting a bit enables the
        outputting of the verbose mode data associated with the bit.  Clearing a bit
        disables the outputting of the verbose mode data associated with the bit.  The
        data that is enabled or disabled by each bit is unique to each command and is
        described in the command's data output section.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xffffffff
    
          Default: 0xffffffff (Output all verbose data)
    

  <b><i><u>Output Data:</u></i></b>
    Displays the Data Output Mode that is selected.

  <b><i><u>Revision History:</u></i></b>
<a name="SELECT_DATA_OUTPUT_MODE_REVISION_HISTORY"></a>
    0001.0000   Initial revision.

<a name="SELECT_LOGICAL_HD_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Select Logical Head"></a><hr align=left width="75%"><b> Select Logical Head (Levels 2, 3, 4, 7 'H')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This commmand performs a seek operation to the specified logical head address.  If no
    address is specified, this command will seek to the next logical head in the Test Space.

  <b><i><u>Quick Help:</u></i></b>
<a name="SELECT_LOGICAL_HD_QUICK_HELP"></a>
    "SelectHd, H[Hd],[SkType],[Options]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="SELECT_LOGICAL_HD_PARM"></a>
    0 - Logical Head Address.
    
        If entered, this parameter is the address of the logical head to be selected.
        If Parameter 0 is not entered, the next logical head in the Test Space will be
        selected.
    
          Type:    Unsigned 8-bit value
    
          Range:   0 to 0xFF
    
          Default: None
    
    1 - Seek Type.
    
        This parameter specifies whether the seek should be performed to the read, write
        or write header track follow position.
    
            0 = Seek to the read track follow position
            1 = Seek to the write track follow position
            2 = Seek to the write header track follow position
    
          Type:    Unsigned 8-bit value
    
          Range:   0 to 0xFF
    
          Default: Seek to the read track follow position
    
    2 - Options.
    
        This parameter is a bit-significant value that allows the user to select the
        following options.
    
          Bits 15-1:  not used.
    
          Bit 0:      Disable Reload Channel Parameters With Seek Flag.
    
                      If this bit is set, the channel parameters will not be reloaded
                      into the channel registers with the seek, else the channel
                      parameters will be reloaded into the channel registers.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: 0    (Reload the channel paramters)
    

  <b><i><u>Output Data:</u></i></b>
<a name="RW_SEEK_OP_STATUS"></a>
        If an error occurred, the following information will be displayed.
    
              "DiagError aaaaaaaa R/W Status c R/W Error dddddddd"
    
           and
    
              "Target User LBA eeeeeeee LLL CHS ffffff.g.hhhh PLP CHS iiiiii.j.kkkk"
    
           or
    
              "Target System LBA eeeeeeee LLL CHS ffffff.g.hhhh PLP CHS iiiiii.j.kkkk"
    
           where
    
              aaaaaaaa is the Diagnostic Error Code
    
              c is the status returned by the R/W subsystem
    
              dddddddd is the error code returned by the R/W subsystem
    
              eeeeeeee is a Disk Logical Block Address on the track to which the seek was
              performed
    
              ffffff is the Logical Cylinder Address of the track to which the seek was
              performed
    
              g is the Logical Head Address of the track to which the seek was performed
    
              hhhh is a Logical Sector Address on the track to which the seek was performed
    
              iiiiii is the Physical Cylinder Address of the track to which the seek was
              performed
    
              j is the Logical Head Address of the track to which the seek was performed
    
              kkkk is a Physical Sector Address on the track to which the seek was performed
    
        If the Verbose Formatted ASCII Data Output Mode is selected, the Verbose Mode option
        bits will enable the following data to be output when set.
    
           Bit 0:      Enables the R/W Status and R/W Error to be displayed
           Bit 1:      NA
           Bit 2:      Enables the Track Position and Track Follow Offset to be displayed
           Bit 3:      Enables the Target Address to be displayed
           Bit 4:      NA
           Bit 5:      NA
           Bit 6:      Enables the Elapsed Time to be displayed
           Bits 31-7:  NA
    
        If Bit 0 is set, the R/W Status and R/W Error will be displayed even if no error
        occurred.  The data displayed will be formatted as shown above.
    
        If Bit 2 is set, the Track Position and Track Follow Offset will be displayed as
        follows.
    
              "Read Position, Persistent Offset m.m% Total Offset n.n%"          or
              "Write Position, Persistent Offset m.m% Total Offset n.n%"         or
              "Write Header Position, Persistent Offset m.m% Total Offset n.n%"
    
           where
    
              m.m is the Persistent Track Follow Offset in units of percentage of track width
    
              n.n is the Total Track Follow Offset in units of percentage of track width
    
        If Bit 3 is set, the Target Address will be displayed even if no error occurred.
        The data displayed will be formatted as shown above.
    
        If Bit 6 is set, the Elapsed Time for the seek operation will be displayed.
<a name="ELAPSED_TIME"></a>
    
       "Elapsed Time a mins b secs"  or
       "Elapsed Time b.c secs"       or
       "Elapsed Time c.d msecs"
    
    where
    
       a is minutes
       b is seconds
       c is milliseconds
       d is microseconds
    
    
<a name="RW_SELECT_HEAD_OUTPUT"></a>
    Regardless of verbose mode status, the following output will be displayed:
    
          "Hd h"
    
       where
    
          h is selected head
    

  <b><i><u>Revision History:</u></i></b>
<a name="SELECT_LOGICAL_HD_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="SELECT_SERVO_CONTROLLER_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Select Servo Controller"></a><hr align=left width="75%"><b> Select Servo Controller (Level 5 'G')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command allows for one of serveral different servo controllers to be selected.
    The servo controllers available have been pre-designed with dynamic characteristics
    which have been optimized for particular operating conditions.

  <b><i><u>Quick Help:</u></i></b>
<a name="SELECT_SERVO_CONTROLLER_QUICK_HELP"></a>
    "SelectServoController, G[Head],[Controller],[InputShift]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="SELECT_SERVO_CONTROLLER_PARM"></a>
    If no parameters are entered, then the command will display the current "controller"
    for all heads. Then the current "input shift" will be displayed.
    0 - Head
    
        This parameter specifies the head or heads to select the servo controller.
    
        If only parameter 0 is specified:
          The command will display the current "controller" selection for the specified head.
          Then the "input shift" will be displayed.
    
        If parameter 0 is specified,
        And either or both parameter 1 and parameter 2 are specified:
          The "controller" for the specified head is changed to the specified values and/or
          the "input shift" will be set to the specified value.
          Then the command will display the current "controller" for the specified head.
          Then the "input shift" will be displayed.
    
       If parameter 0 is NOT specified
       but either or both parameter 1 and parameter 2 are specified:
          All the current "controller" are changed to the specified values for all heads and/or
          the "input shift" will be changed to the specified value.
          The command will then display the current "controller" for all heads.
          Then the "input shift" will be displayed.
        
       Other combinations are invalid.
                                                                                                                                                                                                                                                                                                                                    
          Type:    Unsigned 8-bit value
    
          Range:   0 .. Max Head
    
          Default: None
    
    1 - Controller
    
        This parameter specifies the servo controller to be used.
    
          Type:    Unsigned 8-bit value
    
          Range:   Defined by Servo
    
          Default: None
    
    2 - Controller Input Shift
    
        This parameter specifies the Conroller Input Shift
    
          Type:    Unsigned 8-bit value
    
          Range:   Defined by Servo
    
          Default: None
    

  <b><i><u>Output Data:</u></i></b>
<a name="SELECT_SERVO_CONTROLLER_DATA"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
        If no error occurred, the following will be displayed
    
          Head Controller
          AA   BB
    
          Input Shift = CC
     
           where
    
              AA is the Head Number
    
              BB is the Controller Number selected for the specified head
    
              CC is the Input Shift value.
    
           Note:
              Controller Data will be either for a single head or for all heads
              depending on parameters selections when the diag is executed.
     

  <b><i><u>Revision History:</u></i></b>
<a name="SELECT_SERVO_CONTROLLER_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="SERVO_BATCH_TEST_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Servo Batch Test sub commands"></a><hr align=left width="75%"><b> Servo Batch Test sub commands (Level 4 'U')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    The Servo Batch Test command executes the specified servo batch tests
    function.

  <b><i><u>Quick Help:</u></i></b>
<a name="SERVO_BATCH_TEST_QUICK_HELP"></a>
    "ServoBatchTest, U[SubCmd],[SubCmdParm0],[SubCmdParm1],[SubCmdParm2]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="SERVO_BATCH_TEST_PARM"></a>
    0 - Sub-command ID.
    
        This parameter specifies the sub-command ID of the Servo Batch Test command
        to be executed.
    
            100D = Plot PES on Screen
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: None
    

    If Parameter 0 is equal to 100D (Plot PES on Screen)
<a name="PLOT_PES_ON_SCREEN_PARM"></a>
       0 - Plot PES on Screen sub-command ID (100D)
       
             Type:    Unsigned 16-bit value
       
             Range:   100D
       
             Default: None
       1 - Revs to collect for RRO calculation.
       
           This parameter specifies the revs to collect the PES data for RRO calculation.
           If this parameter is not entered, the default value is 100 revs.
       
             Type:    Unsigned 16-bit value
       
             Range:   0 to 0xffff
       
             Default: 100
       
       2 - Revs to collect for NRRO calculation.
       
           This parameter specifies the revs to collect the PES data for NRRO calculation.
           If this parameter is not entered, the default value is 100 revs.
       
             Type:    Unsigned 16-bit value
       
             Range:   0 to 0xffff
       
             Default: 100
       

  <b><i><u>Output Data:</u></i></b>
    If Parameter 0 is equal to 100D (Plot PES on Screen)
<a name="PLOT_PES_ON_SCREEN_DATA"></a>
<a name="GENERIC_ERROR"></a>
       If an error occurred, the following information will be displayed.
       
             "DiagError aaaaaaaa "
       
          where
       
             aaaaaaaa is the Diagnostic Error Code
       
           Track number, Write Fault Threshold, PES plot, RRO 3 Sigma, and NRRO 3 Sigma are
           displayed with the following format:
       
        01000.0, WFT 333 (+1.9E+1 %)
       
        000 FEF2 0060 013A         <                -       |  *     +               >
        001 FF10 FFE7 00BE         <                 -      *    +                   >
        002 FF08 FFDB 00BC         <                 -     *|    +                   >
        003 FED7 FFBF 00D0         <               -      * |     +                  >
        004 FE8C FF97 00E0         <             -       *  |      +                 >
        005 FE75 FF87 0153         <            -        *  |         +              >
        ......
        (Repeat for every servo sector)
       
        3 sigma RRO  = +4.92E-0 % track
        3 sigma NRRO = +7.08E-0 % track
        **End
       

  <b><i><u>Revision History:</u></i></b>
<a name="SERVO_BATCH_TEST_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="SERVO_BODE_PLOT_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Servo Bode Plot"></a><hr align=left width="75%"><b> Servo Bode Plot (Level 5, 'B')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command implements the Servo Bode Plot diagnostic. It is implemented as a
    single-frequency DFT with an injected sine-wave distrubance, which is either a current or
    position disturbance, depending on the selected measurement.
    
    It has the ability to perform a single frequency measurement or loop through a range of
    frequencies to create a swept-sine frequency response measurement.
    
    The measurement will be done at the current servo position.
    
    A special 'Trace Mode' is supported which will return the raw time-domain data for Signal1
    and Signal2. The data for only one frequency will be returned. If swept-sine measurement
    is done, then time-domain data will be returned for only the last frequency used.
 
  <b><i><u>Quick Help:</u></i></b>
<a name="SERVO_BODE_PLOT_CMD_QUICK_HELP"></a>
    "Servo Bode Plot, B[BodeType],[InjAmp],[Fmin],[Fmax],[NumFreq],[NumSamples],[EnableTracing]";
 
  <b><i><u>Input Parameters:</u></i></b>
<a name="SERVO_BODE_PLOT_CMD_PARM"></a>
    0 - Select the Bode measurement type.
    
        Parameter 0 is used to specify the type of servo bode measuement to be done.
<a name="BODE_TYPE_DESCRIPTION"></a>
          Note: for the following measurements, Signal1 is the 'output', Signal2 is the 'input',
          and the transfer function is output/input = Signal1/Signal2.
          
          If 0, then the diagnostic will be configured for an open-loop bode measurement,
          using vcm current disturbance.
             Signal1:    i16_Current2,
             Signal2:    i16_Current2Out,
             Injection:  i16_TrackingVcmDisturbanceCurrent
                                                                         
          If 1, then the diagnostic will be configured for a closed-loop bode measurement,
          using vcm current disturbance.
             Signal1:    i16_Current2,
             Signal2:    i16_TrackingVcmDisturbanceCurrent,
             Injection:  i16_TrackingVcmDisturbanceCurrent
          
          If 2, then the diagnostic will be configured for a structrual bode measurement,
          using vcm current disturbance.
             Signal1:    i16_DemodPositionError,
             Signal2:    i16_Current2Out,
             Injection:  i16_TrackingVcmDisturbanceCurrent
          
          If 3, then the diagnostic will be configured for an open-loop bode measurement,
          using position disturbance.
             Signal1:    i16_DemodPositionMeasurementIn,
             Signal2:    i16_DemodPositionMeasurementOut,
             Injection:  i16_TrackingDemodDisturbancePosition
          
          If 4, then the diagnostic will be configured for a sensitivity measurement,
          using position disturbance.
             Signal1:    i16_DemodPositionError,
             Signal2:    i16_TrackingDemodDisturbancePosition,
             Injection:  i16_TrackingDemodDisturbancePosition
    
          Type:    Hexadecimal value
    
          Range:   0 .. Maximum Number of Bode Types
    
          Default: 0 (Open Loop - Vcm current distrubance)
    
    1 - Specify the Injection Amplitude
    
        Parameter 1 specifies the peak amplitude of the injected sine-wave disturbance.
        For bode types using VCM current disturbance, the units will be DAC counts.  For
        bode types using pes distrubance, the units will be pes counts.
        
           
          Type:    Positive decimal value
    
          Range:
    
          Default: 400
    
    2 - Set the lowest frequency to be measured.
    
        Parameter 2 specifies lowest frequency in Hertz to be used for the servo bode
        measurement.
    
          Type:    Positive decimal value
    
          Range:   10 Herts to the Nyquist frequency
    
          Default: 10 Hz
    
    3 - Set the highest frequency to be measured.
    
        Parameter 3 specifies highest frequency in Hertz to be used for the servo bode
        measurement. This frequency must be greater than Parameter 2. Entering any value
        larger than the Nyquist frequency will default to the Nyquist frequency.
    
          Type:    Positive decimal value
    
          Range:   10 Herts to the Nyquist frequency
    
          Default: Nyquist frequency
    
    4 - Set the number of frequencies to use.
    
        Parameter 4 specifies number of linearly-spaced frequencies, between the
        minimum frequency (Parameter 2) and the maximum frequency (Parameter 3) to be used
        for the servo bode measurement.
    
          Type:    Positive decimal value
    
          Range:   1 .. 1024
    
          Default: 200
    
    5 - Set the number of samples to collect.
    
        Parameter 5 specifies the length of the time-domain data record to be collected
        for each of the specified frequencies.
    
          Type:    Positive decimal value
    
          Range:   1 .. 32768
    
          Default: 4096
    
    6 - Enable Tracing
    
        Parameter 7 is used to enable a trace-mode that will return the raw time-domain
        data of the last frequency to be analyzed. If Parameter 6 equals 0, then the
        trace-mode is disabled. If Parameter 6 equals 1, the the trace-mode is enabled.
    
          Type:    Hexadecimal value
    
          Range:   0 or 1
    
          Default: 0 (Trace disabled)
    

  <b><i><u>Output Data:</u></i></b>
<a name="SERVO_BODE_PLOT_CMD_DATA"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
        If no error occurred the bode type will be displayed.
        example:
        OPEN LOOP - POSITION DISTURBANCE
     
        Then the frequency response data will be displayed in floating-point format.
     
        Freq     Re1      Im1      Re2      Im2
        A        B        C        D        E
     
        where:
    
        A represents the measurement frequency in Hertz.
        B represents the REAL component of the frequency in Signal 1
        C represents the IMAG component of the frequency in Signal 1
        D represents the REAL component of the frequency in Signal 2
        E represents the IMAG component of the frequency in Signal 2
     
 
  <b><i><u>Examples:</u></i></b>
    The following command will measure the open loop frequency response using the
    defaults parameters.
 
       B
 
    This command will measure the open loop frequency response with a
    TrackingDemodDisturbancePosition amplitude of 100, in the range of 2000Hz
    to 3000Hz, with a linear spacing of 20Hz=(3000-2000)/50, and a time record
    of 5000 samples per frequency.
 
       B3,100,2000,3000,50,5000
 
    This example uses the default bode type and injection amplitude, starting frequency
    of 5000, ending frequency of 5010, using only 1 frequency only do 5000Hz), collect 264
    samples, and use Trace Mode. Trace mode will return the servo sector number, and the
    raw time-domian data for Signal1 and Signal2.
 
       B,,5000,5010,1,264,1

  <b><i><u>Revision History:</u></i></b>
<a name="SERVO_BODE_PLOT_CMD_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="SERVO_DIAG_SUB_COMMANDS_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Servo Diagnostic Sub Commands"></a><hr align=left width="75%"><b> Servo Diagnostic Sub Commands (Level 8 'C')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    The Servo Diagnostic Sub Commands execute the following servo diagnostic sub commands:

       8>C05: Set Seek Delay command. This command sets the seek delay, logical / physical
              seek type, and write / read seek settle for other 8>C seek related commands
              (such as 8>C08 and 8>C0C).

       8>C08: Random Seeks command. This command performs random seeks across the entire disk
              or just by switching heads only.

       8>C0C: Seek Between 2 Physical Cylinders command. This command performs seeks between
              2 physical tracks at the same head.

       8>C15: Change Write Threshold command. This command changes write threshold.

  <b><i><u>Quick Help:</u></i></b>
<a name="SERVO_DIAG_SUB_COMMANDS_QUICK_HELP"></a>
    "ServoDiagSubCmds, C[SubCmd],[Parm0],[Parm1],[Parm2]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="SERVO_DIAG_SUB_COMMANDS_PARM"></a>
    0 - Servo Diag Sub command ID.
    
        This parameter specifies the ID of the servo diag sub command to be executed
    
            05h = Set Seek Delay
            08h = Random Seeks
            0Ch = Seek Between 2 Physical Cylinders
            15h = Change Write Threshold
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: None
    

  Set Seek Delay command 8>C05 (Parameter 0 is 05h)
  <b><i><u>Input Parameters:</u></i></b>
<a name="SET_SEEK_DELAY_PARM"></a>
    0 - Level 8 C command's Set Seek Delay sub-command ID (05h)
    
          Type:    Unsigned 16-bit value
    
          Range:   05h
    
          Default: None
    1 - Seek Delay in the format of servo sectors
    
        This parameter specifies the new seek delay.  If this
        parameter is not entered, then the seek delay is not going
        to be changed
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xffff
    
          Default: None
    
    2 - Seek Type
    
        This parameter specifies the new seek type. Its Bit 0 controls slow/fast settle
        setting and the Bit 1 controls the logical/physical seek setting. If this
        parameter is not entered, then the seek type is not going to be changed.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xffff
    
          Default: None
    

  <b><i><u>Output Data:</u></i></b>
<a name="SET_SEEK_DELAY_DATA"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
        The following will be displayed
    
              Delay between xxxx settle seeks = yyyy servo sectors
              zzzz Seeks Enabled
    
           where
    
              xxxx is either slow or fast
    
              yyyy is the seek delay number in servo sectors
    
              zzzz is either Logical or Physical
    

  Random Seeks command 8>C08 (Parameter 0 is 08h)

  <b><i><u>Input Parameters:</u></i></b>
<a name="RANDOM_SEEK_PARM"></a>
    1 - Random Head Only Indicator
    
        This parameter indicates if the seek destination is random head only. When this
        parameter is not entered or entered as 0, both track number and head number are
        generated randomly, otherwise, only head number changes randomly while the track
        number stays the same.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xffff
    
          Default: 0
    

  <b><i><u>Output Data:</u></i></b>
<a name="SEEK_TIME_DATA"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
        If no error occurred, seek average time is displayed with the following format:
    
        -Average = xxx.yyy msecs-
           Note: The beginning and ending chars are rotating all the time to reflect the
           fact that the command is running

  Seek Between 2 Physical Cylinders command 8>C0C (Parameter 0 is 0Ch)

  <b><i><u>Input Parameters:</u></i></b>
<a name="SEEK_BETWEEN_CYLINDERS_PARM"></a>
    1 - First physical cylinder to be seeked. When this parameter is not entered,
        the minimum physical cylinder at the current head is used.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xffffffff
    
          Default: Minimum physical cylinder at the current head
    
    2 - Second physical cylinder to be seeked. When this parameter is not entered,
        the maximum physical cylinder at the current head is used.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xffffffff
    
          Default: Maximum physical cylinder at the current head
    

  <b><i><u>Output Data:</u></i></b>
<a name="SEEK_TIME_DATA"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
        If no error occurred, seek average time is displayed with the following format:
    
        -Average = xxx.yyy msecs-
           Note: The beginning and ending chars are rotating all the time to reflect the
           fact that the command is running

  Change Write Threshold command 8>C15 (Parameter 0 is 15h)

  <b><i><u>Input Parameters:</u></i></b>
<a name="CHANGE_WRITE_THRESHOLD_PARM"></a>
        1 - Position Threshold
    
            This parameter specifies the new position write threshold.  If this
            parameter is not entered, then position write threshold is not going
            to be changed
    
              Type:    Unsigned 16-bit value
    
              Range:   0 to 0xffff
    
              Default: None
    
    <font color=red>
        2 - Velocity Threshold (Not supported yet by servo)
    
            This parameter specifies the new velocity write threshold.  If this
            parameter is not entered, then velocity write threshold is not going
            to be changed
    
              Type:    Unsigned 16-bit value
    
              Range:   0 to 0xffff
    
              Default: None
    
    </font>

  <b><i><u>Output Data:</u></i></b>
<a name="CHANGE_WRITE_THRESHOLD_DATA"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
        If no error occurred, the following will be displayed
    
           Head  XThresh  VThresh
           00    XXXX     VVVV
           01    XXXX     VVVV
           ...
    
           where
    
              XXXX is the position write threshold
    
              VVVV is the velocity write threshold
    

  <b><i><u>Revision History:</u></i></b>
<a name="SERVO_DIAG_SUB_COMMANDS_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="SET_BAUD_RATE_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Set Baud Rate"></a><hr align=left width="75%"><b> Set Baud Rate (Level T 'B', Level F 'b')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    The Set Baud Rate command sets the serial port baud rate to the specified value.

  <b><i><u>Quick Help:</u></i></b>
<a name="SET_BAUD_RATE_QUICK_HELP"></a>
       Level T
    "SetBaudRate, B[BaudRate],[MsecDelay]";
       Level F
    "SetBaudRate, b[BaudRate],[MsecDelay]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="SET_BAUD_RATE_PARM"></a>
    0 - Desired Baud Rate.
    
        This parameter specifies the desired serial port baud rate.  If this parameter
        is not entered or a value of 0 is entered, the baud rate will be set to the
        default value.  If an unsupported baud rate value is entered, a list of the
        valid baud rates will be displayed.
    
          Type:    Decimal value
    
          Range:   0 to 9999999
    
          Default: 38400
    
    1 - Delay Time in Milliseconds.
    
        This parameter specifies the number of milliseconds that the drive will wait for
        the host to send a carriage return at the new baud rate.  If a carriage return
        is not received within the specified amount of time, the baud rate will be set
        back to its value before the command was received.  If this parameter is not
        entered or a value of 0 is entered, the drive will not wait for a carriage return
        after selecting the specified baud rate.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xffff
    
          Default: 0
    

  <b><i><u>Output Data:</u></i></b>
    If an unsupported baud rate value is entered, this command will display a list
    of the supported baud rates.

  <b><i><u>Revision History:</u></i></b>
<a name="SET_BAUD_RATE_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="SET_BUFFER_PATTERN_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Set Buffer Pattern"></a><hr align=left width="75%"><b> Set Buffer Pattern (Levels 2, 7, F 'P')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command loads the specified data buffer blocks with the specified data pattern.

    This command supports both the legacy ST-10 mode and a new mode that allows the user to
    enter data patterns of up to 16-bytes (128-bits in length).  The Legacy ST-10 mode only
    allowed the user to enter 4-byte (32-bit) patterns.

    In legacy ST-10 mode Parameter 0 selects either a pre-defined pattern (i.e. If Parameter 0
    is equal to 0x1212, random data will be selected) or it contains the lower 16-bits of a
    user specified pattern.  In this mode Parameter 1 contains the upper 16-bits of a user
    specified pattern, Parameter 2 specifies the pattern length, in bits, and the pattern
    is assumed to be right justified.  For example if Parameter 0 is equal to 0x5678,
    Parameter 1 is equal to 0x1234 and Parameter 2 is equal to 0x14, the buffer will be
    filled with the repeating 20-bit pattern 0100 0101 0110 0111 1000 which are the least
    significant 4-bits of Parameter 1 followed by the 16-bits of Parameter 0 (45678).

    The new 16-byte user pattern mode is selected by entering 0x1818 for Parameter 0.  In
    this mode Parameter 1 contains the 16-byte pattern to be used, Parameter 2 specifies
    the pattern length, in bits, and the pattern is assumed to be left justified.  The
    pattern should be entered as a 1 to 32 character hexadecimal value with no spaces or
    commas separating the bytes.  For example if Parameter 0 is equal to 0x1818,
    Parameter 1 is equal to 0x123456789ABC and Parameter 2 is equal to 0x24, the buffer
    will be filled with the repeating 36-bit pattern 0001 0010 0011 0100 0101 0110 0111
    1000 1001 which are the most significant 36-bits of Parameter 1 (123456789).

  <b><i><u>Quick Help:</u></i></b>
<a name="SET_BUFFER_PATTERN_QUICK_HELP"></a>
    "BufferSetPattern, P[PatternSelOrPatternLow],[PatternHi],[PatternBits],[Opts],[BlkNum],[NumBlks]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="BUFFER_SET_PATTERN_PARM"></a>
    0 - Select Pre-Defined Data Pattern or Data Pattern Low.
    
        If Parameter 3 bit 1 is cleared, the value of Parameter 0 will first be checked
        to determine if it selects any of the following pre-defined patterns and only
        if no match is found with any of the pre-defined patterns, will Parameter 0 be
        interpreted as the data pattern low.
    
<a name="INCREMENTING_BUFFER_PATTERN_TYPE"></a>
          0x1111 = Incrementing Pattern.
          
                   Each buffer block will be filled with a 16-bit value containing
                   its block offset relative to the first block filled.
    
<a name="RANDOM_BUFFER_PATTERN_TYPE"></a>
          0x1212 = Random Pattern.
          
                   The buffer will be filled with random data.
    
<a name="ALTERNATING_BUFFER_PATTERN_TYPE"></a>
          0x1313 = Alternating Pattern.
          
                   The number of buffer blocks to be filled will be divided in half and
                   the first group of blocks will be filled with 0x1313 and the second
                   group of blocks will be filled with random data.
    
<a name="ISOLATED_PULSE_BUFFER_PATTERN_TYPE"></a>
          0x1414 = Isolated Pulse Pattern.
          
                   The buffer will be filled with the 64-bit pattern 0xffff0000.
    
<a name="INCREMENTING_2_BYTE_BUFFER_PATTERN_TYPE"></a>
          0x1515 = Incrementing 2-Byte Pattern.
          
                   Each buffer block will be filled with a 16-bit incrementing pattern
                   that resets to zero at the start of each block.
    
<a name="REPEATING_127_BIT_BUFFER_PATTERN_TYPE"></a>
          0x1616 = Repeating 127-bit Pattern.
          
                   If the first 11 blocks will be filled with the following 127-bit
                   repeating binary pattern and the remaining blocks, if any, will be
                   filled with zeroes.
          
                      00010011 00010111 01011011 00000110 (13 17 5B 06 hex)
                      01101010 01110011 11011010 00010101 (6A 73 DA 15 hex)
                      01111101 00101000 11011100 01111111 (7D 28 DC 7F hex)
                      00001110 11110010 11001001 0000001  (0E F2 C9 02 hex)
          
                   Note: When loading the buffer with the repeating 127-bit pattern, each
                   byte will be flipped end to end.  So when displayed, the filled buffer
                   will actually contain the following data.
          
                      11001000 11101000 11011010 01100000 (C8 E8 DA 60 hex)
                      01010110 11001110 01011011 10101000 (56 CE 5B A8 hex)
                      10111110 00010100 00111011 11111110 (BE 14 3B FE hex)
                      01110000 01001111 10010011 01000000 (70 4F 93 40 hex)
    
<a name="REPEATING_15_BYTE_6T_BUFFER_PATTERN_TYPE"></a>
          0x1717 = Repeating 15 byte 6T Pattern.
          
                   The buffer will be filled with the following 15-byte repeating pattern.
          
                      F0 F3 F3 C3 03 03 03 0F 3F 3F 3F 3C 30 30 F0 hex
    
<a name="USER_BUFFER_PATTERN_TYPE"></a>
          0x1818 = Repeating 1 to 128 bit user specified pattern.
    
                   The buffer will be filled with the 1 to 128 bit (16 byte) pattern
                   entered for Parameter 1.  The number of Parameter 1 bits to be repeated
                   will be specified by Parameter 2.
    
        If Parameter 3 bit 1 is set or Parameter 0 is not equal to any of the values listed
        above, Parameter 0 will specify the least significant 16-bits of the data pattern
        with which the buffer is to be loaded.  In this case Parameter 1 will specify the
        most significant 16-bits of the data pattern, the maximum pattern length will be
        32-bits and the specified pattern will be assumed to be right justified.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xffff,
    
          Default: 0x1212 (Random Data)
    
    1 - Data Pattern high or 16-byte Data Pattern.
    
        If Parameter 3 bit 1 is set or Parameter 0 does not select one of the pre-defined
        data patterns (0x1111, 0x1212, etc.), Parameter 1 specifies the most significant
        16-bits of the data pattern with which the buffer is to be loaded.  In this case
        Parameter 0 will specify the least significant 16-bits of the data pattern, the
        maximum pattern length will be 32-bits and the specified pattern will be assumed
        to be right justified.
    
        If Parameter 3 bit 1 is cleared and Parameter 0 is equal to 0x1818, Parameter 1
        will specify a 1-bit to 16-byte pattern.  The number of Parameter 1 bits to be
        repeated will be specified by Parameter 2.  In this case the specified pattern
        is assumed to be left justified.
    
          Type:    Unsigned 16-byte value
    
          Range:   0 to 0xffffffffffffffffffffffffffffffff
    
          Default: 0
    
    2 - Data Pattern Bits.
    
        This parameter specifies the length, in bits, of the fill pattern specified by
        parameters 0 and 1.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0x80
    
          Default: 0x20 (32-bit pattern)
    
    3 - Options.
    
        This parameter is a bit-significant value that selects the following options.
    
          Bits 31-1:  not used
    
          Bit 0:      Disable Pre-Defined Data Patterns.
    
                      If this bit is set, the value of Parameter 0 will not be used to
                      select pre-defined data patterns and will always be interpreted
                      as the data pattern low.  For example, setting this bit allows
                      the user to specify a 16-bit data pattern of 1212 hex instead of
                      a random data pattern.
    
                      If this bit is cleared, the value of Parameter 0 will first be
                      checked to determine if it selects any of the pre-defined patterns
                      and only if no match is found with any of the pre-defined patterns,
                      will Parameter 0 be interpreted as the data pattern low.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: 0 (Enable Pre-Defined Data Patterns )
    
    4 - First Buffer Block Number to fill.
    
        This parameter specifies the number of the first buffer block to be filled.
    
        ************************************ NOTE *******************************************
        This option should be used with great caution, since it has the potential to corrupt
        critical data stored in the data buffer.
        *************************************************************************************
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to last buffer block number
    
          Default: If this parameter is not entered, the first block of Diagnostic Write
                   Buffer will be the first buffer block filled.
    
    5 - Number of consecutive Buffer Blocks to fill.
    
        This parameter specifies the number of consecutive buffer blocks to be filled.
    
        ************************************ NOTE *******************************************
        This option should be used with great caution, since it has the potential to corrupt
        critical data stored in the data buffer.
        *************************************************************************************
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xffff
    
          Default: If this parameter is not entered and Parameter 4 was not entered, the
                   entire Diagnostic Write Buffer will be filled.  If this parameter is
                   not entered and Parameter 4 was entered, only the buffer block specified
                   by Parameter 4 will be filled.
    

  <b><i><u>Output Data:</u></i></b>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    

  <b><i><u>Examples:</u></i></b>
    The following commands will load the Diagnostic Write Buffer with pre-defined patterns:

       F3 2>P1111     (Incrementing Pattern - 1st block 0x0000, 2nd block 0x0001, etc.)
       F3 2>P1212     (Random Pattern)
       F3 2>P1313     (Alternating Pattern - 0x1313 and Random Data)
       F3 2>P1414     (Isolated Pulse Pattern - 0xFFFF0000)
       F3 2>P1515     (Incrementing 2-Byte Pattern - 0x0000000100020003...)
       F3 2>P1616     (Pre-Defined 127-bit Pattern - 0x13175B06...)
       F3 2>P1717     (Pre-Defined 15 byte 6T Pattern - 0xF0F3F3C303...)

    The following commands will load the Diagnostic Write Buffer with user defined patterns:

       F3 2>P1818,01020304050607080910111213141516,80  (User 128-bit pattern 0x010203...16)
       F3 2>P0304,0102                                 (User 32-bit pattern 0x01020304)
       F3 2>P4,,3                                      (User 3-bit pattern 100b)
       F3 2>P1111,,10,1                                (User 16-bit pattern 0x1111)

    The following commands will load the specified buffer blocks with a user defined pattern:

       F3 2>P0304,0102,,,D5C,4  (Buffer Blocks D5C-D5F with user 32-bit pattern 0x01020304)

  <b><i><u>Revision History:</u></i></b>
<a name="SET_BUFFER_PATTERN_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0001.0001   Added support for 6T pattern and user specified 16-byte pattern.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="SET_CONGEN_PARM_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Set Congen Parameter"></a><hr align=left width="75%"><b> Set Congen Parameter (Level T 'F')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command allows the user to display and / or modify the Congen parameters by using
    either relational references or byte offset references to Congen data.  Relational refer-
    ences are provided through parameter names entered as double-quote-delimited strings.

    Some known quirkiness:
    1) YASPP is fickle about double quotes when using the arrow-up and arrow-down keys.  Some-
       times it will mysteriously remove the quote characters, the single character command,
       or both while perusing the command history.
    2) The even number requirement has been fixed.  When specifying a byte offset, you may now
       use an odd number of characters to specify the offset.
<font color=red>
    WARNING!  Using byte offset references to modify Congen parameters must be done thought-
    fully.  This usage of the command provides extremely permissive access to the Congen and
    is provided for convenience when using the diagnostics in an interactive way.  Use of
    this option requires intimate knowledge of the layout of the Congen data and this layout
    is NOT guaranteed to stay the same from one code release to the next.  It is preferred
    that relational references are used to change Congen and is REQUIRED if Congen changes
    are to made by programs or scripts.
</font>

  <b><i><u>Quick Help:</u></i></b>
<a name="SET_CONGEN_PARM_QUICK_HELP"></a>
    "SetCongenParmCmdHelpMsg, F[ValueRef],[Data],[ResetEnable]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="SET_CONGEN_PARM_PARM"></a>
    0 - Congen Value Reference.
    
        This parameter references the Congen value to be modified using a quote-delimited
        string (double quotes) or using a hex value.
    
          Type:    Quote-delimited string or hex value
    
          Range:   1 to 63 character string or 0000 to FFFF (if hex value)
    
          Default: If this parameter is not entered, the entire current Congen data will
                   be displayed.
    
    1 - Congen Data.
    
        This parameter specifies the data to be written to the Congen value specified by
        parameter 0.  This data can be entered as either a quote-delimited string (double
        quotes) or as a variable-lengthed sequence of hex values.
    
          Type:    Quote-delimited string or sequence of hex values
    
          Range:   1 to 63 character string or 1 to 64 byte hex sequence
    
          Default: If this parameter is not entered, then the Congen value associated with
                   parameter 0 will be displayed.
    
    2 - Reset Congen Info Enable.
    
        If parameter 0 and parameter 1 are not entered and this parameter is set to the value
        "0x22" (hex), then this will cause the drive to reset the Congen to its compile-time
        default values.
    
          Type:    Hex number
    
          Range:   0x22 is the only valid value.
    
          Default: None.
    

  <b><i><u>Output Data:</u></i></b>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    

    If no error occurred and Parameter 0 is not entered, the Congen data will be
    displayed as follows:
<a name="VERBOSE_CONGEN_DATA"></a>
    
    F3 T>F
                                                                                                                                              
               RWErrorRecovery Mode Page
                  RWErrorRecovery Group
    Byte:0082:       RWRecoveryFlags = C0
    Byte:0082:           Bit:0, DISABLE_CORRECTION = 0
    Byte:0082:           Bit:1, DISABLE_TRANSFER_ON_ERROR = 0
    Byte:0082:           Bit:2, POST_ERROR = 0
    Byte:0082:           Bit:3, ENABLE_EARLY_RECOVERY = 0
    Byte:0082:           Bit:4, READ_CONTINUOUS = 0
    Byte:0082:           Bit:5, TRANSFER_BLOCK = 0
    Byte:0082:           Bit:6, READ_SPARING_ENABLED = 1
    Byte:0082:           Bit:7, WRITE_SPARING_ENABLED = 1
    Byte:0083:       ReadRetries = 08
    Byte:0084:       CorrectionSpan = FF
    Byte:0085:       HeadOffset = 00
    Byte:0086:       DataStrobeOffset = 00
    Byte:0088:       WriteRetries = 05
    Byte:008A:       RecoveryLimitMSB = FF
    Byte:008B:       RecoveryLimitLSB = FF
                                                                                                                                              
               FormatParameters Mode Page
                  FormatParameters Group
    Byte:008E:       TracksPerZoneMSB = 0D
    Byte:008F:       TracksPerZoneLSB = BE
    Byte:0090:       AltSectorsPerZoneMSB = 00
    Byte:0091:       AltSectorsPerZoneLSB = 00
    Byte:0092:       AltTracksPerZoneMSB = 00
    Byte:0093:       AltTracksPerZoneLSB = 0E
    Byte:0094:       AltTracksPerVolumeMSB = 00
    Byte:0095:       AltTracksPerVolumeLSB = 00
    Byte:0096:       SectorsPerTrackMSB = 06
    Byte:0097:       SectorsPerTrackLSB = 46
    Byte:0098:       BytesPerSectorMSB = 02
    Byte:0099:       BytesPerSectorLSB = 00
    Byte:009A:       InterleaveMSB = 00
    Byte:009B:       InterleaveLSB = 01
    Byte:009C:       TrackSkewMSB = 01
    Byte:009D:       TrackSkewLSB = 18
    Byte:009E:       CylinderSkewMSB = 01
    Byte:009F:       CylinderSkewLSB = 18
    Byte:00A0:       FormatFlags = 40
                                                                                                                                              
               DriveGeometry Mode Page
                  DriveGeometry Group
    Byte:00A6:       CylindersMSB = 02
    Byte:00A7:       CylindersMDB = 44
    Byte:00A8:       CylindersLSB = 8A
    Byte:00A9:       Heads = 02
    Byte:00AA:       WritePrecompMSB = 00
    Byte:00AB:       WritePrecompMDB = 00
    Byte:00AC:       WritePrecompLSB = 00
    Byte:00AD:       ReducedCurrentMSB = 00
    Byte:00AE:       ReducedCurrentMDB = 00
    Byte:00AF:       ReducedCurrentLSB = 00
    Byte:00B0:       StepRateMSB = 00
    Byte:00B1:       StepRateLSB = 00
    Byte:00B2:       LandingZoneMSB = 00
    Byte:00B3:       LandingZoneMDB = 00
    Byte:00B4:       LandingZoneLSB = 00
    Byte:00B5:       PositionLocking = 00
    Byte:00B6:       RotationalOffset = 00
    Byte:00B8:       RotationRateMSB = 1C
    Byte:00B9:       RotationRateLSB = 20
                                                                                                                                              
               VerifyError Mode Page
                  VerifyError Group
    Byte:00BE:       VerifyRecoveryFlags = 00
    Byte:00BE:           Bit:0, VE_DISABLE_CORRECTION = 0
    Byte:00BE:           Bit:1, VE_DISABLE_TRANSFER_ON_ERROR = 0
    Byte:00BE:           Bit:2, VE_POST_ERROR = 0
    Byte:00BE:           Bit:3, VE_ENABLE_ERROR_RECOVERY = 0
    Byte:00BF:       VerifyCount = 08
    Byte:00C0:       VerifySpan = FF
    Byte:00C6:       VerifyTimeLimitMSB = FF
    Byte:00C7:       VerifyTimeLimitLSB = FF
                                                                                                                                              
               CacheControl Mode Page
                  CacheControl Group
    Byte:00CA:       CacheFlags = 14
    Byte:00CA:           Bit:0, READ_CACHING_DISABLED_ON_POWER_UP = 0
    Byte:00CA:           Bit:1, MULTIPLICATION_FACTOR = 0
    Byte:00CA:           Bit:2, WRITE_CACHING_ENABLED_ON_POWER_UP = 1
    Byte:00CA:           Bit:4, DISCONTINUITY = 1
    Byte:00CA:           Bit:5, CACHING_ANALYSIS_PERMITTED = 0
    Byte:00CA:           Bit:6, ABORT_PREFETCH = 0
    Byte:00CA:           Bit:7, DISABLE_ADAPTIVE_READ_AHEAD = 0
    Byte:00CB:       RetentionPriority = 00
    Byte:00CC:       DisablePrefetchLengthMSB = FF
    Byte:00CD:       DisablePrefetchLengthLSB = FF
    Byte:00CE:       MinPrefetchMSB = 00
    Byte:00CF:       MinPrefetchLSB = 00
    Byte:00D0:       MaxPrefetchMSB = FF
    Byte:00D1:       MaxPrefetchLSB = FF
    Byte:00D2:       MaxPrefetchCeilingMSB = FF
    Byte:00D3:       MaxPrefetchCeilingLSB = FF
    Byte:00D4:       SpecialCacheFlags = 80
    Byte:00D5:       CacheSegmentNum = 20
    Byte:00D6:       CacheSegSizeMSB = 00
    Byte:00D7:       CacheSegSizeLSB = 00
    Byte:00D9:       NonCacheSegSizeMSB = 00
    Byte:00DA:       NonCacheSegSizeMDB = 00
    Byte:00DB:       NonCacheSegSizeLSB = 00
                                                                                                                                              
               ControlMode Mode Page
                  ControlMode Group
    Byte:00DE:       LogFlags = 02
    Byte:00DF:       QueueFlags = 00
    Byte:00E0:       AllegianceFlags = 00
    Byte:00E2:       RAERHoldOffMSB = 00
    Byte:00E3:       RAERHoldOffLSB = 00
    Byte:00E4:       BusyTimeoutMSB = 00
    Byte:00E5:       BusyTimeoutLSB = 00
    Byte:00E6:       ExtendedDstestTimeMSB = 00
    Byte:00E7:       ExtendedDstestTimeLSB = 00
                                                                                                                                              
               PowerCondition Mode Page
                  PowerCondition Group
    Byte:00EB:       PowerFlags = 02
    Byte:00EC:       IdleTimerMSB = 00
    Byte:00ED:       IdleTimerNMSB = 00
    Byte:00EE:       IdleTimerNLSB = 00
    Byte:00EF:       IdleTimerLSB = 05
    Byte:00F0:       StandbyTimerMSB = 00
    Byte:00F1:       StandbyTimerNMSB = 00
    Byte:00F2:       StandbyTimerNLSB = 00
    Byte:00F3:       StandbyTimerLSB = 04
                                                                                                                                              
               BackgroundMediaScan Mode Page
                  BGMS Group
    Byte:00F7:       BGMSBusIdleIn100ms = 05
    Byte:00F8:       OtherScanFlags = 00
    Byte:00F9:       IRAWWriteCachePercentage = 00
    Byte:00FA:       IRAWDelayInMilliSecs = 00
    Byte:00FB:       IRAWMaxQDepth = 00
    Byte:00FC:       BGMSFlags = 00
    Byte:00FD:       BGMSECCTLevel = 0A
    Byte:0104:       ReadAfterWriteControl = 00
    Byte:0104:           Bit:0, MP_RAW_ENABLE_BIT = 0
    Byte:0104:           Bit:1, MP_RAW_TRIP_1ST_N_WRITES = 0
    Byte:0104:           Bit:2, MP_RAW_FORCE_RAW_MODE = 0
    Byte:0104:           Bit:3, MP_RAW_UDS_DEBUG_MODE = 0
    Byte:0105:       NWritesAfterSWDFail = 00
    Byte:0106:       NWritesAfterRAWFail = 00
    Byte:0107:       NWritesAfterIRAWFail = 00
    Byte:0108:       N1stWrites = 00
    Byte:0109:       RAWOnColdThreshold = 00
    Byte:010A:       RAWOnHotThreshold = 00
    Byte:010B:       RAWATAMode = 02
    Byte:010C:       RAWVerifyNSectors = 00 00 00 00
    Byte:0114:       SWDControl = 00
    Byte:0114:           Bit:0, MP_SWD_ENABLE_BIT = 0
    Byte:0114:           Bit:1, MP_SWD_DONT_REPORT_BIT = 0
    Byte:0114:           Bit:2, MP_SWD_DEBUG_MODE_BIT = 0
    Byte:0115:       SWDDvgasEventsBeforeFail = 00
    Byte:0116:       SWDRvgasEventsBeforeFail = 00
    Byte:0117:       SWDFvgasEventsBeforeFail = 00
                                                                                                                                              
               DriveNativeInfo Mode Page
                  DriveNativeInfo Group
    Byte:011E:       PartNumber = 30 32 36 46 51 30 32 34 31
                     '026FQ0241'
    Byte:0127:       PartNumberWhitespacePad = 00 00 00 00 00 00 00 00
                     ''
    Byte:012F:       PartNumberPad = 00
    Byte:0130:       ProcessControlVersion = 01 37
    Byte:0132:       CongenConfigurationState = 03
    Byte:0133:       WrittenCount = 40
                                                                                                                                              
               ANSIBackgroundMediaScan Mode Page
                  ANSIBackgroundMediaScan Group
    Byte:0138:       BGMSFlags = 01
    Byte:0139:       Prescan = 00
    Byte:013A:       BGMSIntervalTimeHoursMSB = 00
    Byte:013B:       BGMSIntervalTimeHoursLSB = 18
    Byte:013C:       PrescanTimeoutHoursMSB = 00
    Byte:013D:       PrescanTimeoutHoursLSB = 02
                                                                                                                                              
               Congen Mode Page
                  Congen Group
    Byte:0148:       GeneralConfiguration = 5A 0C
    Byte:0148:           Bit:1, HARD_SECTORED = 1
    Byte:0148:           Bit:2, SOFT_SECTORED = 0
    Byte:0148:           Bit:3, NOT_MFM_ENCODED = 1
    Byte:0148:           Bit:4, HEAD_SWITCH_TIME_ABOVE_15_MICROSECONDS = 1
    Byte:0148:           Bit:5, SPINDLE_MOTOR_CONTROL_IMPLEMENTED = 0
    Byte:0148:           Bit:6, NON_REMOVABLE_DEVICE = 1
    Byte:0148:           Bit:7, REMOVABLE_CARTRIDGE_DRIVE = 0
    Byte:0149:           Bit:0, DISK_XFER_RATE_LESS_THAN_5_MEGABYTES_PER_SECOND = 0
    Byte:0149:           Bit:1, DISK_XFER_RATE_BETWEEN_5_AND_10_MEGABYTES_PER_SECOND = 0
    Byte:0149:           Bit:2, DISK_XFER_RATE_ABOVE_10_MEGABYTES_PER_SECOND = 1
    Byte:0149:           Bit:3, ROTATIONAL_SPEED_TOLERANCE_ABOVE_POINT_5_PERCENT = 1
    Byte:0149:           Bit:4, DATA_STROBE_OFFSET_OPTION_AVAIL = 0
    Byte:0149:           Bit:5, TRACK_OFFSET_OPTION_AVAIL = 0
    Byte:0149:           Bit:6, FORMAT_SPEED_TOLERANCE_GAP_REQUIRED = 0
    Byte:014A:       NumDefaultATCyls = FF 3F
    Byte:014C:       SpecificConfiguration = 37 C8
    Byte:014E:       NumDefaultATHeads = 10 00
    Byte:0154:       NumDefaultATSectors = 3F 00
    Byte:015C:       SerialNumber =
                     00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
                     00 00 00 00
                     ''
    Byte:0172:       BufferSize = 00 40
    Byte:0174:       NumECCBytesForLongCmds = 04 00
    Byte:0176:       FirmwareRevision = 20 20 20 20 20 20 20 20
                     '        '
    Byte:017E:       ModelNumber =
                     53 54 45 33 32 34 34 38 31 30 41 53 20 20 20 20
                     20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20
                     20 20 20 20 20 20 20 20
                     'STE3244810AS                            '
    Byte:01A6:       MaximumMultipleSize = 10
    Byte:01A7:       Word47Byte1 = 00
    Byte:01A8:       Word48 = 00 00
    Byte:01AA:       Capabilities = 20 2F
    Byte:01AB:           Bit:0, DMA_SUPPORTED = 1
    Byte:01AB:           Bit:1, LBA_SUPPORTED = 1
    Byte:01AB:           Bit:2, ABLE_TO_DISABLE_IORDY = 1
    Byte:01AB:           Bit:3, IORDY_SUPPORTED = 1
    Byte:01AB:           Bit:5, STANDARD_STANDBY_TIMER_VALUES_SUPPORTED = 1
    Byte:01AC:       CapabilitiesII = 00 40
    Byte:01AE:       PIOModeTiming = 00 02
    Byte:01B0:       DMAModeTiming = 00 02
    Byte:01B2:       ValidFields = 00 00
    Byte:01B2:           Bit:0, IDENTIFY_WORDS_54_TO_58_ARE_VALID = 0
    Byte:01B2:           Bit:1, IDENTIFY_WORDS_64_TO_70_ARE_VALID = 0
    Byte:01B2:           Bit:2, IDENTIFY_WORD_88_IS_VALID = 0
    Byte:01B4:       NumCurrentATCyls = FF 3F
    Byte:01B6:       NumCurrentATHeads = 10 00
    Byte:01B8:       NumCurrentATSectors = 3F 00
    Byte:01BA:       CurrentATCHSCapacity = 10 FC FB 00
    Byte:01BE:       CurrentMultipleSize = 10 01
    Byte:01C0:       TotalUserCapacity = FF FF FF 0F
    Byte:01C6:       MultiwordDMAModesSupported = 07
    Byte:01C6:           Bit:0, MULTIWORD_DMA_MODE_0_SUPPORTED = 1
    Byte:01C6:           Bit:1, MULTIWORD_DMA_MODE_1_SUPPORTED = 1
    Byte:01C6:           Bit:2, MULTIWORD_DMA_MODE_2_SUPPORTED = 1
    Byte:01C7:       MultiwordDMAModeSelected = 04
    Byte:01C8:       AdvancedPIOModesSupported = 23 00
    Byte:01C8:           Bit:0, PIO_MODE_3_SUPPORTED = 1
    Byte:01C8:           Bit:1, PIO_MODE_4_SUPPORTED = 1
    Byte:01CA:       MinimumMultiwordDMACycleTime = 78 00
    Byte:01CC:       RecommendedMultiwordDMACycleTime = 78 00
    Byte:01CE:       MinimumPIOTimeWithoutFlowControl = 78 00
    Byte:01D0:       MinimumPIOTimeWithFlowControl = 78 00
    Byte:01D2:       Word69 = 00 00
    Byte:01D4:       Word70 = 00 00
    Byte:01D6:       Word71 = 00 00
    Byte:01D8:       Word72 = 00 00
    Byte:01DA:       Word73 = 00 00
    Byte:01DC:       Word74 = 00 00
    Byte:01DE:       QDepth = 1F 00
    Byte:01E0:       SATACapabilities = 26 21
    Byte:01E0:           Bit:1, SATA_GEN1_SIGNALING_SPEED = 1
    Byte:01E0:           Bit:2, SATA_GEN2_SIGNALING_SPEED = 1
    Byte:01E0:           Bit:3, SATA_FUTURE_SIGNALING_SPEED_RESERVED = 0
    Byte:01E1:           Bit:0, SATA_NCQ_SUPPORTED = 1
    Byte:01E1:           Bit:1, HOST_INITIATED_PHY_POWER_MANAGEMENT_SUPPORTED = 0
    Byte:01E1:           Bit:2, SATA_PHY_EVENT_COUNTERS_SUPPORTED = 0
    Byte:01E1:           Bit:4, UNLOAD_WHILE_NCQ_CMDS_OUTSTANDING_SUPPORTED = 0
    Byte:01E2:       Word77 = 00 00
    Byte:01E4:       SATAFeaturesSupported = 20 20
    Byte:01E4:           Bit:1, DMA_SETUP_NON_ZERO_OFFSET_SUPPORTED = 0
    Byte:01E4:           Bit:2, DMA_AUTOACTIVATE_SUPPORTED = 0
    Byte:01E4:           Bit:3, DEVICE_INITIATED_POWER_MANAGEMENT_SUPPORTED = 0
    Byte:01E4:           Bit:6, PRESERVE_SETTINGS_ON_COMRESET_SUPPORTED = 0
    Byte:01E6:       SATAFeaturesEnabled = 20 20
    Byte:01E6:           Bit:1, DMA_SETUP_NON_ZERO_OFFSET_ENABLED = 0
    Byte:01E6:           Bit:2, DMA_AUTOACTIVATE_ENABLED = 0
    Byte:01E6:           Bit:3, DEVICE_INITIATED_POWER_MANAGEMENT_ENABLED = 0
    Byte:01E6:           Bit:4, IN_ORDER_DATA_DELIVERY_ENABLED = 0
    Byte:01E6:           Bit:6, PRESERVE_SETTINGS_ON_COMRESET_ENABLED = 0
    Byte:01E8:       MajorVersionNumber = 7E 20
    Byte:01E8:           Bit:1, ATAPI_1_SUPPORTED = 1
    Byte:01E8:           Bit:2, ATAPI_2_SUPPORTED = 1
    Byte:01E8:           Bit:3, ATAPI_3_SUPPORTED = 1
    Byte:01E8:           Bit:4, ATAPI_4_SUPPORTED = 1
    Byte:01E8:           Bit:5, ATAPI_5_SUPPORTED = 1
    Byte:01E8:           Bit:6, ATAPI_6_SUPPORTED = 1
    Byte:01E8:           Bit:7, ATAPI_7_SUPPORTED = 0
    Byte:01EA:       MinorVersionNumber = 1B 00
    Byte:01EC:       CommandSetSupported = 6B 34
    Byte:01EC:           Bit:0, SMART_SUPPORTED = 1
    Byte:01EC:           Bit:1, SECURITY_MODE_FEATURE_SET_SUPPORTED = 1
    Byte:01EC:           Bit:3, POWER_MANAGEMENT_SUPPORTED = 1
    Byte:01EC:           Bit:5, WRITE_CACHE_SUPPORTED = 1
    Byte:01EC:           Bit:6, READ_LOOKAHEAD_SUPPORTED = 1
    Byte:01EC:           Bit:7, RELEASE_INTERRUPT_SUPPORTED = 0
    Byte:01ED:           Bit:0, SERVICE_INTERRUPT_SUPPORTED = 0
    Byte:01ED:           Bit:1, DEVICE_RESET_CMD_SUPPORTED = 0
    Byte:01ED:           Bit:2, HOST_PROTECTED_AREA_SUPPORTED = 1
    Byte:01ED:           Bit:4, WRITE_BUFFER_CMD_SUPPORTED = 1
    Byte:01ED:           Bit:5, READ_BUFFER_CMD_SUPPORTED = 1
    Byte:01ED:           Bit:6, NOP_CMD_SUPPORTED = 0
    Byte:01EE:       CommandSetsSupported = 01 7F
    Byte:01EE:           Bit:0, DOWNLOAD_MICROCODE_CMD_SUPPORTED = 1
    Byte:01EE:           Bit:1, READ_WRITE_DMA_QUEUED_SUPPORTED = 0
    Byte:01EE:           Bit:2, CFA_FEATURE_SUPPORTED = 0
    Byte:01EE:           Bit:3, ADVANCED_POWER_MANAGEMENT_SUPPORTED = 0
    Byte:01EE:           Bit:4, REMOVABLE_MEDIA_STATUS_NOTIFICATION_FEATURE_SET_SUPPORTED = 0
    Byte:01EE:           Bit:5, POWER_UP_IN_STANDBY_SUPPORTED = 0
    Byte:01EE:           Bit:6, SET_FEATURES_SPINUP_REQUIRED_SUPPORTED = 0
    Byte:01EF:           Bit:0, SET_MAX_SECURITY_EXTENSION_SUPPORTED = 1
    Byte:01EF:           Bit:1, AUTO_ACOUSTIC_MANAGEMENT_SUPPORTED = 1
    Byte:01EF:           Bit:2, FOURTYEIGHT_BIT_SUPPORTED = 1
    Byte:01EF:           Bit:3, DCO_COMMAND_SETS_SUPPORTED = 1
    Byte:01EF:           Bit:4, FLUSH_CACHE_SUPPORTED = 1
    Byte:01EF:           Bit:5, FLUSH_CACHE_EXT_SUPPORTED = 1
    Byte:01F0:       CommandSetSupportedExtension = 03 40
    Byte:01F0:           Bit:0, SMART_ERROR_LOGGING_SUPPORTED = 1
    Byte:01F0:           Bit:1, SMART_SELF_TEST_SUPPORTED = 1
    Byte:01F0:           Bit:2, MEDIA_SERIALNUMBER_SUPPORTED = 0
    Byte:01F0:           Bit:3, MEDIA_CARD_PASS_THROUGH_CMD_FEATRUE_SET_SUPPORTED = 0
    Byte:01F0:           Bit:4, STREAMING_FEATURE_SET_SUPPORTED = 0
    Byte:01F0:           Bit:5, GENERAL_PURPOSE_LOGGING_SUPPORTED = 0
    Byte:01F0:           Bit:6, FUA_WRITE_EXT_COMMANDS_SUPPORTED = 0
    Byte:01F0:           Bit:7, FUA_WRITE_QUEUED_EXT_COMMANDS_SUPPORTED = 0
    Byte:01F1:           Bit:0, SIXTYFOUR_BIT_WWN_SUPPORTED = 0
    Byte:01F1:           Bit:1, URG_FOR_READ_STREAM_SUPPORTED = 0
    Byte:01F1:           Bit:2, URG_FOR_WRITE_STREAM_SUPPORTED = 0
    Byte:01F1:           Bit:3, AV_LITE_SUPPORTED = 0
    Byte:01F1:           Bit:4, AV_LITE_RC_WC_SUPPORTED = 0
    Byte:01F1:           Bit:5, IDLE_IMMEDIATE_UNLOAD_SUPPORTED = 0
    Byte:01F1:           Bit:6, BASE_VALUE_OF_IDENTIFY_WORD_84 = 1
    Byte:01F2:       CommandSetEnabled = 28 34
    Byte:01F2:           Bit:0, SMART_ENABLED = 0
    Byte:01F2:           Bit:1, SECURITY_MODE_FEATURE_SET_ENABLED = 0
    Byte:01F2:           Bit:3, POWER_MANAGEMENT_ENABLED = 1
    Byte:01F2:           Bit:5, WRITE_CACHE_ENABLED = 1
    Byte:01F2:           Bit:6, READ_LOOKAHEAD_ENABLED = 0
    Byte:01F2:           Bit:7, RELEASE_INTERRUPT_ENABLED = 0
    Byte:01F3:           Bit:0, SERVICE_INTERRUPT_ENABLED = 0
    Byte:01F3:           Bit:2, HOST_PROTECTED_AREA_ENABLED = 1
    Byte:01F3:           Bit:4, WRITE_BUFFER_CMD_ENABLED = 1
    Byte:01F3:           Bit:5, READ_BUFFER_CMD_ENABLED = 1
    Byte:01F4:       CommandSetsEnabled = 01 3C
    Byte:01F4:           Bit:0, DOWNLOAD_MICROCODE_CMD_ENABLED = 1
    Byte:01F4:           Bit:1, READ_WRITE_DMA_QUEUED_ENABLED = 0
    Byte:01F4:           Bit:2, CFA_FEATURE_SET_ENABLED = 0
    Byte:01F4:           Bit:3, ADVANCED_POWER_MANAGEMENT_ENABLED = 0
    Byte:01F4:           Bit:4, REMOVABLE_MEDIA_STATUS_NOTIFICATION_FEATURE_SET_ENABLED = 0
    Byte:01F4:           Bit:5, POWER_UP_IN_STANDBY_ENABLED = 0
    Byte:01F4:           Bit:6, SET_FEATURES_SPINUP_REQUIRED_ENABLED = 0
    Byte:01F4:           Bit:7, ADDRESS_OFFSET_RESERVED_AREA_BOOT = 0
    Byte:01F5:           Bit:0, SET_MAX_SECURITY_EXTENSION_ENABLED = 0
    Byte:01F5:           Bit:1, AUTO_ACOUSTIC_MANAGEMENT_ENABLED = 0
    Byte:01F5:           Bit:2, FOURTYEIGHT_BIT_ENABLED = 1
    Byte:01F5:           Bit:3, DCO_COMMAND_SETS_ENABLED = 1
    Byte:01F5:           Bit:4, FLUSH_CACHE_ENABLED = 1
    Byte:01F5:           Bit:5, FLUSH_CACHE_EXT_ENABLED = 1
    Byte:01F6:       CommandSetEnabledExtension = 03 40
    Byte:01F6:           Bit:0, SMART_ERROR_LOGGING_ENABLED = 1
    Byte:01F6:           Bit:1, SMART_SELF_TEST_ENABLED = 1
    Byte:01F6:           Bit:2, MEDIA_SERIALNUMBER_IS_VALID = 0
    Byte:01F6:           Bit:3, MEDIA_CARD_PASSTHROUGH_FEATURE_SET_ENABLED = 0
    Byte:01F6:           Bit:4, STREAMING_FEATURE_SET_ENABLED = 0
    Byte:01F6:           Bit:5, GENERAL_PURPOSE_LOGGING_ENABLED = 0
    Byte:01F6:           Bit:6, FUA_WRITE_EXT_COMMANDS_ENABLED = 0
    Byte:01F6:           Bit:7, FUA_WRITE_QUEUED_EXT_COMMANDS_ENABLED = 0
    Byte:01F7:           Bit:0, SIXTYFOUR_BIT_WWN_ENABLED = 0
    Byte:01F7:           Bit:1, URG_FOR_READ_STREAM_ENABLED = 0
    Byte:01F7:           Bit:2, URG_FOR_WRITE_STREAM_ENABLED = 0
    Byte:01F7:           Bit:3, AV_LITE_ENABLED = 0
    Byte:01F7:           Bit:4, AV_LITE_RC_WC_ENABLED = 0
    Byte:01F7:           Bit:5, IDLE_IMMEDIATE_UNLOAD_ENABLED = 0
    Byte:01F8:       UltraDMAModesSupported = 7F
    Byte:01F8:           Bit:0, ULTRA_DMA_MODE0_SUPPORTED = 1
    Byte:01F8:           Bit:1, ULTRA_DMA_MODE1_AND_BELOW_SUPPORTED = 1
    Byte:01F8:           Bit:2, ULTRA_DMA_MODE2_AND_BELOW_SUPPORTED = 1
    Byte:01F8:           Bit:3, ULTRA_DMA_MODE3_AND_BELOW_SUPPORTED = 1
    Byte:01F8:           Bit:4, ULTRA_DMA_MODE4_AND_BELOW_SUPPORTED = 1
    Byte:01F8:           Bit:5, ULTRA_DMA_MODE5_AND_BELOW_SUPPORTED = 1
    Byte:01F8:           Bit:6, ULTRA_DMA_MODE6_AND_BELOW_SUPPORTED = 1
    Byte:01F9:       UltraDMAModeSelected = 00
    Byte:01F9:           Bit:0, ULTRA_DMA_MODE0_SELECTED = 0
    Byte:01F9:           Bit:1, ULTRA_DMA_MODE1_SELECTED = 0
    Byte:01F9:           Bit:2, ULTRA_DMA_MODE2_SELECTED = 0
    Byte:01F9:           Bit:3, ULTRA_DMA_MODE3_SELECTED = 0
    Byte:01F9:           Bit:4, ULTRA_DMA_MODE4_SELECTED = 0
    Byte:01F9:           Bit:5, ULTRA_DMA_MODE5_SELECTED = 0
    Byte:01F9:           Bit:6, ULTRA_DMA_MODE6_SELECTED = 0
    Byte:01FA:       SecurityEraseTime = 00 00
    Byte:01FC:       EnhancedSecurityEraseTime = 00 00
    Byte:01FE:       CurrentAPMValue = FE FE
    Byte:0200:       MasterPasswordRevisionCode = FE FF
    Byte:0202:       EightyConductorCableDetection = 00 00
    Byte:0202:           Bit:0, DEV0_RESULT = 0
    Byte:0202:           Bit:1, DEV0_RESULT_JUMPER_USED_TO_DETERMINE_DEV_NUM = 0
    Byte:0202:           Bit:2, DEV0_RESULT_CSEL_USED_TO_DETERMINE_DEV_NUM = 0
    Byte:0202:           Bit:3, DEV0_RESULT_PASSED_DIAGNOSTICS = 0
    Byte:0202:           Bit:4, DEV0_RESULT_DETECTED_PDIAG = 0
    Byte:0202:           Bit:5, DEV0_RESULT_DETECTED_DASP = 0
    Byte:0202:           Bit:6, DEV0_RESULT_DEV0_RESPONDS_WHEN_DEV1_SELECTED = 0
    Byte:0203:           Bit:0, DEV1_RESULT = 0
    Byte:0203:           Bit:1, DEV1_RESULT_JUMPER_USED_TO_DETERMINE_DEV_NUM = 0
    Byte:0203:           Bit:2, DEV1_RESULT_CSEL_USED_TO_DETERMINE_DEV_NUM = 0
    Byte:0203:           Bit:3, DEV1_RESULT_ASSERTED_PDIAG = 0
    Byte:0203:           Bit:5, EIGHTY_CONDUCTOR_CABLE_PRESENT_BIT = 0
    Byte:0204:       AcousticLevel = 00 FE
    Byte:0206:       StreamMinRequestSize = 00 00
    Byte:0208:       StreamXferTimeDMA = 00 00
    Byte:020A:       StreamAccessLatency = 00 00
    Byte:020C:       StreamPerformanceGranularity = 00 00 00 00
    Byte:0210:       FortyEightBitAddress = 99 A9 6B 1C 00 00 00 00
    Byte:0218:       StreamXferTimePIO = 00 00
    Byte:021A:       Word105 = 00 00
    Byte:021C:       PhysicalLogicalSectorSize = 00 00
    Byte:021E:       InterSeekDelayForISO7779 = 00 00
    Byte:0220:       NAAIEEEOUIHigh = 00 00
    Byte:0222:       IEEEOUILowAndUniqueIDHigh = 00 00
    Byte:0224:       UniqueIDMid = 00 00
    Byte:0226:       UniqueIDLow = 00 00
    Byte:0230:       AVLiteWorstCaseTimer = 00 00
    Byte:0232:       WordsPerLogicalSector = 00 00 00 00
    Byte:0236:       ATACommandSetSupportedExt2 = 24 20
    Byte:0236:           Bit:1, WRITE_READ_VERIFY_SUPPORTED = 0
    Byte:0236:           Bit:2, WRITE_UNCORRECTABLE_SUPPORTED = 1
    Byte:0236:           Bit:3, READ_AND_WRITE_DMA_EXP_GPL_COMMANDS_SUPPORTED = 0
    Byte:0236:           Bit:4, SEGMENTED_DOWNLOAD_MICROCODE_SUPPORTED = 0
    Byte:0238:       ATACommandSetEnabledExt2 = 22 20
    Byte:0238:           Bit:1, WRITE_READ_VERIFY_ENABLED = 1
    Byte:0238:           Bit:3, READ_AND_WRITE_DMA_EXP_GPL_COMMANDS_ENABLED = 0
    Byte:0238:           Bit:4, SEGMENTED_DOWNLOAD_MICROCODE_ENABLED = 0
    Byte:0248:       SecurityStatus = 21 00
    Byte:0248:           Bit:0, SECURITY_SUPPORTED = 1
    Byte:0248:           Bit:1, SECURITY_ENABLED = 0
    Byte:0248:           Bit:2, SECURITY_LOCKED = 0
    Byte:0248:           Bit:3, SECURITY_FROZEN = 0
    Byte:0248:           Bit:4, SECURITY_COUNT_EXPIRED = 0
    Byte:0248:           Bit:5, ENHANCED_SECURITY_ERASE_SUPPORTED = 1
    Byte:0249:           Bit:1, SECURITY_LEVEL_MAXIMUM = 0
    Byte:024A:       FirstATAVendorSpecificPad = 00 00 00 00 00 00 00 00 00 00
                     ''
    Byte:0254:       CompaqWord = 02 00
    Byte:0254:           Bit:1, COMPAQ_CAM_COMPLIANT = 1
    Byte:0256:       SecondATAVendorSpecificPad =
                     00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
                     00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
                     00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
                     00 00
                     ''
    Byte:0288:       Word160 = 00 00
    Byte:028A:       CFAWords =
                     00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
                     00 00 00 00 00 00 00 00 00 00 00 00 00 00
                     ''
    Byte:02A8:       MediaSerialNumberCopy =
                     00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
                     00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
                     00 00 00 00 00 00 00 00
                     ''
    Byte:02D0:       MediaManufacturerCopy =
                     00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
                     00 00 00 00
                     ''
    Byte:02E4:       ATATransportMajorRevisionNumber = 08 10
    Byte:02E6:       ATATransportMinorRevisionNumber = 20 20
    Byte:0346:       ATACheckSum = 00 00
    Byte:0348:       ATSMARTConfig =
                     0F 00 06 00 03 00 00 00 32 00 14 00 33 00 24 00
                     0F 00 1E 00 32 00 00 00 13 00 61 00 32 00 14 00
                     32 00 00 00 3A 00 00 00 22 00 2D 00 32 00 00 00
                     32 00 00 00 32 00 00 00 22 00 00 00 1A 00 00 00
                     12 00 00 00 10 00 00 00 3E 00 00 00 00 00 00 00
                     00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
                     00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
                     00 00 00 00 00 00 00 00
    Byte:0348:       SMART1Status = 0F 00
    Byte:034A:       SMART1Threshold = 06
    Byte:034C:       SMART2Status = 03 00
    Byte:034E:       SMART2Threshold = 00
    Byte:0350:       SMART3Status = 32 00
    Byte:0352:       SMART3Threshold = 14
    Byte:0354:       SMART4Status = 33 00
    Byte:0356:       SMART4Threshold = 24
    Byte:0358:       SMART5Status = 0F 00
    Byte:035A:       SMART5Threshold = 1E
    Byte:035C:       SMART6Status = 32 00
    Byte:035E:       SMART6Threshold = 00
    Byte:0360:       SMART7Status = 13 00
    Byte:0362:       SMART7Threshold = 61
    Byte:0364:       SMART8Status = 32 00
    Byte:0366:       SMART8Threshold = 14
    Byte:0368:       SMART9Status = 32 00
    Byte:036A:       SMART9Threshold = 00
    Byte:036C:       SMART10Status = 3A 00
    Byte:036E:       SMART10Threshold = 00
    Byte:0370:       SMART11Status = 22 00
    Byte:0372:       SMART11Threshold = 2D
    Byte:0374:       SMART12Status = 32 00
    Byte:0376:       SMART12Threshold = 00
    Byte:0378:       SMART13Status = 32 00
    Byte:037A:       SMART13Threshold = 00
    Byte:037C:       SMART14Status = 32 00
    Byte:037E:       SMART14Threshold = 00
    Byte:0380:       SMART15Status = 22 00
    Byte:0382:       SMART15Threshold = 00
    Byte:0384:       SMART16Status = 1A 00
    Byte:0386:       SMART16Threshold = 00
    Byte:0388:       SMART17Status = 12 00
    Byte:038A:       SMART17Threshold = 00
    Byte:038C:       SMART18Status = 10 00
    Byte:038E:       SMART18Threshold = 00
    Byte:0390:       SMART19Status = 3E 00
    Byte:0392:       SMART19Threshold = 00
    Byte:0394:       SMART20Status = 00 00
    Byte:0396:       SMART20Threshold = 00
    Byte:0398:       SMART21Status = 00 00
    Byte:039A:       SMART21Threshold = 00
    Byte:039C:       SMART22Status = 00 00
    Byte:039E:       SMART22Threshold = 00
    Byte:03A0:       SMART23Status = 00 00
    Byte:03A2:       SMART23Threshold = 00
    Byte:03A4:       SMART24Status = 00 00
    Byte:03A6:       SMART24Threshold = 00
    Byte:03A8:       SMART25Status = 00 00
    Byte:03AA:       SMART25Threshold = 00
    Byte:03AC:       SMART26Status = 00 00
    Byte:03AE:       SMART26Threshold = 00
    Byte:03B0:       SMART27Status = 00 00
    Byte:03B2:       SMART27Threshold = 00
    Byte:03B4:       SMART28Status = 00 00
    Byte:03B6:       SMART28Threshold = 00
    Byte:03B8:       SMART29Status = 00 00
    Byte:03BA:       SMART29Threshold = 00
    Byte:03BC:       SMART30Status = 00 00
    Byte:03BE:       SMART30Threshold = 00
    Byte:03C0:       ATSMARTDefaultFlags = 00 00
    Byte:03C0:           Bit:0, SMARTDEFAULTON = 0
    Byte:03C2:       SCTCommandSetSupported = 40 4B
    Byte:03C4:       SCTFanControlMaxOperatingTemp = 00
    Byte:03C5:       SCTFanControlOverRangeTemp = 00
    Byte:03C6:       SCTFanControlUnderRangeTemp = 00
    Byte:03C7:       SCTFanControlMinOperatingTemp = 00
    Byte:03C8:       SCTVendorFlags = 00 00
    Byte:03C8:           Bit:0, SCT_VENDORFLAGS_SEATOOLS = 0
    Byte:03C8:           Bit:1, SCT_VENDORFLAGS_WRITE_SAME = 0
    Byte:03C8:           Bit:2, SCT_VENDORFLAGS_CORRECTABLE_BIT = 0
    Byte:03C9:           Bit:7, SCT_VENDORFLAGS_DEBUG_MODE = 0
    Byte:03CA:       SCTTimerReadDefault = 00
    Byte:03CB:       SCTTimerWriteDefault = 00
    Byte:03CC:       SCTTenMsecCount = 00
    Byte:03CD:       SCTPerformanceFlags = 00
    Byte:03CE:       ATAPadSlewRate = 00
    Byte:03CF:       ATAIORDYPadControl = 00
    Byte:03D0:       PreampHotTweak = 00
    Byte:03D1:       PreampColdTweak = 00
    Byte:03D2:       LubeMitigationRetries = 00 00
    Byte:03D4:       LengthOfWriteCommandToTriggerFlush = 00 00
    Byte:03D6:       LengthOfWriteSpaceToFlush = 00 00
    Byte:03D8:       NDSLBAThresholdA = 00 00
    Byte:03DA:       NDSLBAThresholdB = 00 00
    Byte:03DC:       NDSPartitionDependencies = 00 00
    Byte:03DE:       NDSODOffsetConfig = 00
    Byte:03DF:       NDSIDOffsetConfig = 00
    Byte:03E0:       APMTimer1mSec = 40 04
    Byte:03E2:       APMTimer2mSec = 00 15
    Byte:03E4:       APMStandByTimer = 20 00
    Byte:03E6:       APMTimerForDither = 2C 01
    Byte:03E8:       ReadDelayMinimum = 00
    Byte:03E9:       ReadDelayIncremental = 00
    Byte:03EA:       WriteDelayMinimum = 00
    Byte:03EB:       WriteDelayIncremental = 00
    Byte:03EC:       NativeCapacity = 99 A9 6B 1C
    Byte:03F0:       HDACapacity = 99 A9 6B 1C
    Byte:03F4:       FeatureFlags = 00 A0 08 00
    Byte:03F4:           Bit:0, WRITE_CONFIG_DATA_TO_FLASH = 0
    Byte:03F4:           Bit:1, SPINUP_WRITE_FAULT_THRESHOLDS_ENABLED = 0
    Byte:03F4:           Bit:2, IOEDC_CHECK_ENABLED = 0
    Byte:03F4:           Bit:3, IOEDC_ERROR_ENABLED = 0
    Byte:03F4:           Bit:4, DOWNLOAD_MICROCODE_FUTURE_USE_ONLY = 0
    Byte:03F4:           Bit:5, SUPPRESS_SERIAL_PORT_PRINTS = 0
    Byte:03F4:           Bit:6, DRQ_CLEAR_ON_PIO_READ_ERR_SUPPORTED = 0
    Byte:03F4:           Bit:7, OFFLINE_SEEK_AWAY = 0
    Byte:03F5:           Bit:0, DELAY_SLEEP_STANDBY_CMDCOMPLETE = 0
    Byte:03F5:           Bit:1, IDLE_IMMEDIATE_UNLOAD_EMERGENCY = 0
    Byte:03F5:           Bit:2, ENABLE_ALLOW_RAW_ERROR_RATE_UPDATE = 0
    Byte:03F5:           Bit:3, OP_SHOCK_DETECTION_ENABLED = 0
    Byte:03F5:           Bit:4, LOG99_CONTROL = 0
    Byte:03F5:           Bit:5, READ_WRITE_LONG_EXTENDED_ENABLED = 1
    Byte:03F5:           Bit:6, WRITE_REORDERING_DISABLED = 0
    Byte:03F5:           Bit:7, ALLOW_AAM_FEATURE_SET = 1
    Byte:03F6:           Bit:0, DATA_LOG_ENABLED = 0
    Byte:03F6:           Bit:1, HOST_STREAM_RECORD_FIRST_ERROR_BLOCK = 0
    Byte:03F6:           Bit:2, SAVE_ATA_COMMAND_HISTORY_TO_DISC = 0
    Byte:03F6:           Bit:3, EIB_ON_POWERUP = 1
    Byte:03F6:           Bit:4, LEFT_JUSTIFY_SERIAL_NUMBER = 0
    Byte:03F6:           Bit:5, SUN_MICRO_MODEL_NUMBER_UPDATE = 0
    Byte:03F6:           Bit:6, REVERTING_TO_POWER_ON_DEFAULTS_SUPPORTED = 0
    Byte:03F6:           Bit:7, RIGHT_JUSTIFY_FIRMWARE_REVISION = 0
    Byte:03F8:       PerformanceFlags = 00 00
    Byte:03F8:           Bit:0, REDUCED_RAW_TRANSITION_FLUSH = 0
    Byte:03F8:           Bit:1, REDUCED_AV_RETRIES = 0
    Byte:03F8:           Bit:2, READ_LOOKAHEAD_DISABLED_ON_POWER_UP = 0
    Byte:03F8:           Bit:3, JIT3 = 0
    Byte:03F8:           Bit:4, JIT2 = 0
    Byte:03F8:           Bit:5, JIT1 = 0
    Byte:03F8:           Bit:6, JIT0 = 0
    Byte:03F8:           Bit:7, ZERO_LATENCY_RD_ENABLED = 0
    Byte:03F9:           Bit:0, DAR_ENABLED = 0
    Byte:03F9:           Bit:1, OFFLINE_SPARING_ENABLED = 0
    Byte:03FA:       AggressivelyScanThisManyTimes = 00 00
    Byte:03FC:       DOSNeedToScanThreshold = 00
    Byte:03FD:       DOSOughtToScanThreshold = 00
    Byte:03FE:       SleepStandbyDelay = 00 00
    Byte:0400:       CustomerUniques = 00 00 00 00
    Byte:0404:       CustomerType = 00 00 00 00
    Byte:0408:       AdditionalSATAFeatureConfig = 00 00 00 00
    Byte:0408:           Bit:0, SATA_FORCE_EARLY_STATUS = 0
    Byte:0408:           Bit:1, SATA_EARLY_STATUS_FORCE_COMRESET = 0
    Byte:0408:           Bit:2, SATA_INTRACOMMAND_PHY_MANAGEMENT_ENABLED = 0
    Byte:0408:           Bit:3, SATA_ENABLE_PHY_PM_CALIBRATION = 0
    Byte:0408:           Bit:4, SATA_ENABLE_SPI_VIS_MODE = 0
    Byte:0408:           Bit:5, SATA_AGGRESSIVE_PHY_SUPPORTED = 0
    Byte:0408:           Bit:6, SATA_ENABLE_SSC = 0
    Byte:0408:           Bit:7, SATA_ACTIVITY_LED = 0
    Byte:0409:           Bit:0, SATA_DISABLE_PRIMITIVE_SCRAMBLING = 0
    Byte:040C:       FactoryODScanMBytes = D0 07
    Byte:040E:       FactoryIDScanMBytes = E8 03
    Byte:0410:       MaxDSTSelfTestTime = 54 15
    Byte:0412:       DSTShortTestTimeLimit = 3C 00
    Byte:0414:       CongenDriveType = 00 26
    Byte:0416:       BootFlagsForROM = 00 00
    Byte:0416:           Bit:0, BOOT_FLAG_POWER_ON_IN_STANDBY = 0
    Byte:0416:           Bit:1, BOOT_FLAG_PARTIAL_OOB = 0
    Byte:0416:           Bit:2, USE_SMALL_ID_FORMAT = 0
    Byte:0416:           Bit:3, LOW_CURRENT_SPINUP = 0
    Byte:0418:       LastCongenWriteCaller = 00 00
    Byte:041A:       RealTimeUpdatedFlags = 08 00
    Byte:041A:           Bit:0, HPA_SET_BY_SETMAX = 0
    Byte:041A:           Bit:1, HPA_SET_BY_SETMAX_EXT = 0
    Byte:041A:           Bit:2, DCO_SET_ACTIVE = 0
    Byte:041A:           Bit:3, CONGEN_READ_FROM_MEDIA = 1
    Byte:041C:       CheckSum = 00 00
    Byte:041E:       HostStreamJumpSizeInSectors = 00 00
    Byte:0420:       HostStreamTotalJumpSteps = 00
    Byte:0421:       SerialDebugLevel = 00
    Byte:0422:       DefaultStandbyTimer = 00
                                                                                                                                              
    Bytes Returned = 0.
    F3 T>
    
          Note: Congen words that can not be modified will be highlighted.

    If no error occurred, Parameter 0 is entered and Parameter 1 is not entered, the
    current value of the specified Congen Parameter will be displayed.

    If no error occurred and Parameter 0 and 1 are both entered, the new value of the
    specified Congen Parameter will be displayed.

  <b><i><u>Examples:</u></i></b>

     To display the full Congen in a humanized way:

       In:
       F3 T>F

       Out:
       (See above for example of full humanized output)
     

     To display a single Congen parameter in a humanized way:
     (The byte offset of the Congen Parameter, SerialDebugLevel, could be at a different
     byte offset than this example shows.  Use this example with caution!)

       In:
       F3 T>F421
       F3 T>F0421
       F3 T>F"SerialDebugLevel"

       Out:
       Byte:0421:       SerialDebugLevel = 00
     

     To modify the Congen:
     (Although these are syntactically valid usages, they are nonsensical; However, they all
     do the same thing)

       In:
       F3 T>F421,41
       F3 T>F421,"A"
       F3 T>F0421,41
       F3 T>F0421,"A"
       F3 T>F"SerialDebugLevel",41
       F3 T>F"SerialDebugLevel","A"

       Out:
       Byte:0421:       SerialDebugLevel = 41

  <b><i><u>Revision History:</u></i></b>
<a name="SET_CONGEN_PARM_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="SET_CONTROLLER_TEST_PORT_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Set Controller Test Port"></a><hr align=left width="75%"><b> Set Controller Test Port (Level A 'M')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command is used to set the controller test port mux.

  <b><i><u>Quick Help:</u></i></b>
<a name="SET_CONTROLLER_TEST_PORT_QUICK_HELP"></a>
    "SetControllerTestPort, M[Port],[Value]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="SET_CONTROLLER_TEST_PORT_PARM"></a>
    0 - Test Port.
    
        This input specifies the Test port to set.
    
          Type:    Unsigned 8-bit value
    
          Range:   0 to 0xFF
    
          Default: None
    
    1 - Test Port Value.
    
        This input specifies the Value to set to the Test port. If this input is set
        to 0xFF then the test port will be disabled.
    
          Type:    Unsigned 8-bit value
    
          Range:   0 to 0xFF
    
          Default: None
    

  <b><i><u>Output Data:</u></i></b>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    

  <b><i><u>Revision History:</u></i></b>
<a name="SET_CONTROLLER_TEST_PORT_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="SET_DERP_RETRIES_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Set Retries - DERP"></a><hr align=left width="75%"><b> Set Retries - DERP (Level 2, 7, A, F 'Y')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command allows the user to specify the error recovery parameters that will be used
    for subsequent diagnostic commands.  (This version of the Set Retries command is only
    available if the drive supports DERP!  To know whether your drive supports DERP, issue
    the Online "^L" command to see a list of features supported by the drive.)

  <b><i><u>Quick Help:</u></i></b>
<a name="SET_DERP_RETRIES_QUICK_HELP"></a>
    "SetDerpRetries, Y[Mode],[MaxRdRetries],[MaxWrtRetries],[OtcTLevel],[Options]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="SET_DERP_RETRIES_INPUT_PARM"></a>
    0 - Error Recovery Mode.
    
        This parameter specifies the error recovery mode to be used.  The following
        error recovery modes are available:
    
             0 = Maximum Normal
             1 = Maximum Full
             2 = Default Normal
             3 = Default Full
             4 = Minimum Normal
             5 = Minimum Full
             6 = Simple
    
        The Maximum Error Recovery Modes (0 and 1) are typically used for system
        information recovery.
    
        The Default Error Recovery Modes (2 and 3) are typically used by the native
        interface.
    
        The Minimum Error Recovery Modes (4 and 5) are typically used for diagnostic
        and media certification operations.
    
        The Normal Error Recovery Modes (0, 2 and 4) should be used for multiple sector
        transfers.  The retry steps for these modes employ less extreme tweaks to recover
        the data.  This increases the chance of successfully reading subsequent sectors
        without resetting tweaks.
    
        The Full Error Recovery Modes (1, 3 and 5) should be used for single sector
        transfers.  The retry steps for these modes employ more extreme tweaks to
        recover the data.  The tweaks used by these modes would make it difficult to
        read subsequent sectors without error.
    
        The Simple Error Recover Mode is a "Normal" type error recovery mode but with no
        additional options enabled.
    
        Error Recovery Mode 0 (Default Normal) is the default configuration used by the
        native interface (aka, "Interface Level Retries")
    
        TIP: Setting the Error Recovery Mode without setting any other parameters will
        restore the default settings for the specified Error Recovery Mode.
    
          Type:    Unsigned 8-bit value
    
          Range:   0 to 6
    
          Default: If this parameter is not entered, the current error recovery mode
                   will not be changed.
    
    1 - Maximum read retry count allowed.
    
        If entered, this parameter specifies the maximum allowed read retry count.  NOTE:
        Specifying this parameter will cause the corresponding Error Recovery Options bit
        to be set that enables the use of this value.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: If this parameter is not entered, the maximum allowed read retry count
                   for the specified error recovery mode will not be changed.
    
    2 - Maximum write retry count allowed.
    
        If entered, this parameter specifies the maximum allowed write retry count.  NOTE:
        Specifying this parameter will cause the corresponding Error Recovery Options bit
        to be set that enables the use of this value.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: If this parameter is not entered, the maximum allowed write retry count
                   for the specified error recovery mode will not be changed.
    
    3 - On-the-fly Correction ECC T-Level.
    
        If entered, this parameter specifies the ECC T-Level to be used for on-the-fly
        correction.  Although any value from 0x00 to 0xFF may be entered, the diagnostic
        will automatically round down to the nearest available value from the entered
        value.  NOTE: Specifying this parameter will cause the corresponding Error Recovery
        Options bit to be set that enables the use of this value.
    
          Type:    Unsigned 8-bit value
    
          Range:   0 to 0xFF
    
          Default: If this parameter is not entered, the on-the-fly correction ECC T-Level
                   for the specified error recovery mode will not be changed.
    
    4 - Error Recovery Options.
    
        If entered, this parameter specifies the options that are allowed to be set for
        the Error Recovery system.  The definition of each bit is specified below:
    
<a name="READ_WRITE_ERROR_RECOVERY_MODE_OPTIONS"></a>
        
        Bit 0: Enable maximum OTF ECC correction.
        
               If set, maximum on-the-fly ECC correction will be applied.
        
        Bit 1: Apply only minimum ECC correction.
        
               If set, only minimum on-the-fly ECC correction will be applied.
        
        Bit 2: Enable transfer of uncorrectable data block.
        
               If set, uncorrectable sectors will be transfered from the Correction
               Buffer to the Read Buffer.
        
        Bit 3: Enable restricted servo flaws coast - read.
        
               If set, restrict servo flaw coasting during a read only if one of the
               following conditions applies:
        
                 1) The failed block is not associated with a known grown servo flaw
                 2) New servo flaws are detected on the target track
                 3) Forced servo coast tweaks
        
        Bit 4: Enable restricted servo flaws coast - write.
        
               If set, restrict servo flaw coasting during a write only if one of the
               following conditions applies:
        
                 1) The failed block is not associated with a known grown servo flaw
                 2) New servo flaws are detected on the target track
                 3) Forced servo coast tweaks
        
        Bit 5: Enable early error recovery exit.
        
               If set, error recovery will terminate when the retry step is equal
               to the early exit retry step.
        
        Bit 6: Disable normal retry tweak steps.
        
               If set, all retry tweak steps will be disabled for normal error recovery
               modes.
        
        Bit 7: Disable full-hidden retry tweak steps.
        
               If set, the hidden retry steps will be disabled for the full error
               recovery modes.  The first 9 steps of the full error recovery modes
               are defined as hidden retries.
        
        Bit 8: Disable full retry tweak steps.
        
               If set, all retry steps will be disabled for the full error recovery
               modes.
        
        Bit 9: Disable undo of retry tweaks.
        
               If set, the retry tweaks will not be undone after the retry completes.
        
        Bit 10: Disable on-the-fly ECC correction - initial access.
        
                If set, on-the-fly ECC correction will be disabled for the initial
                attempt to access a sector.
        
        Bit 11: Disable on-the-fly ECC correction - normal retry tweak steps.
        
                If set, on-the-fly ECC correction will be disabled for the normal
                error recovery modes for all retry steps.
        
        Bit 12: Disable on-the-fly ECC correction - full-hidden retry tweak steps.
        
                If set, on-the-fly ECC correction will be disabled for the full
                error recovery modes for all hidden retry steps.  The first 9
                steps of the full error recovery modes are defined as hidden retries.
        
        Bit 13: Disable on-the-fly ECC correction - full retry tweak steps.
        
                If set, on-the-fly ECC correction will be disabled for the full
                error recovery modes for all retry steps following the hidden
                retries.  The first 9 retry steps of the full error recovery modes
                are defined as hidden retries.
        
        Bit 14: Enable selected ER retry step.
        
                If this bit is set and Mode Options Bit 15 is also set, a specified
                error recovery step will be used for the initial sector access.
        
        Bit 15: Skip initial read/write access of request.
        
                Typically, the initial access of a sector is performed without error
                recovery.  If this bit is set, the initial sector access will be
                performed using error recovery.  If Mode Options Bit 14 is also set,
                a specified error recovery step will be used for the initial sector
                access.  If Mode Options Bit 14 is cleared, the first error recovery
                step will be used for the initial sector access.
        
        Bit 16: Enable ECC selection setting - normal retries only.
        
                If set, a specified ECC T-Level will be used for on-the-fly correction
                only during NORMAL retries.  (This bit is a "don't care" if Bit 23 is
                set.)
        
        Bit 17: Disable retry on track integrity error.
        
                If set, retries will be disabled on track integrity errors.
        
        Bit 18: Allow one retry.
        
                If set, only a single, normal retry will be enabled.  (This feature
                is not typically enabled in OEM code.)
        
        Bit 19: Disable PFast.
        
                If set, P-Fast will be disabled during preamp fast tweaks.
        
        Bit 20: Enable use of selected maximum read retry count.
        
                If set, only a specified number of read retries will be allowed when
                read retries are required.
        
        Bit 21: Enable use of selected maximum write retry count.
        
                If set, only a specified number of write retries will be allowed when
                write retries are required.
        
        Bit 22: Enable selected maximum retry counts in non-User media partition.
        
                If set, the maximum read and write retry counts that have been enabled
                by Bits 20 and 21 will be applied to retries in non-user partitions.
        
        Bit 23: Enable ECC selection setting.
        
                If set, a specified ECC T-Level will be used for on-the-fly correction
                for all retry modes.  Setting this bit causes Bit 16 to be considered
                a "don't care."
        
        Bit 24: Disable the extended retries applied to Write Unsafe error.
        
                If set, the extended retries applied to Write Unsafe errors will be
                disabled.
        
        Bit 25: Enable reporting of recovered servo seek error to host.
        
                If set, recovered servo seek errors will be reported to the host.
        
        Bit 26: Enable Read/Write to complete transfers in RAW mode.
        
                If set and the Read-After-Write feature is enabled for the product,
                the Read/Write firmware is allowed to request that a transfer be
                completed in RAW mode.
        
        Bit 24: Enable Reduced Erasure correction.
        
                If set and the Reduced Erasure Correction feature is enabled for
                the product, the level of erasure correction applied during retries
                will be reduced.
        
        Bit 27: Enable abort during error recovery.
        
                If set, abort request will be honored during error recovery.
                Note that this bit only applies for single-block error
                recovery.  For non single-block error recovery, abort of
                error recovery is already allowed.
        
        Bits 28-31: Unused.
        
        
        To Disable All Retries:
           Clear bit 18
           Set bits 6, 7, and 8
        
        To Disable OTF Correction:
           Set bits 10, 11, 12, and 13
        
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: If this parameter is not entered, the Error Recovery Options for the
                   specified error recovery mode will not be changed.
    

  <b><i><u>Output Data:</u></i></b>
<a name="SET_DERP_RETRIES_OUTPUT_DATA"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
        If no error occurred, the current Error Recovery configuration will be displayed
        as follows.
    
           "Error Recovery Info:
    
           " P0: Mode a (bbbbbb)"
    
           " P4: Options = eeeeee"
    
           "     B26: (f) gggggg R/W allowed to use RAW"
           "     B25: (f) gggggg Recovered Servo Sk Err Reporting"
           "     B24: (f) gggggg Ext WUS Err Retries OR Reduced Erasure correction"
    
           "     B23: (f) gggggg P3: Selected OTF ECC T-level = jj"
           "     B22: (f) gggggg Max Retries In Non-User Partition"
           "     B21: (f) gggggg P1: Max Write Retries = hh"
           "     B20: (f) gggggg P2: Max Read Retries = ii"
    
           "     B19: (f) gggggg P-Fast"
           "     B18: (f) gggggg Single Retry"
           "     B17: (f) gggggg Trk Integrity Err Retry"
           "     B16: (f) gggggg Selected OTF ECC T-level (Normal Retries ONLY)"
    
           "     B15: (f) gggggg Initial RW Access"
           "     B14: (f) gggggg Selected Retry Step = kk"
           "     B13: (f) gggggg OTF on Full Retry Steps"
           "     B12: (f) gggggg OTF on Full-Hidden Retry Steps"
    
           "     B11: (f) gggggg OTF on Normal Retry Steps"
           "     B10: (f) gggggg OTF on Initial Access"
           "     B09: (f) gggggg undo of Retry Tweaks"
           "     B08: (f) gggggg Full Retries"
    
           "     B07: (f) gggggg Full-Hidden Retries"
           "     B06: (f) gggggg Normal Retries"
           "     B05: (f) gggggg Early Err Recovery Exit"
           "     B04: (f) gggggg Restricted Servo Flaw Coasting during Write"
    
           "     B03: (f) gggggg Restricted Servo Flaw Coasting during Read"
           "     B02: (f) gggggg xfer of Uncorrectable Sectors"
           "     B01: (f) gggggg Min OTF ECC Correction"
           "     B00: (f) gggggg Max OTF ECC Correction"
    
    
           where
    
              a      is the Error Recovery Mode number
    
              bbbbbb is a string representing the Error Recovery Mode
    
              eeeeee are the Error Recovery Options that are selected for the current Error
                     Recovery Mode
    
              f      is the state of the options bit
    
              gggggg is a string indicating whether the feature controlled by the options bit is
                     enabled or disabled
    
              hh     is the maximum number of allowable write retries for the current Error
                     Recovery Mode
    
              ii     is the maximum number of allowable read retries for the current Error
                     Recovery Mode
    
              jj     is the ECC T-Level to be used for On-The-Fly Correction for the current
                     Error Recovery Mode
    
              kk     is the Selected Error Retry Step for the current Error Recovery Mode
    

  <b><i><u>Revision History:</u></i></b>
<a name="SET_DERP_RETRIES_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0002.0000   Added support for recent changes to the "options" parameter (non-DERP).
    0010.0000   Added support for DERP and simple retries.  (NOTE: Several revisions have
                been skipped because this command shares the same command letter with the
                "regular" Set Retries command and the old command must still be supported.)
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="SET_DERP_RETRY_STATE_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Set DERP Retry State"></a><hr align=left width="75%"><b> Set DERP Retry State (Level 2, 7, A, F 'y')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command allows the user to specify the DERP Retry State that will be used by the
    Read/Write firmware subsystem's Error Recovery system during subsequent diagnostic
    commands that access the disc.  (This command is only available on drives that support
    DERP!  To know whether your drive supports DERP, issue the Online "^L" command to see a
    list of features supported by the drive.)

  <b><i><u>Quick Help:</u></i></b>
<a name="SET_DERP_RETRY_STATE_QUICK_HELP"></a>
    "SetDerpRetryState, y[Type],[PathState],[RetryStateCnt],[LoopCnt1],[LoopCnt2]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="SET_DERP_RETRY_STATE_PARM"></a>
    
    IMPORTANT: Either all parameters must be entered or no parameters must be entered.  If
    all parameters are specified, then the Selected DERP Retry State will be enabled and the
    state values will be set to the specified values.  If no parameters are specified, then
    the Selected DERP Retry State will be disabled.  Entering parameters any other way will
    cause the command to fail.
    
    0 - DERP Error Type.
    
        This parameter specifies the type of error that the DERP Error Recovery system will
        assume for subsequent diagnostic operations.  Valid values for this parameter are
        given below:
<a name="RW_RETRY_PATHS"></a>
        0 = UNDETERMINED
        1 = DATA_ERROR
        2 = SYNC
        3 = TA
        4 = DATAORTA
        5 = SYNCTA
        6 = SYNCORDATA
    
          Type:    Unsigned 8-bit value
    
          Range:   0 to Maximum DERP Error Type
    
          Default: None
    
    1 - DERP Path State
    
        This parameter specifies the path count from the current retry sequence that the DERP
        Error Recovery system will assume for subsequent diagnostic operations.  The meaning
        of the Path State is dependent on the Error Type (parameter 0).
    
          Type:    Unsigned 8-bit value
    
          Range:   0 to 0xFF
    
          Default: None
    
    2 - DERP Retry State Count.
    
        This parameter specifies the retry path count from the current retry sequence that
        the DERP Error Recovery system will assume for subsequent diagnostic operations.
    
          Type:    Unsigned 8-bit value
    
          Range:   0 to 0xFF
    
          Default: None
    
    3 - DERP Retry Loop Count 1.
    
        This parameter specifies the first loop counter that the DERP Error Recovery system
        will assume for subsequent diagnostic operations.
    
          Type:    Unsigned 8-bit value
    
          Range:   0 to 0xFF
    
          Default: None
    
    4 - DERP Retry Loop Count 2.
    
        This parameter specifies the second loop counter that the DERP Error Recovery system
        will assume for subsequent diagnostic operations.
    
          Type:    Unsigned 8-bit value
    
          Range:   0 to 0xFF
    
          Default: None
    

  <b><i><u>Output Data:</u></i></b>
<a name="SET_DERP_RETRY_STATE_OUTPUT_DATA"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
        If no error occurred, the current Error Recovery configuration will be displayed
        as follows.
    
           "Selected DERP Retry State XXXXXXXX"
    
        where XXXXXXXX is either "Enabled" or "Disabled"
    
        If the Selected DERP Retry State is Enabled, then the following will also be displayed:
    
           " P0: Error Type:        aa"
           " P1: Path State:        bb"
           " P2: State Count:       cc"
           " P3: Loop Counter 1:    dd"
           " P4: Loop Counter 2:    ee"
    
        where
    
           aa is the type of error.
           bb is the path count from the current retry sequence.
           cc is the retry path count from the current retry sequence.
           dd is the first loop counter.
           ee is the second loop counter.
    

  <b><i><u>Revision History:</u></i></b>
<a name="SET_DERP_RETRY_STATE_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="SET_DIAG_IDLE_MODE_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Set Diag Idle Mode"></a><hr align=left width="75%"><b> Set Diag Idle Mode (Level 2 'M')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This commmand enables / disables Idle Mode features.  The Online Control P command can
    subsequently toggle selected features off and back on.  The mode you set will not
    change when you move among diag, interface, and online modes (that is, the mode will
    stay set when you use ctl-T, ctl-R, and ctl-Z).

  <b><i><u>Quick Help:</u></i></b>
<a name="SET_DIAG_IDLE_MODE_QUICK_HELP"></a>
    "SetDiagIdleMode, M[ModeSelect],[ModeMask],[ResetToPowerOn]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="SET_DIAG_IDLE_MODE_PARM"></a>
    
    0 - Idle features mode select
    
        This parameter specifies which idle mode features are enabled.
    
          Enable STIR                     0x1
          Enable TCC                      0x2
          Enable Continuous Writer Heat   0x4
          Enable MR Bias Chop and disable
            Continuous Preamp Power       0x8
          Enable PFAST                    0x10
          Enable Self Seek                0x20 (only on some drives)
          Continuous Channel Power        0x40
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0x3F
    
          Default: If no value entered, display current features enabled.
    
    
    1 - Idle features mode mask
    
        This parameter specifies which idle mode features are MODIFIED, both
        by this command and by subsequent ctl-P commands.  For each bit,
        a 1 in this parameter means this feature will be enabled or
        disabled depending on how parameter 0 is set.  A zero in a bit for this
        parameter means this feature will remain unchanged regardless of how
        parameter 0 is set.
        Ctl-P toggles the bits set in this parameter.
        If this parameter is not entered, all bits are set according to parameter 0
        and the Ctl-P mask is unchanged.
        If parameter 0 is not entered, this parameter is ignored.
    
          Enable STIR                     0x1
          Enable TCC                      0x2
          Enable Continuous Writer Heat   0x4
          Enable MR Bias Chop             0x8
          Enable PFAST                    0x10
          Enable Self Seek                0x20
          Continuous Channel Power        0x40
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to DIAG_POWER_ALL
    
          Default: 0x3F [ all features modified ]
    
          Example: 2> M3,7 sets STIR and TCC, clears Continuous Writer Heat and
            MR Bias Chop, and leaves PFAST and Self Seek unchanged.
            Subsequent clt-P commands toggle only STIR, TCC, and Continuous Writer
            Heat.
    
    
    2 - Reset to power on values
    
        If this parameter is entered, the other parameters are ignored.  The idle
        mode is reset to its power on value.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: none
    
          Example: 2> M,,7 sets the idle mode to what it was when the drive powered
            on.
    

  <b><i><u>Output Data:</u></i></b>
<a name="DIAG_IDLE_MODE"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
     If no error occurred, then the following will be displayed:
    
                        Dithering xxx  ctl-P yyyyyyyyyyy
                              TCC xxx  ctl-P yyyyyyyyyyy
        Continuous heat to writer xxx  ctl-P yyyyyyyyyyy
        MR chop / cnt. preamp pwr xxx  ctl-P yyyyyyyyyyy
                            PFast xxx  ctl-P yyyyyyyyyyy
         Continuous channel power xxx  ctl-P yyyyyyyyyyy
    
     Where:
    
        xxx is either "On" or "Off"
    
        yyyyyyyyyyy is either "toggles" or "won't toggle"
    
    </font>

  <b><i><u>Examples:</u></i></b>

    Example #1:
    To turn on Dithering and TCC, turn off continuous heat and
    MR chop, and leave PFast and channel power unchanged:

       F3 2>M3,f

                        Dithering On   ctl-P toggles
                              TCC On   ctl-P toggles
        Continuous heat to writer Off  ctl-P toggles
        MR chop / cnt. preamp pwr Off  ctl-P toggles
                            PFast Off  ctl-P won't toggle
         Continuous channel power Off  ctl-P won't toggle

       Note that the second parameter ('f' above) will control what
       toggles with control P.

       [ issue control P ]

                        Dithering Off  ctl-P toggles     <- used to be ON
                              TCC Off  ctl-P toggles     <- used to be ON
        Continuous heat to writer On   ctl-P toggles     <- used to be OFF
        MR chop / cnt. preamp pwr On   ctl-P toggles     <- used to be OFF
                            PFast Off  ctl-P won't toggle
         Continuous channel power Off  ctl-P won't toggle

       [ issue control P ]

                        Dithering On   ctl-P toggles     <- used to be OFF
                              TCC On   ctl-P toggles     <- used to be OFF
        Continuous heat to writer Off  ctl-P toggles     <- used to be ON
        MR chop / cnt. preamp pwr Off  ctl-P toggles     <- used to be ON
                            PFast Off  ctl-P won't toggle
         Continuous channel power Off  ctl-P won't toggle


    Example #2:
    To turn off power chop and see RDX/RDY on all the time:

       F3 2>M0,8

                        Dithering On   ctl-P won't toggle
                              TCC On   ctl-P won't toggle
        Continuous heat to writer On   ctl-P won't toggle
        MR chop / cnt. preamp pwr Off  ctl-P toggles
                            PFast Off  ctl-P won't toggle
         Continuous channel power Off  ctl-P won't toggle


  <b><i><u>Revision History:</u></i></b>
<a name="SET_DIAG_IDLE_MODE_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="SET_DIRECT_WRITE_MODE_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Set Direct Write Mode"></a><hr align=left width="75%"><b> Set Direct Write Mode (Level 2 'N')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    The Set Direct Write Mode commmand enables or disables Direct Write mode.

  <b><i><u>Quick Help:</u></i></b>
<a name="SET_DIRECT_WRITE_MODE_QUICK_HELP"></a>
    "SetDirectWrite, N[EnableDirWrtModeOpt]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="SET_DIRECT_WRITE_MODE_PARM"></a>
    0 - Enable Direct Write Mode.
    
        If Parameter 0 is not entered or is equal to 0, the direct write mode will
        disabled and the normal write mode will be restored for the diagnostic write
        operation.
    
        If this parameter is entered and is not equal to 0, the direct write mode
        will be enabled for the diagnostic write operation.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: 0
    
 
  <b><i><u>Output Data:</u></i></b>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
 
  <b><i><u>Examples:</u></i></b>
    The following command enables the Direct Write Mode:

       F3 2>N1

    The following commands disable the Direct Write Mode and restore the normal
    write mode:

       F3 2>N
       F3 2>N0

  <b><i><u>Revision History:</u></i></b>
<a name="SET_DIRECT_WRITE_MODE_REVISION_HISTORY"></a>
    0001.0000   Initial revision.

<a name="SET_RETRIES_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Set Retries - Non-DERP"></a><hr align=left width="75%"><b> Set Retries - Non-DERP (Level 2, 7, A, F 'Y')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command allows the user to specify the error recovery parameters that will be used
    for subsequent diagnostic commands.  (This version of the Set Retries command is only
    available if the drive does NOT support DERP!  To know whether your drive supports DERP,
    issue the Online "^L" command to see a list of features supported by the drive.)

  <b><i><u>Quick Help:</u></i></b>
<a name="SET_RETRIES_QUICK_HELP"></a>
    "SetRetries, Y[Config],[Mode],[MaxRdRetryLevel],[MaxWrRetryLevel],[RetryStep],[OtcTLevel],[MaxRetryCnt],[Opts]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="SET_RETRIES_INPUT_PARM"></a>
    0 - Error Recovery Configuration.
    
        NOTE: This parameter is ignored if entered!  Since the Error Recovery Configuration
        can be derived from the Error Recovery Mode, it is not necessary to specify it.
        However, the parameter is retained for backwards compatibility.
    
        The following error recovery configurations may be set by this command:
    
             0 = Normal error recovery configuration
             1 = Format user partition error recovery configuration
             2 = Format system partition error recovery configuration
             3 = Full error recovery configuration
    
        Error Recovery Configurations 0 through 2 apply to the normal error recovery
        modes and should be used for multiple sector transfers.  The retry steps for
        these configurations employ less extreme tweaks to recover the data.  This
        increases the chance of successfully reading subsequent sectors without
        resetting tweaks.
    
        Error Recovery Configuration 3 applies to the full error recovery modes and
        should be used for single sector transfers.  The retry steps for these
        configurations employ more extreme tweaks to recover the data.  The tweaks
        used by this configuration would make it difficult to read subsequent sectors
        without error.
    
        Error Recovery Configuration 0 is the default configuration used by the native
        interface.
    
          Type:    Unsigned 8-bit value
    
          Range:   0 to 3
    
          Default: If this parameter is not entered, the current error recovery
                   configuration will not be changed.
    
    1 - Error Recovery Mode.
    
        This parameter specifies the error recovery mode to be used.  The following
        error recovery modes are available.
    
             0 = Maximum Normal
             1 = Maximum Full
             2 = Default Normal
             3 = Default Full
             4 = Minimum Normal
             5 = Minimum Full
             6 = Simple
    
        The Maximum Error Recovery Modes (0 and 1) are typically used for system
        information recovery.
    
        The Default Error Recovery Modes (2 and 3) are typically used by the native
        interface.
    
        The Minimum Error Recovery Modes (4 and 5) are typically used for diagnostic
        and media certification operations.
    
        The Normal Error Recovery Modes (0, 2 and 4) should be used for multiple sector
        transfers.  The retry steps for these modes employ less extreme tweaks to recover
        the data.  This increases the chance of successfully reading subsequent sectors
        without resetting tweaks.
    
        The Full Error Recovery Modes (1, 3 and 5) should be used for single sector
        transfers.  The retry steps for these modes employ more extreme tweaks to
        recover the data.  The tweaks used by these modes would make it difficult to
        read subsequent sectors without error.
    
        Error Recovery Mode 0 is the default configuration used by the native interface.
    
          Type:    Unsigned 8-bit value
    
          Range:   0 to 5
    
          Default: If this parameter is not entered, the current error recovery mode
                   will not be changed.
    
    2 - Maximum Read Retry Level Allowed.
    
        If entered, this parameter specifies the maximum read retry level allowed.
    
        Note: A retry level consists of one or more retry steps and each retry step
        performs a single disk transfer after performing one or more tweaks.  Therefore,
        the retry level is not equivalent to the retry count.
    
          Type:    Unsigned 8-bit value
    
          Range:   0 to 0x0B
    
          Default: If this parameter is not entered, the maximum read retry level for the
                   specified error recovery mode will not be changed.
    
    3 - Maximum Write Retry Level Allowed.
    
        If entered, this parameter specifies the maximum write retry level allowed.
    
        Note: A retry level consists of one or more retry steps and each retry step
        performs a single disk transfer after performing one or more tweaks.  Therefore,
        the retry level is not equivalent to the retry count.
    
          Type:    Unsigned 8-bit value
    
          Range:   0 to 0x0B
    
          Default: If this parameter is not entered, the maximum write retry level for the
                   specified error recovery mode will be changed.
    
    4 - Retry step to execute.
    
        If entered, this parameter specifies the retry step.  If Parameter 2 Bits 14
        (Enable selected error recovery step) and 15 (Skip initial read/write access
        of request) are set, the next read/write access will be performed using the
        retry tweaks associated with the specified retry step.
    
          Type:    Unsigned 8-bit value
    
          Range:   0 to 0xFF
    
          Default: If this parameter is not entered, the retry step for the specified
                   error recovery mode will not be changed.
    
    5 - On-the-fly Correction ECC T-Level.
    
        If entered, this parameter specifies the ECC T-Level to be used for on-the-fly
        correction.  The specified value will only be used by the error recovery algorithm,
        when Parameter 2 bit 16 is set.
    
          Type:    Unsigned 8-bit value
    
          Range:   0 to 0xFF
    
          Default: If this parameter is not entered, the on-the-fly correction ECC T-Level
                   for the specified error recovery mode will not be changed.
    
    6 - User media partition maximum retry count allowed.
    
        If entered, this parameter specifies the maximum retry count for user partition
        accesses.  The specified value will only be used by the error recovery algorithm,
        when Parameter 2 bit 20 is set.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: If this parameter is not entered, the maximum user partition retry count
                   for the specified error recovery mode will not be changed.
    
    7 - Error Recovery Options.
    
        If entered, this parameter selects the following error recovery options.
<a name="READ_WRITE_ERROR_RECOVERY_MODE_OPTIONS"></a>
        
        Bit 0: Enable maximum OTF ECC correction.
        
               If set, maximum on-the-fly ECC correction will be applied.
        
        Bit 1: Apply only minimum ECC correction.
        
               If set, only minimum on-the-fly ECC correction will be applied.
        
        Bit 2: Enable transfer of uncorrectable data block.
        
               If set, uncorrectable sectors will be transfered from the Correction
               Buffer to the Read Buffer.
        
        Bit 3: Enable restricted servo flaws coast - read.
        
               If set, restrict servo flaw coasting during a read only if one of the
               following conditions applies:
        
                 1) The failed block is not associated with a known grown servo flaw
                 2) New servo flaws are detected on the target track
                 3) Forced servo coast tweaks
        
        Bit 4: Enable restricted servo flaws coast - write.
        
               If set, restrict servo flaw coasting during a write only if one of the
               following conditions applies:
        
                 1) The failed block is not associated with a known grown servo flaw
                 2) New servo flaws are detected on the target track
                 3) Forced servo coast tweaks
        
        Bit 5: Enable early error recovery exit.
        
               If set, error recovery will terminate when the retry step is equal
               to the early exit retry step.
        
        Bit 6: Disable normal retry tweak steps.
        
               If set, all retry tweak steps will be disabled for normal error recovery
               modes.
        
        Bit 7: Disable full-hidden retry tweak steps.
        
               If set, the hidden retry steps will be disabled for the full error
               recovery modes.  The first 9 steps of the full error recovery modes
               are defined as hidden retries.
        
        Bit 8: Disable full retry tweak steps.
        
               If set, all retry steps will be disabled for the full error recovery
               modes.
        
        Bit 9: Disable undo of retry tweaks.
        
               If set, the retry tweaks will not be undone after the retry completes.
        
        Bit 10: Disable on-the-fly ECC correction - initial access.
        
                If set, on-the-fly ECC correction will be disabled for the initial
                attempt to access a sector.
        
        Bit 11: Disable on-the-fly ECC correction - normal retry tweak steps.
        
                If set, on-the-fly ECC correction will be disabled for the normal
                error recovery modes for all retry steps.
        
        Bit 12: Disable on-the-fly ECC correction - full-hidden retry tweak steps.
        
                If set, on-the-fly ECC correction will be disabled for the full
                error recovery modes for all hidden retry steps.  The first 9
                steps of the full error recovery modes are defined as hidden retries.
        
        Bit 13: Disable on-the-fly ECC correction - full retry tweak steps.
        
                If set, on-the-fly ECC correction will be disabled for the full
                error recovery modes for all retry steps following the hidden
                retries.  The first 9 retry steps of the full error recovery modes
                are defined as hidden retries.
        
        Bit 14: Enable selected ER retry step.
        
                If this bit is set and Mode Options Bit 15 is also set, a specified
                error recovery step will be used for the initial sector access.
        
        Bit 15: Skip initial read/write access of request.
        
                Typically, the initial access of a sector is performed without error
                recovery.  If this bit is set, the initial sector access will be
                performed using error recovery.  If Mode Options Bit 14 is also set,
                a specified error recovery step will be used for the initial sector
                access.  If Mode Options Bit 14 is cleared, the first error recovery
                step will be used for the initial sector access.
        
        Bit 16: Enable ECC selection setting - normal retries only.
        
                If set, a specified ECC T-Level will be used for on-the-fly correction
                only during NORMAL retries.  (This bit is a "don't care" if Bit 23 is
                set.)
        
        Bit 17: Disable retry on track integrity error.
        
                If set, retries will be disabled on track integrity errors.
        
        Bit 18: Allow one retry.
        
                If set, only a single, normal retry will be enabled.  (This feature
                is not typically enabled in OEM code.)
        
        Bit 19: Disable PFast.
        
                If set, P-Fast will be disabled during preamp fast tweaks.
        
        Bit 20: Enable use of selected maximum read retry count.
        
                If set, only a specified number of read retries will be allowed when
                read retries are required.
        
        Bit 21: Enable use of selected maximum write retry count.
        
                If set, only a specified number of write retries will be allowed when
                write retries are required.
        
        Bit 22: Enable selected maximum retry counts in non-User media partition.
        
                If set, the maximum read and write retry counts that have been enabled
                by Bits 20 and 21 will be applied to retries in non-user partitions.
        
        Bit 23: Enable ECC selection setting.
        
                If set, a specified ECC T-Level will be used for on-the-fly correction
                for all retry modes.  Setting this bit causes Bit 16 to be considered
                a "don't care."
        
        Bit 24: Disable the extended retries applied to Write Unsafe error.
        
                If set, the extended retries applied to Write Unsafe errors will be
                disabled.
        
        Bit 25: Enable reporting of recovered servo seek error to host.
        
                If set, recovered servo seek errors will be reported to the host.
        
        Bit 26: Enable Read/Write to complete transfers in RAW mode.
        
                If set and the Read-After-Write feature is enabled for the product,
                the Read/Write firmware is allowed to request that a transfer be
                completed in RAW mode.
        
        Bit 24: Enable Reduced Erasure correction.
        
                If set and the Reduced Erasure Correction feature is enabled for
                the product, the level of erasure correction applied during retries
                will be reduced.
        
        Bit 27: Enable abort during error recovery.
        
                If set, abort request will be honored during error recovery.
                Note that this bit only applies for single-block error
                recovery.  For non single-block error recovery, abort of
                error recovery is already allowed.
        
        Bits 28-31: Unused.
        
        
        To Disable All Retries:
           Clear bit 18
           Set bits 6, 7, and 8
        
        To Disable OTF Correction:
           Set bits 10, 11, 12, and 13
        
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFF
    
          Default: If this parameter is not entered, the current error recovery options
                   will be used.
    

  <b><i><u>Output Data:</u></i></b>
<a name="SET_RETRIES_OUTPUT_DATA"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
        If no error occurred, the current Error Recovery configuration will be displayed
        as follows.
    
           "Error Recovery Info:
    
           " P0: Config 0 (Normal)"                  or
           " P0: Config 1 (Format User Partition)"   or
           " P0: Config 2 (Format System Partition)" or
           " P0: Config 3 (Full)"                    or
           " P0: Config 4 (Customer)"
    
           " P1: Mode 0 (Default Normal)"            or
           " P1: Mode 1 (Default Full)"              or
           " P1: Mode 2 (Max Normal)"                or
           " P1: Mode 3 (Max Full)"                  or
           " P1: Mode 4 (Min Normal)"                or
           " P1: Mode 5 (Min Full)"                  or
           " P1: Mode 6 (Customer)"
    
           " P2: Max Read Retry Level = cc"
           " P3: Max Write Retry Level = dd"
    
           " P7: Options = eeeeee"
    
           "     B26: (1) Enable R/W allowd to use RAW"                         or
           "     B26: (0) Disable R/W allowd to use RAW"
    
           "     B25: (1) Enable Recovered Servo Sk Err Reporting"              or
           "     B25: (0) Disable Recovered Servo Sk Err Reporting"
    
           "     B24: (1) Disable Extended WUS Err Retries"                     or
           "     B24: (0) Enable Extended WUS Err Retries"
    
           "     B22: (1) Enable Max Retries In Non-User Partition"             or
           "     B22: (0) Disable Max Retries In Non-User Partition"
    
           "     B21: (1) Enable Max Write Retries (P6: %ff)"                   or
           "     B21: (0) Disable Max Write Retries (P6: %ff)"
    
           "     B20: (1) Enable Max Read Retries (P6: %ff)"                    or
           "     B20: (0) Disable Max Read Retries (P6: %ff)"
    
           "     B19: (1) Disable P-Fast"                                       or
           "     B19: (0) Enable P-Fast"
    
           "     B18: (1) Enable Single Retry"                                  or
           "     B18: (0) Disable Single Retry"
    
           "     B17: (1) Disable Trk Integrity Err Retry"                      or
           "     B17: (0) Enable Trk Integrity Err Retry"
    
           "     B16: (1) Enable OTF ECC T-Level (P5: gg)"                      or
           "     B16: (0) Disable OTF ECC T-Level (P5: gg)"
    
           "     B15: (1) Disable Initial RW Access"                            or
           "     B15: (0) Enable Initial RW Access"
    
           "     B14: (1) Enable Selected Err Recovery Step (P4: hh)"           or
           "     B14: (0) Disable Selected Err Recovery Step (P4: hh)"
    
           "     B13: (1) Disable OTF on Full Retry Steps"                      or
           "     B13: (0) Enable OTF on Full Retry Steps"
    
           "     B12: (1) Disable OTF on Full-Hidden Retry Steps"               or
           "     B12: (0) Enable OTF on Full-Hidden Retry Steps"
    
           "     B11: (1) Disable OTF on Normal Retry Steps"                    or
           "     B11: (0) Enable OTF on Normal Retry Steps"
    
           "     B10: (1) Disable OTF on Initial Access"                        or
           "     B10: (0) Enable OTF on Initial Access"
    
           "     B09: (1) Disable undo of Retry Tweaks"                         or
           "     B09: (0) Enable undo of Retry Tweaks"
    
           "     B08: (1) Disable Full Retries"                                 or
           "     B08: (0) Enable Full Retries"
    
           "     B07: (1) Disable Full-Hidden Retries"                          or
           "     B07: (0) Enable Full-Hidden Retries"
    
           "     B06: (1) Disable Normal Retries"                               or
           "     B06: (0) Enable Normal Retries"
    
           "     B05: (1) Enable Early Err Recovery Exit"                       or
           "     B05: (0) Disable Early Err Recovery Exit"
    
           "     B04: (1) Enable Restricted Servo Flaw Coasting during Write"   or
           "     B04: (0) Disable Restricted Servo Flaw Coasting during Write"
    
           "     B03: (1) Enable Restricted Servo Flaw Coasting during Read"    or
           "     B03: (0) Disable Restricted Servo Flaw Coasting during Read"
    
           "     B02: (1) Enable xfer of Uncorrectable Sectors"                 or
           "     B02: (0) Disable xfer of Uncorrectable Sectors"
    
           "     B01: (1) Enable Min OTF ECC Correction"                        or
           "     B01: (0) Disable Min OTF ECC Correction"
    
           "     B00: (1) Enable Max OTF ECC Correction"                        or
           "     B00: (0) Disable Max OTF ECC Correction"
    
           where
    
              cc     is the maximum Read Retry Level for the current Error Recovery Mode
    
              dd     is the maximum Write Retry Level for the current Error Recovery Mode
    
              eeeeee are the Error Recovery Options that are selected for the current Error
                     Recovery Mode
    
              ff     is the Maximum User Partion Retry Count for the current Error Recovery Mode
    
              gg     is the ECC T-Level to be used for On-The-Fly Correction for the current Error
                     Recovery Mode
    
              hh     is the Selected Error Retry Step for the current Error Recovery Mode
    

  <b><i><u>Revision History:</u></i></b>
<a name="SET_RETRIES_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0002.0000   Added support for "options" changes (only if DERP is disabled).
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="SET_SEEK_SPEED_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Set Seek Speed"></a><hr align=left width="75%"><b> Set Seek Speed (Level 4 'u')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command sets the JIT seek speed to be used for future diagnostic seek, read and
    write operations.

  <b><i><u>Quick Help:</u></i></b>
<a name="SET_SEEK_SPEED_QUICK_HELP"></a>
    "SetSkSpeed, u[Opts],[SkSpeed]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="SET_SEEK_SPEED_PARM"></a>
    0 - Options.
    
        This parameter specifies options for modifying the Diagnostic Seek Speed.
    
          0 = Display current Diagnostic Seek Speed status
             
                Selecting this option will display the current Diagnostic Seek Speed
                status.
    
          1 = Enable Diagnostic Seek Speed specified by Parameter 1
    
                Selecting this option will enable the Seek Speed specified by Parameter 1
                for future diagnostic seek, read and write operations.
    
          2 = Disable Diagnostic Seek Speed
    
                Selecting this option will disable the Diagnostic Seek Speed.  This
                will allow the Read/Write subsystem to pick the optimum Seek Speed.
    
          Type:    Unsigned 8-bit value
    
          Range:   0 to 2
    
          Default: 0 (Display current Diagnostic Seek Speed status)
    1 - Seek Speed.
    
        If Parameter o is equal to 1, this parameter specifies the JIT speed to be
        used for future diagnostic seek, read and write operations.  The JIT seek
        speed decreases as the parameter value increases, therefore a value of 0
        selects the fastest JIT seek speed.  If a value is entered that is greater
        than the maximum value supported, the slowest supported JIT seek speed will
        be selected.
    
          Type:    Unsigned 8-bit value
    
          Range:   0 to FFh
    
          Default: 0 (Fastest JIT Seek Speed )

  <b><i><u>Output Data:</u></i></b>
<a name="SEEK_SPEED_DATA"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
        If no error occurred, the following information will be displayed.
    
           "Diag Seek Speed c enabled"   or
           "Diag Seek Speed disabled"
    
           where
    
              c is the Diagnostic Seek Speed that is currently selected.
    

  <b><i><u>Revision History:</u></i></b>
<a name="SET_SEEK_SPEED_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="SET_TEST_SPACE_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Set Test Space"></a><hr align=left width="75%"><b> Set Test Space (All Levels 'A')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    The Set Test Space command configures the diagnostic Test Space based on the parameters
    entered.

  <b><i><u>Quick Help:</u></i></b>
<a name="SET_TEST_SPACE_QUICK_HELP"></a>
    "SetTestSpace, A[OptsOrParmSelect],[ParmValue],[AddrType],[HdForCylLimit]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="SET_TEST_SPACE_PARM"></a>
    0 - Test Space Parameter select / Test Space Options low.
    
        If Parameter 0 bit 3 is set, Parameter 0 bits 2-0 specify the Test Space
        Parameter to be modified and Parameter 1 contains the new parameter value.
        If Parameter 0 bit 3 is cleared, Parameter 0 bits 7-4 and 2-0 select the
        following Test Space Options.  If Parameter 0 is not entered, the Test Space
        will not be modified and the current Test Space configuration will be
        displayed.
    
            Bit F-B: not used
    
            Bit A: Sequential 80% and Random 20%
    
                   If set, the cylinder and head address will be updated sequentially
                   80% of the time and randomly 20% of the time.
    
            Bit 9: Random Transfer Length
    
                   If set, a random transfer length will be used for read/write
                   operations.
    
            Bit 8: Random Starting Sector
    
                   If set, a random starting sector will be used for read/write
                   operations.  If cleared, read/write operations will start at
                   sector 0.
    
            Bit 7: Random Data
    
                   If set, random data will be used for disk write operations.  If
                   cleared, the existing buffer data will be used for write operations.
    
            Bit 6: Sequential Out
    
                   If set, the cylinder and head address will be updated sequentially
                   from the Inner Diameter to the Outer Diameter.  If cleared, the
                   cylinder and head address will be updated sequentially from the
                   Outer Diameter to the Inner Diameter.
    
            Bit 5: Odd Cylinders
    
                   If set, only odd numbered cylinders will be accessed.
    
            Bit 4: Even Cylinders
    
                   If set, only even numbered cylinders will be accessed.
    
            Bit 3: Update Test Space Parameter
    
                   If set, bits 7-4 will not be used and bits 2-0 will select the
                   following Test Space Parameters to be modified:
    
                     0 = Set Minimum Cylinder to Parameter 1 value.
    
                     1 = Set Maximum Cylinder to Parameter 1 value.
    
                     2 = Set Maximum Head to Parameter 1 value.
    
                     3 = Set Minimum LBA to Parameter 1 value.
    
                     4 = Set Maximum LBA to Parameter 1 value.
    
                     5 = Select the default Test Space.
    
                     6 = Set Minimum Head to Parameter 1 value.
    
                     7 = Set Target Buffer Sector Offset to Parameter 1 value.
    
            Bit 2: Random Cylinder and / or Head
    
                   If Bit 1 (All Cylinders) is set and this bit is set, all cylinders
                   (Minimum Cylinder to Maximum Cylinder) will be accessed in a
                   pseudo-random fashion.  If Bit 1 (All Cylinders) is set and this
                   bit is cleared, all cylinders (Minimum Cylinder to Maximum Cylinder)
                   will be accessed in a sequentially fashion.  If Bit 1 (All Cylinders)
                   is cleared and this bit is set or cleared, only the current cylinder
                   will be accessed.
    
                   If Bit 0 (All Heads) is set and this bit is set, all heads (Minimum
                   Head to Maximum Head) will be accessed in a pseudo-random fashion.
                   If Bit 0 (All Heads) is set and this bit is cleared, all heads (Minimum
                   Head to Maximum Head) will be accessed in a sequentially fashion.  If
                   Bit 0 (All Heads) is cleared and this bit is set or cleared, only the
                   current head will be accessed.
    
            Bit 1: All Cylinders
    
                   If set, all cylinders (Minimum Cylinder to Maximum Cylinder) will be
                   accessed.  If cleared, only the current cylinder will be accessed.
    
                   If this bit is set, Bit 2 will specify if the cylinder address is to be
                   updated randomly or sequentially.
    
            Bit 0: All Heads
    
                   If set, all heads (Minimum Head to Maximum Head) will be accessed.
                   If cleared, only the current head will be accessed.
    
                   If this bit is set, Bit 2 will specify if the head address is to be
                   updated randomly or sequentially.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: None
    
    1 - Test Space Parameter value.
    
        If Parameter 0 bit 3 is set, Parameter 0 bits 2-0 specify the Test Space
        Parameter to be modified and Parameter 1 contains the new parameter value.
        If Parameter 0 bit 3 is cleared, Parameter 1 is not used.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xffffffff
    
          Default: None
    
    2 - Test Space Address Type.
    
        When specifying a new Test Space minimum or maximum address, this parameter
        specifies the type of address as follows.
    
             0 = User Area
             1 = System Area
             2 = Physical
    
        For example:
    
          If Parameter 2 is equal to 0 (User Area) and a new maximum cylinder address
          is being specified (Parameter 0 equal to 9), Parameter 1 will specify the
          new maximum logical cylinder address for commands that access the User Area
          in LLL CHS mode.
    
          If Parameter 2 is equal to 1 (System Area) and a new maximum cylinder address
          is being specified (Parameter 0 equal to 9), Parameter 1 will specify the
          new maximum logical cylinder address for commands that access the System Area
          in LLL CHS mode.
    
          If Parameter 2 is equal to 2 (Physical) and a new maximum cylinder address is
          being specified (Parameter 0 equal to 9), Parameter 1 will specify the maximum
          physical cylinder address for commands that use PLP CHS or PLP CHW address
          modes.
    
          Type:    Unsigned 8-bit value
    
          Range:   0 to 2
    
          Default: 0 (User Area)
    3 - Head Address of Minimum or Maximum Cylinder.
    
        When specifying a new Test Space minimum or maximum cylinder address (Parameter 0
        equal to 8 or 9), this parameter specified the head address for which the minimum
        or maximum cylinder address is to be set.  This parameter is not used if the
        minimum or maximum cylinder address is not being set.
    
          Type:    Unsigned 8-bit value
    
          Range:   0 to maximum head address
    
          Default: 0

  <b><i><u>Output Data:</u></i></b>
<a name="TEST_SPACE_CONFIG"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
        If no error occurred, the Test Space Limits for the currently selected Address Modes
        will be displayed as follows:
    
           One of the following strings will be displayed to indicate the diagnostic address
           mode that is currently selected.
    
              "User LBA"            or
              "User LLL CHS"        or
              "User LLP CHW"        or
              "System LBA"          or
              "System LLL CHS"      or
              "System LLP CHW"      or
              "PLP CHS"             or
              "PLP CHW"
    
           This may be followed by one or more of the following strings indicating which Test
           Space options are selected.
    
              "80% Rnd 20% Seq"    (Update the Cylinder and Head Address randomly 80% of
                                    the time and sequentially 20% of the time)
    
              "Rnd Cyls"           (Update the Cylinder Address randomly)
    
              "Rnd Hds"            (Update the Head Address randomly)
    
              "Seq Out"            (Update the Cylinder and Head Address sequentially outward
                                    from ID to OD)
    
              "Seq In"             (Update the Cylinder and Head Address sequentially inward
                                    from OD to ID)
    
              "Even Cyls"          (Only test even numbered cylinders)
    
              "Odd Cyls"           (Only test odd numbered cylinders)
    
              "Rnd Sec"            (Update the Sector address or LBA randomly)
    
              "Rnd Wedge"          (Update the Wedge address randomly)
    
              "Rnd Lngth"          (Use a random Transfer Length for read and write operations)
    
              "Rnd Data"           (Use random data for write operations)
    
           This will be followed by strings indicating the range of addresses being tested.
    
           For the User LBA and System LBA address modes, the followed string indicates the
           range of LBAs being tested.
    
              "LBAs cccccccc - dddddddd"
    
           where
    
              cccccccc is the minimum LBA to be tested
    
              dddddddd is the maximum LBA to be tested
    
           For all other address modes, the following strings indicate the range of heads and
           cylinders being tested.
    
              "Hd e"                        (when testing a single head)
    
              "Hds f - g"                   (when testing a range of heads)
    
              "Cyl hhhhhh"                  (when testing a single cylinder)
    
              "Cyls iiiiii - jjjjjj"        (when testing a range of cylinders)
    
           where
    
              e is the address of the single head being tested
    
              f is the address of the first head being tested
    
              g is the address of the last head being tested
    
              hhhhhh is the address of the single cylinder being tested
    
              iiiiii is the address of the first cylinder being tested
    
              jjjjjj is the address of the last cylinder being tested
    
    
           The Test Space Limits for all Address Modes will be displayed as follows:
    
              "All Addr Modes"
              "User LBA Mode
              "  LBAs kkkkkkkk - mmmmmmmm"
              "System LBA Mode
              "  LBAs nnnnnnnn - pppppppp"
              "User LLL CHS and User LLP CHW Mode
              "  Hd q Cyls rrrrrr - ssssss"             (repeated for each head in the Test Space)
              "System LLL CHS and System LLP CHW Mode
              "  Hd t Cyls uuuuuu - vvvvvv"             (repeated for each head in the Test Space)
              "PLP CHS and User PLP CHW Mode
              "  Hd w Cyls xxxxxx - yyyyyy"             (repeated for each head in the Test Space)
    
           where
    
              kkkkkkkk is the minimum User Area LBA that will be accessed by commands that use
                       User LBA Address Mode
    
              mmmmmmmm is the maximum User Area LBA that will be accessed by commands that use
                       User LBA Address Mode
    
              nnnnnnnn is the minimum System Area LBA that will be accessed by commands that
                       use System LBA Address Mode
    
              pppppppp is the maximum System Area LBA that will be accessed by commands that
                       use System LBA Address Mode
    
              q        is a Logical Head Address that can be accessed by commands that use
                       User LLL CHS or User LLP CHW Address Modes
    
              rrrrrr   is the minimum User Area Logical Cylinder Address on the specified head
                       that will be accessed by commands that use User LLL CHS or User LLP CHW
                       Address Modes
    
              ssssss   is the maximum User Area Logical Cylinder Address on the specified head
                       that will be accessed by commands that use User LLL CHS or User LLP CHW
                       Address Modes
    
              t        is a Logical Head Address that will be accessed by commands that use
                       System LLL CHS or System LLP CHW Address Modes
    
              uuuuuu   is the minimum System Area Logical Cylinder Address that will be accessed
                       by commands that use System LLL CHS or System LLP CHW Address Modes
    
              vvvvvv   is the maximum System Area Logical Cylinder Address that will be accessed
                       by commands that use System LLL CHS or System LLP CHW Address Modes
    
              w        is a Logical Head Address that will be accessed by commands that use PLP
                       CHS or PLP CHW Address Modes
    
              xxxxxx   is the minimum Physical Cylinder Address on the specified head that will
                       be accessed by commands that use PLP CHS or PLP CHW Address Modes
    
              yyyyyy   is the maximum Physical Cylinder Address on the specified head that will
                       be accessed by commands that use PLP CHS or PLP CHW Address Modes
    
           Following the display above, the Target Buffer Sector Offset will be displayed.
    
              "Buffer Sector Offset bbbbbbbb"
    
           where
    
              bbbbbbbb is the Target Buffer Sector Offset at which from the beginning of
                       diagnostic Read/Write buffer the next Read/Write diagnostic command will
                       transfer data to or from.
     

  <b><i><u>Examples:</u></i></b>
    The following command displays without modifying the Test Space that is currently
    selected:

       F3 2>A

    The following commands specify how the target address is to be updated:

       F3 2>A0           (single cylinder, single head)
       F3 2>A1           (single cylinder, sequential heads)
       F3 2>A2           (sequential inward cylinders, single head)
       F3 2>A3           (sequential inward cylinders, sequential heads)
       F3 2>A5           (single cylinder, random heads)
       F3 2>A6           (random cylinders, single head)
       F3 2>A7           (random cylinders, random heads)

       F3 2>A12          (sequential inward even cylinders, single head)
       F3 2>A13          (sequential inward even cylinders, sequential heads)
       F3 2>A22          (sequential inward odd cylinders, single head)
       F3 2>A23          (sequential inward odd cylinders, sequential heads)

       F3 2>A16          (random even cylinders, single head)
       F3 2>A17          (random even cylinders, random heads)
       F3 2>A26          (random odd cylinders, single head)
       F3 2>A27          (random odd cylinders, random heads)

       F3 2>A42          (sequential outward cylinders, single head)
       F3 2>A43          (sequential outward cylinders, sequential heads)
       F3 2>A52          (sequential outward even cylinders, single head)
       F3 2>A53          (sequential outward even cylinders, sequential heads)
       F3 2>A62          (sequential outward odd cylinders, single head)
       F3 2>A63          (sequential outward odd cylinders, sequential heads)

    The following commands set the Test Space limits:

       F3 2>A8,123,,0    (sets the minimum user logical cylinder for head 0 to 123)
       F3 2>A9,234,,0    (sets the maximum user logical cylinder for head 0 to 234)
       F3 2>A8,567,,1    (sets the minimum user logical cylinder for head 1 to 567)
       F3 2>A9,890,,1    (sets the maximum user logical cylinder for head 1 to 890)
       F3 2>A8,11,1,0    (sets the minimum system logical cylinder for head 0 to 11)
       F3 2>A9,23,1,0    (sets the maximum system logical cylinder for head 0 to 23)
       F3 2>A8,567,2,0   (sets the minimum physical cylinder for head 0 to 567)
       F3 2>A9,876,2,0   (sets the maximum physical cylinder for head 0 to 876)
       F3 2>AA,3         (sets the maximum head to 3)
       F3 2>AB,4567      (sets the minimum user LBA to 4567)
       F3 2>AC,9876      (sets the maximum user LBA to 9876)
       F3 2>AB,223,1     (sets the minimum system LBA to 223)
       F3 2>AC,7845,1    (sets the maximum system LBA to 7845)
       F3 2>AE,1         (sets the minimum head to 1)

    The following command resets the Test Space to its default state:

       F3 2>AD

    The following command sets the Target Buffer Sector Offset to 0

       F3 2>AF,0
 
  <b><i><u>Revision History:</u></i></b>
<a name="SET_TEST_SPACE_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0002.0000   Modified for VBAR to support minimum and maximum cylinder address values
                for each head.
    0002.0001   Added new capability that enables users to set the Target Buffer Sector Offset
                to any value they want.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="SET_TRACK_FORMAT_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Set Track Format"></a><hr align=left width="75%"><b> Set Track Format (Level 7 'K')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command configures the track layout based on the specified track format type.

  <b><i><u>Quick Help:</u></i></b>
<a name="SET_TRACK_FORMAT_QUICK_HELP"></a>
    "SetTrackFormat, K[UserAreaTrkFormatType],[SysAreaTrkFormatType]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="SET_TRACK_FORMAT_PARM"></a>
    0 - User Partition Track Format Type.
    
        This parameter specifies the track format type to be applied to user
        media partition.
    
             0 = Normal Track Format - multiple sectors per wedge w/ splits
             1 = No Splits Format - multiple sectors per wedge w/o splits
             2 = Single Sector Per Wedge Format
    
          Type:    Unsigned 8-bit value
    
          Range:   0, 1, or 2
    
          Default: 0
    
    1 - System Partition Track Format Type.
    
        This parameter specifies the track format type to be applied to system
        media partition.
    
             0 = Normal Track Format - multiple sectors per wedge w/ splits
             1 = No Splits Format - multiple sectors per wedge w/o splits
             2 = Single Sector Per Wedge Format
    
          Type:    Unsigned 8-bit value
    
          Range:   0, 1, or 2
    
          Default: 0
    

  <b><i><u>Output Data:</u></i></b>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    

  <b><i><u>Revision History:</u></i></b>
<a name="SET_TRACK_FORMAT_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="SET_TRACKING_OFFSET_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Set Tracking Offset"></a><hr align=left width="75%"><b> Set Tracking Offset (Levels 2, 4 'K')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command applies an offset to the servo system and then performs a seek to the
    specified offset for the current track and head.  The type of seek (Read, Write or
    Write Header) will be the same as the last seek performed.

  <b><i><u>Quick Help:</u></i></b>
<a name="SET_TRACKING_OFFSET_QUICK_HELP"></a>
    "SetTrackingOffset, K[OffsetValue],[PersOrTempOpt],[UnitsOpt],[ChanReload]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="SET_TRACKING_OFFSET_PARM"></a>
    0 - Track Follow Offset value.
    
        This parameter is a signed 16-bit number representing the amount of tracking
        offset to apply in the servo system.  Parameter 2 will indicate whether the offset
        is in units of 1/256th, a.k.a. Q8 format, or 0.1% of the servo or data track width.
        Parameter 2 will also indicate whether the offset is in servo tracks or in data tracks
    
          Type:    Signed 16-bit value
    
          Range:   0x8000 to 0x7FFF
    
          Default: 0
    
    1 - Temporary or Persistent Track Follow Offset option.
      
        This parameter specifies if the Track Follow Offset value is persistent or
        temporary.  If this parameter is equal to 0, the offset value is temporary and
        will only remain in effect until the next seek is performed.  If this parameter
        is equal to 1, the offset will be persistent and will remain in effect for all
        subsequent seeks until reset.
    
          Type:    Unsigned 8-bit value
    
          Range:   0 or 1
    
          Default: 0 (Offset is temporary)
    
    2 - Track Follow Offset Units option.
      
        This parameter specifies the units of the Track Follow Offset value.
    
            Bits 7-2: not used
    
            Bit 1: Servo or Data Track Width
    
                   If this bit is equal to 0, the Track Follow Offset value specified in the
                   Parameter 0 will be in data track width.
                   If this bit is equal to 1, the Track Follow Offset value specified in the
                   Parameter 0 will be in servo track width.
    
            Bit 0: Unit Selection.
    
                   If this bit is equal to 0, the specified offset will be in units of
                   1/256th of the servo or data track width, a.k.a. Q8 format.
                   If this bit is equal to 1, the specified offset will be in units of
                   0.1% of the servo or data track width.
    
          Type:    Unsigned 8-bit value
    
          Range:   0 to 0xFF
    
          Default: 0 (Offset is in units of 1/256th of the data track width)
    
    3 - Reload Channel Parameters After Setting Track Offset option.
      
        This parameter enables or disables reloading the channel parameters after the
        track offset is set.  If this parameter is equal to 0, the channel parameters
        will not be reloaded into the channel registers.  If this parameter is equal
        to 1, the channel parameters will be reloaded into the channel registers.
    
          Type:    Unsigned 8-bit value
    
          Range:   0 or 1
    
          Default: 0 (disable reloading the channel parameters in the channel registers)
    

  <b><i><u>Output Data:</u></i></b>
<a name="RW_SEEK_OP_STATUS"></a>
        If an error occurred, the following information will be displayed.
    
              "DiagError aaaaaaaa R/W Status c R/W Error dddddddd"
    
           and
    
              "Target User LBA eeeeeeee LLL CHS ffffff.g.hhhh PLP CHS iiiiii.j.kkkk"
    
           or
    
              "Target System LBA eeeeeeee LLL CHS ffffff.g.hhhh PLP CHS iiiiii.j.kkkk"
    
           where
    
              aaaaaaaa is the Diagnostic Error Code
    
              c is the status returned by the R/W subsystem
    
              dddddddd is the error code returned by the R/W subsystem
    
              eeeeeeee is a Disk Logical Block Address on the track to which the seek was
              performed
    
              ffffff is the Logical Cylinder Address of the track to which the seek was
              performed
    
              g is the Logical Head Address of the track to which the seek was performed
    
              hhhh is a Logical Sector Address on the track to which the seek was performed
    
              iiiiii is the Physical Cylinder Address of the track to which the seek was
              performed
    
              j is the Logical Head Address of the track to which the seek was performed
    
              kkkk is a Physical Sector Address on the track to which the seek was performed
    
        If the Verbose Formatted ASCII Data Output Mode is selected, the Verbose Mode option
        bits will enable the following data to be output when set.
    
           Bit 0:      Enables the R/W Status and R/W Error to be displayed
           Bit 1:      NA
           Bit 2:      Enables the Track Position and Track Follow Offset to be displayed
           Bit 3:      Enables the Target Address to be displayed
           Bit 4:      NA
           Bit 5:      NA
           Bit 6:      Enables the Elapsed Time to be displayed
           Bits 31-7:  NA
    
        If Bit 0 is set, the R/W Status and R/W Error will be displayed even if no error
        occurred.  The data displayed will be formatted as shown above.
    
        If Bit 2 is set, the Track Position and Track Follow Offset will be displayed as
        follows.
    
              "Read Position, Persistent Offset m.m% Total Offset n.n%"          or
              "Write Position, Persistent Offset m.m% Total Offset n.n%"         or
              "Write Header Position, Persistent Offset m.m% Total Offset n.n%"
    
           where
    
              m.m is the Persistent Track Follow Offset in units of percentage of track width
    
              n.n is the Total Track Follow Offset in units of percentage of track width
    
        If Bit 3 is set, the Target Address will be displayed even if no error occurred.
        The data displayed will be formatted as shown above.
    
        If Bit 6 is set, the Elapsed Time for the seek operation will be displayed.
<a name="ELAPSED_TIME"></a>
    
       "Elapsed Time a mins b secs"  or
       "Elapsed Time b.c secs"       or
       "Elapsed Time c.d msecs"
    
    where
    
       a is minutes
       b is seconds
       c is milliseconds
       d is microseconds
    
    

  <b><i><u>Examples:</u></i></b>
    Example #1:
       To persistently apply the servo tracking offset in the amount of 256/256th of data track width
       in positive direction

          F3 2>A0
          F3 2>S1000
          F3 2>K100,1

    Example #2:
       To persistently apply the servo tracking offset in the amount of 100% of data track width
       in negative direction

          F3 2>A0
          F3 2>S1000
          F3 2>KFC18,1,1

    Example #3:
       To persistently apply the servo tracking offset in the amount of 256/256th of servo track width
       in negative direction

          F3 2>A0
          F3 2>S1000
          F3 2>KFF00,1,2

    Example #4:
       To persistently apply the servo tracking offset in the amount of 100% of a servo track width
       in positive direction

          F3 2>A0
          F3 2>S1000
          F3 2>K3E8,1,3

  <b><i><u>Revision History:</u></i></b>
<a name="SET_TRACKING_OFFSET_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0001.0001   Added an option flag to allow the offset input in servo tracks.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="SLOW_WRITE_CHS_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Slow Write CHS"></a><hr align=left width="75%"><b> Slow Write CHS (Level E 'w')</b><hr align=left width="75%">
                   
  <b><i><u>Description:</u></i></b>
    This command writes data to the disk starting at the specified sector on the target
    track for the specified number of sectors.  The sectors are written consecutively
    with the specified number of sectors and then followed by the skip of the specified
    number of sectors to cool down the head. The sectors are written with the data
    contained in the Diagnostic Write Buffer.

  <b><i><u>Quick Help:</u></i></b>
<a name="SLOW_WRITE_CHS_QUICK_HELP"></a>
    "SlowWrChs, w[Sec],[NumSecs],[ConSec],[Skip],[UnitOfSkip]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="SLOW_WRITE_CHS_PARM"></a>
    0 - Logical or Physical Sector Address.
    
        If any value is entered for Parameter 5, this parameter contains the physical
        sector address of the first sector to write, else this parameter contains the
        User Area logical sector address of the first sector to write.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to maximum logical or physical sector address on the target track
    
          Default: 0
    
    1 - Transfer Length.
    
        This parameter specifies the number of total sectors to write.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: If the Sector Address was entered and the Transfer Length was not
                   entered, then only the specified sector will be written.
    
                   If both the Sector Address and Transfer Length are not entered, then
                   the Transfer Length will be set based on the Test Space that is
                   selected.  If the Random Transfer Length option is selected, a random
                   value will be used that is less than or equal to the number of sectors
                   remaining on the track.  If the Random Transfer Length option is not
                   selected, the number of sectors remaining on the track will be written.
    
                   If a Transfer Length is entered, it will be limited to the number of
                   sectors remaining on the track.
    
    2 - Consecutive Sectors to be Written.
    
        This parameter specifies the number of consecutive sectors to be written
        as a segment.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: 1
    
    3 - Skip.
    
        This parameter specifies the amount of skip after the specified consecutive
        sector are written.  Its unit is decided by Parameter 4.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: 1
    
    4 - Unit of Skip.
      
        This parameter specifies the unit of skip.  If Parameter 4 is equal to 0, the
        skip is specified in the wedges.  If its value is 1, the skip is specified in
        the sectors. Otherwise, the skip is specified in the time of micro seconds.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: 0 (skip in the wedge)
    
    5 - Physical Sector Address Flag.
      
        If any value is entered for this parameter, then Parameter 0 specifies a physical
        sector address, else Parameter 0 specifies a User Area logical sector address.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: None
    

  <b><i><u>Output Data:</u></i></b>
<a name="RW_OP_STATUS_OUTPUT_DATA"></a>
        If an error occurred, the following information will be displayed.
    
              "DiagError aaaaaaaa R/W Status c R/W Error dddddddd"
    
           and
    
              "Next User LBA eeeeeeee LLL CHS ffffff.g.hhhh PLP CHS iiiiii.j.kkkk"
              "Remaining Transfer Length llllllll"
    
           or
    
              "Next System LBA eeeeeeee LLL CHS ffffff.g.hhhh PLP CHS iiiiii.j.kkkk"
              "Remaining Transfer Length llllllll"
    
           where
    
              aaaaaaaa is the Diagnostic Error Code
    
              c is the status returned by the R/W subsystem
    
                    0 = R/W request completed successfully with error recovery
                    1 = R/W request completed successfully (no error recovery performed)
                    2 = R/W request failed
    
              dddddddd is the error code returned by the R/W subsystem
    
              eeeeeeee is the Disk Logical Block Address of the sector in error
    
              ffffff is the Logical Cylinder Address of the sector in error
    
              g is the Logical Head Address of the sector in error
    
              hhhh is the Logical Sector Address of the sector in error
    
              iiiiii is the Physical Cylinder Address of the sector in error
    
              j is the Logical Head Address of the sector in error
    
              kkkk is the Physical Sector Address of the sector in error
    
              llllllll is the number of sectors remaining to be read or written
    
        If the Verbose Formatted ASCII Data Output Mode is selected, the Verbose Mode option
        bits will enable the following data to be output when set.
    
           Bit 0:      Enables the R/W Status and R/W Error to be displayed
           Bit 1:      Enable the Next Address to be displayed
           Bit 2:      Enables the Track Position and Track Follow Offset to be displayed
           Bit 3:      Enables the Target Address to be displayed
           Bit 4:      Enables the Recovery Status to be displayed
           Bit 5:      Enables the Fault Status to be displayed
           Bit 6:      Enables the Elapsed Time to be displayed
           Bits 31-7:  NA
    
        If Bit 0 is set, the R/W Status and R/W Error will be displayed even if no error
        occurred.  The data displayed will be formatted as shown above.
    
        If Bit 1 is set, the Next Address will be displayed even if no error occurred.  The
        data displayed will be formatted as shown above.
    
        If Bit 2 is set, the Track Position and Track Follow Offset will be displayed as
        follows.
    
              "Read Position, Persistent Offset m.m% Total Offset n.n%"          or
              "Write Position, Persistent Offset m.m% Total Offset n.n%"         or
              "Write Header Position, Persistent Offset m.m% Total Offset n.n%"
    
           where
    
              m.m is the Persistent Track Follow Offset in units of percentage of track width
    
              n.n is the Total Track Follow Offset in units of percentage of track width
    
        If Bit 3 is set, the Target Address will be displayed as follows.
    
              "Target User LBA pppppppp LLL CHS qqqqqq.r.ssss PLP CHS tttttt.u.vvvv"
              "Starting Transfer Length wwwwwwww"
    
           or
    
              "Target System LBA pppppppp LLL CHS qqqqqq.r.ssss PLP CHS tttttt.u.vvvv"
              "Starting Transfer Length wwwwwwww"
    
           where
    
              pppppppp is the starting Disk Logical Block Address
    
              qqqqqq is the starting Logical Cylinder Address
    
              r is the starting Logical Head Address
    
              ssss is the starting Logical Sector Address
    
              tttttt is the starting Physical Cylinder Address
    
              u is the starting Logical Head Address
    
              vvvv is the starting Physical Sector Address
    
              wwwwwwww is the starting Transfer Length
    
        If Bit 4 is set, the Recovery Status will be displayed as follows.
    
              "Recovered User LBA AAAAAAAA LLL CHS BBBBBB.C.DDDD PLP CHS EEEEEE.F.GGGG"
              "Recovery Flags HHHH Count II"
    
           or
    
              "Recovered System LBA AAAAAAAA LLL CHS BBBBBB.C.DDDD PLP CHS EEEEEE.F.GGGG"
              "Recovery Flags HHHH Count II"
    
           where
    
              AAAAAAAA is the Disk Logical Block Address of the last recovered sector
    
              BBBBBB is the Logical Cylinder Address of the last recovered sector
    
              C is the Logical Head Address of the last recovered sector
    
              DDDD is the Logical Sector Address of the last recovered sector
    
              EEEEEE is the Physical Cylinder Address of the last recovered sector
    
              F is the Logical Head Address of the last recovered sector
    
              GGGG is the Physical Sector Address of the last recovered sector
    
              HHHH are the Recovery Flags reported by the Read/Write code
    
              II is the Recovery Count reported by the Read/Write code
    
        If Bit 5 is set, the Fault Status will be displayed as follows.
    
              "Drive Fault Status JJJJ Preamp Fault Status KKKK"
    
           where
    
              JJJJ is the Drive Fault Status reported by the Read/Write code
    
              KKKK is the Preamp Fault Status reported by the Read/Write code
    
        If Bit 6 is set, the Elapsed Time for the read/write operation will be displayed.
<a name="ELAPSED_TIME"></a>
    
       "Elapsed Time a mins b secs"  or
       "Elapsed Time b.c secs"       or
       "Elapsed Time c.d msecs"
    
    where
    
       a is minutes
       b is seconds
       c is milliseconds
       d is microseconds
    
    

  <b><i><u>Examples:</u></i></b>
    Example #1:
       To write a single logical sector
       (in this case logical sector 23 on logical cylinder 45 head 1)

          F3 2>A0
          F3 2>S45,1
          F3 E>w23

    Example #2:
       To write multiple logical sectors
       (in this case logical sectors 23 to 26 on logical cylinder 45 head 1)

          F3 2>A0
          F3 2>S45,1
          F3 E>w23,4

    Example #3:
       To write all of the logical sectors on a track
       (in this case all logical sectors on logical cylinder 45 head 1)

          F3 2>A0
          F3 2>S45,1
          F3 E>w

    Example #4:
       To write all of the logical sectors on multiple tracks
       (in this case all logical sectors on logical cylinders 45 to 49 head 0)

       Note: You must seek to the track before the first one to be written.

          F3 2>A3
          F3 2>S44,0
          F3 2>L,5
          F3 E>w

    Example #5:
       To write a single physical sector
       (in this case physical sector 32 on physical cylinder 54 head 0)

          F3 2>A0
          F3 2>s54,0,22
          F3 E>w32,,,,,1

    Example #6:
       To write multiple physical sectors
       (in this case physical sectors 32 to 35 on physical cylinder 54 head 0)

          F3 2>A0
          F3 2>s54,0,22
          F3 E>w32,4,,,,1

    Example #7:
       To write all of the physical sectors on a track
       (in this case all physical sectors on physical cylinder 54 head 0)

          F3 2>A0
          F3 2>s54,0,22
          F3 E>w,,,,,1

  <b><i><u>Revision History:</u></i></b>
<a name="SLOW_WRITE_CHS_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).
    0011.0001   Added physical sector address flag to write in PLP CHS address mode.

<a name="SMART_CONTROL_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="SMART Control"></a><hr align=left width="75%"><b> SMART Control (Level 1 'N')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    Performs several diagnostic SMART functions.

  <b><i><u>Quick Help:</u></i></b>
<a name="SMART_CONTROL_QUICK_HELP"></a>
    "SmartControl, N[SubCmd],[SubCmdParm0],[SubCmdParm1]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="SMART_CONTROL_PARM"></a>
    0 - Serial Port Command.
    
        This parameter defines which command will be used on the SMART Serial Port.  The
        following are the allowable commands (red indicates that the command is unsupported).
    
          <font color=red>0x00: TOGGLE_SMART - toggles SMART on/off.</font>
          0x01: INITIALIZE_SMART_DATA - initializes SMART statistics data (both in RAM and SMART
          sectors).  Also initializes Fast Flush and Media Cache on the disk.
          <font color=red>0x02: UPDATE_SMART_ATTRIBUTES - updates SMART's attributes.</font>
          <font color=red>0x03: SET_CLEAR_PREFAILURE_BIT - sets/clears specified pre-failure warranty bit.</font>
          <font color=red>0x04: INITIALIZE_SMART - is the same as INITIALIZE_SMART_DATA.</font>
          0x05: DUMP_SMART_ATTRIBUTES - retrieves SMART's attributes.
          0x06: DUMP_SMART_THRESHOLDS - retrieves SMART's thresholds.
          <font color=red>0x07: DUMP_SMART_GLIST - retrieves the G-List.</font>
          0x08: DUMP_CE_LOG - retrieves the critical event log.
          <font color=red>0x09: DUMP_PENDING_LIST - retrieves the pending list.</font>
          <font color=red>0x0B: START_SHORT_DST - start the short DST after next power up or ^T.</font>
          <font color=red>0x0C: START_LONG_DST - start the long DST after next power up or ^T.</font>
          <font color=red>0x10: DUMP_2_HR_LOG - retrieves the 2 hr log.</font>
          0x23: CLEAR_PERSISTENT_INFO - clears persistent information.
          0xFF: NO_COMMAND
    
          Type:    Unsigned 8-bit value
    
          Range:   0x00 to 0x23
    
          Default: None
    
    1 - Variable Parameter
    
        Multi-purpose parameter. Used in command 01 to initialize Fast Flush and Media cache.
        Used in command 03 as the number of the attribute to change.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: None
    
    2 - Boolean Bit Value.
    
        Used in command 03 to set/clear the boolean value for the bit.
    
          Type:    Boolean value
    
          Range:   0 to 0x1
    
          Default: None
    

  <b><i><u>Output Data:</u></i></b>
<a name="SMART_DATA"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
    
     N1 - initialize Smart data
     N5 - display attribute values
     N6 - display threshold values
    
     F3 1>N5
     Att
     Num  Flgs normlzd worst raw
      1   000F   64     64   00000000000000
      3   0003   64     64   00000000000000
      4   0032   64     64   00000000000001
      5   0033   64     64   00000000000000
      7   000F   64     FD   00000000000001
      9   0032   64     64   00000000000000
      A   0013   64     64   00000000000000
      C   0032   64     64   00000000000001
     B8   0032   64     64   00000000000000
     BB   0032   64     64   00000000000000
     BC   0032   64     FD   00000000000000
     BD   003A   64     64   00000000000000
     BE   0022   46     46   0000001E1E001E
     C2   0022   1E     28   00001E0000001E
     C3   001A   64     64   00000000000000
     C5   0012   64     64   00000000000000
     C6   0010   64     64   00000000000000
         - etc
    
     F3 1>N6
     Att  Thresh
       1      6
       3      0
       4     14
       5     24
       7     1E
       9      0
         - etc
    
<a name="CRITICAL_EVENT_LOG_DATA"></a>
    N8 - display critical event log
    F3 1>N8
                                                   DERP
      dec                                         error  DERP
     Hours -    LBA       R  Theta Z EC       Cmd type  retry temp  type
      2103 -    10000      D 8E6F  0 C4090081  35  FF     FF    0  recovered write
      2103 -    10002      D 8EB0  0 C4090081  35  FF     FF    0  recovered write
      2103 -    10004      D 8EF1  0 C3160080  25  FF     FF    0  data scrubbed
      2103 -    10006      D 8F32  0 C3160080  25  FF     FF    0  data scrubbed
      2103 -   100000     23 3D2B  1       80  25  FF     FF    0  marked as BBM
      2103 -   100000     23 3D2B  1 C3160080  35  FF     FF    0  write BBM data scrubbed
      2103 -    12000   FF57 7405  2 C4090081  35  FF     FF    0  wedge reallocated
      2103 -    12000   FF57 7405  2 C4090081  35  FF     FF    0  reallocated
      2103 -    13000   FF57 7445  2 C3160080  35  FF     FF   23  RAW rewrite
      2103 -    13000   FF57 7445  2 C3160080  35  FF     FF   23  RAW reallocated
      2103 - 217CAD77   517E  B2C  5       80  EC  FF     FF   23  BGMS marked as BBM
      2103 - 217CAD78   517E  B51  5       80  EC  FF     FF   23  BGMS marked as BBM
    
     Note that the first N entries in the log are preserved from when the
     drive entered service. The remaining entries form a circular buffer
     where new entries will overwrite old entries when the log
     fills up.  To find the value of N, see the approriate developer.
    
       What columns mean:
     LBA        LBA of log entry
     R          physical cylinder normalized to range 0 - max physical cylinder
                value shown in DECIMAL not hex
     Theta      physical sector number normalized to range 0 - FFFF
     Z          head number
     EC         error code of log entry
     Cmd        interface command prior to event
     error type DER error type
     retry      DER retry
     temp       temperature at time of event
     type       text description of log entry type
    
                For further information on critical event log
                types, please find the developer of the code
                that added the log entry.
    

  <b><i><u>Revision History:</u></i></b>
<a name="SMART_CONTROL_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0002.0000   Added display of raw data to the SMART data display.
    00011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).
    0011.0001   Added support for SMART Clear Persistent Information (23)

<a name="SPECIAL_BATCH_FILE_FUNCTION_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Special Batch File Function"></a><hr align=left width="75%"><b> Special Batch File Function (All Levels '*')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command performs the specified Batch File function.

  <b><i><u>Quick Help:</u></i></b>
<a name="SPECIAL_BATCH_FILE_FUNCTION_QUICK_HELP"></a>
    "SpecialBatchFileFunction, *[FuncId],[FuncParm0],[FuncParm1]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="SPECIAL_BATCH_FILE_FUNCTION_PARM"></a>
    0 - Batch File Function ID.
    
        This parameter selects one of the following special Batch File function to
        be performed.
    
             0 = No operation.
    
             1 = Pause the execution of the batch file until input is received from the
                 user via the Serial Port interface.
    
             2 = Delay the number of milliseconds specified by Parameter 1.
    
             3 = Branch batch file execution to the label specified by Parameter 1.
    
             4 = Increment the head address and branch batch file execution to the
                 label specified by Parameter 1, if the head address did not wrap.
    
             5 = Clear the display screen.
    
             6 = Stop batch file execution if an error occurred.
    
             7 = Set the batch file Loop Count specified by Parameter 2 to the value
                 specified by Parameter 1.
    
             8 = Decrement the batch file Loop Count specified by Parameter 2 and,
                 if the Loop Count is not equal to zero, branch batch file execution
                 to the label specified by Parameter 1.
    
             9 = Clear the expected batch file error information.
    
             A = Updates the expected batch file error information with the Diagnostic
                 Error Code specified by Parameter 1, the Minimum Count specified by
                 Parameter 2 and the Maximum Count specified by Parameter 3.
    
             B = Display the Active Error Log and compare its contents against the
                 expected batch file errors to determine if the batch file failed.
    
          Type:    Unsigned 8-bit value
    
          Range:   0 to B hex
    
          Default: 0
    
    1 - Special Batch File Function Parameter.
    
        This parameter specifies additional information required by the special Batch
        File function selected by Parameter 0.
    
        If Parameter 0 is equal to 0, 1, 5, 9 or B this parameter will not be used.
    
        If Parameter 0 is equal to 2, this parameter specifies the number of milliseconds
        to delay.
    
        If Parameter 0 is equal to 3, 4 or 8, this parameter specifies the number of the
        label to which batch file execution is to branch, when the specified condition is
        satisfied.
    
        If Parameter 0 is equal to 6 and this parameter is entered, it specifies the
        Diagnostic Error Code on which Batch File execution is to be terminated.
        If Parameter 0 is equal to 6 and this parameter is not entered, Batch File
        execution will be terminated on any error that occurs.
    
        If Parameter 0 is equal to 7, this parameter specifies the value to which the
        batch file Loop Count is to be set.
    
        If Parameter 0 is equal to A, this parameter specifies the expected Diagnostic
        Error Code associated with the error that is expected.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF,  if Millisecond Delay
                   0 to 0xFFFFFFFF,  if Loop Count Value
                   0 to 0xF,         if Label Number
                   0 to 0xFFFFFFFF,  if Diagnostic Error Code
    
          Default: None
    
    2 - Special Batch File Function Parameter.
    
        This parameter specifies additional information required by the special Batch
        File function selected by Parameter 0.
    
        If Parameter 0 is equal to 0, 1, 2, 3, 4, 5, 6, 9 or B this parameter will not
        be used.
    
        If Parameter 0 is equal to 7 or 8, this parameter specifies the number of the
        batch file loop count to be set or decremented.
    
        If Parameter 0 is equal to A, this parameter specifies the minimum number of
        times the error specified by Parameter 1 is expected to occur.  Setting this
        parameter to zero indicates that the error may occur but is not required to
        occur.  Setting this parameter to a value greater than zero indicates that the
        batch file is attempting to force the error.  In this case an error that occurs
        less than the specified number of times will be considered to be a failing
        condition.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 3,        if Loop Count Value
                   0 to 0xFFFF,   if Minimum Error Count
    
          Default: 0
    
    3 - Special Batch File Function Parameter.
    
        This parameter specifies additional information required by the special Batch
        File function selected by Parameter 0.
    
        If Parameter 0 is equal to 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 or B this parameter will
        not be used.
    
        If Parameter 0 is equal to A, this parameter specifies the maximum number of
        times the error specified by Parameter 1 is expected to occur.  If the error
        occurs more than the specified number of times this will be considered to be a
        failing condition.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFF
    
          Default: 0
    

  <b><i><u>Output Data:</u></i></b>
    None

  <b><i><u>Revision History:</u></i></b>
<a name="SPECIAL_BATCH_FILE_FUNCTION_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="SPIN_DOWN_AND_RESET_DRIVE_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Spin Down and Reset Drive"></a><hr align=left width="75%"><b> Spin Down and Reset Drive (Level 1 'e')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command spins down the drive, waits the specified number of milliseconds and
    jumps to the Power On Reset function or the Boot Strap Loader.  When jumping to
    the Power On Reset function, a Control Z command will be required to enable the
    Diagnostic Mode commands following the completion of the reset.

  <b><i><u>Quick Help:</u></i></b>
<a name="SPIN_DOWN_AND_RESET_DRIVE_QUICK_HELP"></a>
    "SpinDownAndResetDrive, e[MsecDelay],[Opts]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="SPIN_DOWN_AND_RESET_DRIVE_PARM"></a>
    0 - Delay After Spin Down.
    
        This parameter specifies the number of milliseconds to delay after spinning down
        and before resetting the drive.
    
          Type:    Unsigned 16-bit value
    
          Range:   0x1388 to 0xFFFF
    
          Default: 0x1388 (5000 msec or 5 seconds)
    
    1 - Jump to Boot Strap Loader option.
    
        If this parameter is equal to 0x0F, the code will jump to the Boot Strap Loader
        after spinning down the drive.  If this parameter is not equal to 0x0F, the code
        will jump to the Power On Reset function after spinning down the drive.
    
          Type:    Signed 8-bit value
    
          Range:   0 to 0xFF
    
          Default: None
    

  <b><i><u>Output Data:</u></i></b>
    The following string will be output to indicate that the drive is in the process
    of spinning down.

          "Spinning Down"

    When the spin down is complete, the following information will be displayed.

          "Spin Down Complete"
<a name="ELAPSED_TIME"></a>
    
       "Elapsed Time a mins b secs"  or
       "Elapsed Time b.c secs"       or
       "Elapsed Time c.d msecs"
    
    where
    
       a is minutes
       b is seconds
       c is milliseconds
       d is microseconds
    
    When delaying following spin down, the following string will be displayed.

          "Delaying eeee msec"

       where

          eeee is the length of the delay in milliseconds

    After the delay is complete, one of the following strings will be output to indicate
    that the reset is being performed.

          "Jumping to Power On Reset"      or
          "Jumping to Boot Loader"

  <b><i><u>Revision History:</u></i></b>
<a name="SPIN_DOWN_AND_RESET_DRIVE_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="SPIN_DOWN_DRIVE_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Spin Down Drive"></a><hr align=left width="75%"><b> Spin Down Drive (Levels 2, 3, 7, 8, F 'Z')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command spins the drive down.

  <b><i><u>Quick Help:</u></i></b>
<a name="SPIN_DOWN_DRIVE_QUICK_HELP"></a>
    "SpinDownDrive, Z";

  <b><i><u>Input Parameters:</u></i></b>
    None

  <b><i><u>Output Data:</u></i></b>
<a name="SPIN_UP_OR_DOWN_DATA"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
    
        In addition, one of the following strings will be output to indicate the current Spin
        State.
    
              "Spin Down Complete"                      or
              "Spin Up held prior to Unlatch"           or
              "Spin Up held prior to Demod Sync"        or
              "Spin Up held prior to Track Follow"      or
              "Spin Up Complete"                        or
              "Spin Error"                              or
              "Invalid Spin State"
    
        The elapsed time for the spin operation will be displayed as follows.
<a name="ELAPSED_TIME"></a>
    
       "Elapsed Time a mins b secs"  or
       "Elapsed Time b.c secs"       or
       "Elapsed Time c.d msecs"
    
    where
    
       a is minutes
       b is seconds
       c is milliseconds
       d is microseconds
    
    
        If a spin error occurred, the following additional information will be displayed.
    
              "R/W Status c R/W Error dddddddd"
    
           where
    
              c is the status returned by the R/W subsystem
    
                    0 = R/W request completed successfully with error recovery
                    1 = R/W request completed successfully (no error recovery performed)
                    2 = R/W request failed
    
              dddddddd is the error code returned by the R/W subsystem
    
        If a spin error occurred and the Verbose Formatted ASCII Data Output Mode is selected,
        the Verbose Mode option bits will enable the following data to be output when set.
    
           Bit 0-6:    NA
           Bit 7:      Enable the Servo Event Log to be displayed
           Bits 31-8:  NA
    
        If Bit 7 is set, the contents of the Servo Event Log will be displayed as follows.
    
<a name="SERVO_EVENT_LOG"></a>
       "Servo Event Log"
       "cccc cccc cccc ... cccc" (repeated until all entries have been displayed)
    
    where
    
       cccc is a 16-bit Servo Event Log entry
    
    

  <b><i><u>Revision History:</u></i></b>
<a name="SPIN_DOWN_DRIVE_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="SPIN_UP_DRIVE_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Spin Up Drive"></a><hr align=left width="75%"><b> Spin Up Drive (Levels 2, 3, 7, 8, F 'U')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    The command spins up the drive.  Optionally, the spin up operation can be paused
    in several intermediate states.

  <b><i><u>Quick Help:</u></i></b>
<a name="SPIN_UP_DRIVE_QUICK_HELP"></a>
    "SpinUpDrive, U[HoldState],[Hd],[Cyl]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="SPIN_UP_DRIVE_PARM"></a>
    0 - Spin Up Hold State.
    
        This parameter specifies the state in which the Spin Up operation is to be held.
    
            0 = Spin up and attempt to track follow on the default cylinder and head.
    
            1 = Advance to the next Spin Hold State.
    
            2 = Release the Spin Hold State.  If this option is selected the drive will
                spin up to completion and attempt to track follow on the specified cylinder
                and head.
    
            3 = Spin up and hold with the actuator latched.
    
            4 = Spin up, unlatch the actuator and hold prior to attempting to synchronize
                the demodulator to the data on the disk.
    
            5 = Spin up, unlatch the actuator, synchronize the demodulator to the data on
                the disk and hold prior to attempting to track follow.
    
          Type:    Unsigned 8-bit value
    
          Range:   0 to 0xFF
    
          Default: 0
    
    1 - Logical Head Address.
    
        If the Spin Hold States are being used (Parameter 0 not equal to 0), this
        parameter specifies the address of the logical head on which the spin up
        operation will attempt to synchronize the demodulator and / or track follow.
        If the Spin Hold States are not being used (Parameter 0 not entered or equal
        to 0), this parameter specifies the address of the logical head to which a
        seek will be performed after the drive is spun up.
    
          Type:    Unsigned 8-bit value
    
          Range:   0 to 0xFF
    
          Default: First logical head
    
    2 - Physical Cylinder Address.
    
        If the Spin Hold States are being used (Parameter 0 not equal to 0), this
        parameter specifies the address of the physical cylinder on which the spin
        up operation will attempt to track follow.  If the Spin Hold States are not
        being used (Parameter 0 not entered or equal to 0), this parameter specifies
        the address of the physical cylinder to which a seek will be performed after
        the drive is spun up.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: First user area physical cylinder
    

  <b><i><u>Output Data:</u></i></b>
<a name="SPIN_UP_OR_DOWN_DATA"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
    
        In addition, one of the following strings will be output to indicate the current Spin
        State.
    
              "Spin Down Complete"                      or
              "Spin Up held prior to Unlatch"           or
              "Spin Up held prior to Demod Sync"        or
              "Spin Up held prior to Track Follow"      or
              "Spin Up Complete"                        or
              "Spin Error"                              or
              "Invalid Spin State"
    
        The elapsed time for the spin operation will be displayed as follows.
<a name="ELAPSED_TIME"></a>
    
       "Elapsed Time a mins b secs"  or
       "Elapsed Time b.c secs"       or
       "Elapsed Time c.d msecs"
    
    where
    
       a is minutes
       b is seconds
       c is milliseconds
       d is microseconds
    
    
        If a spin error occurred, the following additional information will be displayed.
    
              "R/W Status c R/W Error dddddddd"
    
           where
    
              c is the status returned by the R/W subsystem
    
                    0 = R/W request completed successfully with error recovery
                    1 = R/W request completed successfully (no error recovery performed)
                    2 = R/W request failed
    
              dddddddd is the error code returned by the R/W subsystem
    
        If a spin error occurred and the Verbose Formatted ASCII Data Output Mode is selected,
        the Verbose Mode option bits will enable the following data to be output when set.
    
           Bit 0-6:    NA
           Bit 7:      Enable the Servo Event Log to be displayed
           Bits 31-8:  NA
    
        If Bit 7 is set, the contents of the Servo Event Log will be displayed as follows.
    
<a name="SERVO_EVENT_LOG"></a>
       "Servo Event Log"
       "cccc cccc cccc ... cccc" (repeated until all entries have been displayed)
    
    where
    
       cccc is a 16-bit Servo Event Log entry
    
    

  <b><i><u>Revision History:</u></i></b>
<a name="SPIN_UP_DRIVE_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="TOGGLE_DEBUG_DISPLAY_ENABLE_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Toggle Debug Display Enable"></a><hr align=left width="75%"><b> Toggle Debug Display Enable (Online Control \)</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command toggles the Debug Display Enable state.

  <b><i><u>Quick Help:</u></i></b>
<a name="TOGGLE_DEBUG_DISPLAY_ENABLE_QUICK_HELP"></a>
    "ToggleDebugDisplayEnable";

  <b><i><u>Input Parameters:</u></i></b>
    None

  <b><i><u>Output Data:</u></i></b>
    If the Debug Display is enabled, the following message will be displayed.

       "Debug Display enabled"

    If the Debug Display is disabled, the following message will be displayed.

       "Debug Display disabled"

  <b><i><u>Revision History:</u></i></b>
<a name="TOGGLE_DEBUG_DISPLAY_ENABLE_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="TOGGLE_DIAG_IDLE_MODE_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Toggle Diag Idle Mode"></a><hr align=left width="75%"><b> Toggle Diag Idle Mode (Online Control P)</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command toggles the selected idle mode features.  If the selected features are
    enabled, this command will disable them.  If the selected features are disabled, this
    command will enable them.

    Features are selected [ and enabled ] by being enabled with the level 2 M command.

  <b><i><u>Quick Help:</u></i></b>
<a name="TOGGLE_DIAG_IDLE_MODE_QUICK_HELP"></a>
    "ToggleDiagIdleMode";

  <b><i><u>Input Parameters:</u></i></b>
    None

  <b><i><u>Output Data:</u></i></b>
<a name="DIAG_IDLE_MODE"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
     If no error occurred, then the following will be displayed:
    
                        Dithering xxx  ctl-P yyyyyyyyyyy
                              TCC xxx  ctl-P yyyyyyyyyyy
        Continuous heat to writer xxx  ctl-P yyyyyyyyyyy
        MR chop / cnt. preamp pwr xxx  ctl-P yyyyyyyyyyy
                            PFast xxx  ctl-P yyyyyyyyyyy
         Continuous channel power xxx  ctl-P yyyyyyyyyyy
    
     Where:
    
        xxx is either "On" or "Off"
    
        yyyyyyyyyyy is either "toggles" or "won't toggle"
    
    </font>

  <b><i><u>Revision History:</u></i></b>
<a name="TOGGLE_DIAG_IDLE_MODE_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="TOGGLE_EIB_TRACING_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Toggle EIB-Specific R/W Tracing"></a><hr align=left width="75%"><b> Toggle EIB-Specific R/W Tracing (Online {)</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command is used to control the display of Read/Write Retry Tracing Characters using
    the serial port, formatted specifically for use with the Error Injection Board (EIB).
    Several modes can be selected through the setting of the bits S T R:
 
    S  T  R  |  Display Mode
    *************************************************************************
    0  X  X  |  Vismux signals Enabled during Read/Write of a System Sector
    1  X  X  |  Vismux signals Disabled during Read/Write of a System Sector
    X  0  1  |  Retry number displayed. (see example below)
    X  1  0  |  Tagged or delimited retry number displayed. (see example below)
 
    example: Retry number displayed - for each retry, output the mode (R/W) and the retry number.
             R0001R0002R0003 or W0001W0002W0003
    example: Tagged retry number - this is the same as Retry Number display with the inclusion
             of a unique character '~', which is used to delimit each retry.
             ~R0001~R0002~R0003 or ~W0001~W0002~W0003

  <b><i><u>Quick Help:</u></i></b>
<a name="TOGGLE_EIB_TRACING_QUICK_HELP"></a>
    "ToggleEibTracing";

  <b><i><u>Input Parameters:</u></i></b>
    None

  <b><i><u>Output Data:</u></i></b>
<a name="EIB_TRACING_STATE"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
        If no error occurred, the following information will be displayed.
    
              "S T R = a b c"
    
           where
    
              "S T R" is an acronym for "Suppress Vismux", "Tagged Retry number", "Retry number"
    
              a is equal to 1 if the Vismux output is supressed during System Sectors
    
              b is equal to 1 if additional tagging characters are added to the Retry number
    
              c is equal to 1 if the Retry number is to be output
    

  <b><i><u>Revision History:</u></i></b>
<a name="TOGGLE_EIB_TRACING_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="TOGGLE_INTERFACE_CMD_ECHO_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Toggle Interface Command Echo"></a><hr align=left width="75%"><b> Toggle Interface Command Echo (Online Control V)</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command toggles the Interface Command Echo state

  <b><i><u>Quick Help:</u></i></b>
<a name="TOGGLE_INTERFACE_CMD_ECHO_QUICK_HELP"></a>
    "ToggleInterfaceCmdEcho";

  <b><i><u>Input Parameters:</u></i></b>
    None

  <b><i><u>Output Data:</u></i></b>
<a name="INTERFACE_CMD_ECHO"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
        If no error occurred, following information will be displayed.
    
        If the Toggle Interface Command Echo is enabled, following will be displayed
    
        "EchoInterfaceCmds: On"
    
        If the Toggle Interface Command Echo is disable, following will be displayed
    
        "EchoInterfaceCmds: Off"
     
        If the Toggle Interface Command Echo is enabled, Interface Command State will be
        displayed when a new Command was received on the Native Interface.
        For detail format of the Interface Command State please refer Online '~' Diag Command.
     

  <b><i><u>Revision History:</u></i></b>
<a name="TOGGLE_INTERFACE_CMD_ECHO_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="TOGGLE_RW_TRACING_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Toggle R/W Tracing"></a><hr align=left width="75%"><b> Toggle R/W Tracing (Online Control D or Control N)</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command steps through all possible combinations of enabled / disabled states
    for the following three R/W Tracing functions:

       Retry Tracing
       Command Tracing
       Error Tracing

  <b><i><u>Quick Help:</u></i></b>
<a name="TOGGLE_RW_TRACING_QUICK_HELP"></a>
    "ToggleRwTracing";

  <b><i><u>Input Parameters:</u></i></b>
    None

  <b><i><u>Output Data:</u></i></b>
<a name="RW_TRACING_STATE"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
        If no error occurred, the following information will be displayed.
    
              "e c r = a b c"
    
           where
    
              "e c r" is an acronym for "error", "command", "retry" tracing
    
              a is equal to 1 if error tracing is enabled and 0 if error tracing is disabled
    
              b is equal to 1 if command tracing is enabled and 0 if command tracing is disabled
    
              c is equal to 1 if retry tracing is enabled and 0 if retry tracing is disabled
    

  <b><i><u>Revision History:</u></i></b>
<a name="TOGGLE_RW_TRACING_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="TRANSLATE_LBA_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Translate LBA"></a><hr align=left width="75%"><b> Translate LBA (Level A 'F')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command translates the specified Logical Block Address (LBA) to the following:

       - PBA (Physical Block Address)
       - LLL CHS (Logical Cylinder, Logical Head and Logical Sector)
       - PLP CHS (Physical Cylinder, Logical Head and Physical Sector)
       - Wedge Address
       - Symbols From Index
       - Zone Number

  <b><i><u>Quick Help:</u></i></b>
<a name="TRANSLATE_LBA_QUICK_HELP"></a>
    "XlateLba, F[LbaHi],[LbaLo],[SysAreaOpt],[NumLbas]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="TRANSLATE_LBA_PARM"></a>
    0 - LBA or LBA High.
    
        If Parameter 1 is not entered, then this parameter contains the 32-bit Logical
        Block Address to be translated.  If Parameter 1 is entered, then this parameter
        contains the upper 16-bits of the Logical Block Address to be translated.
    
        If Parameter 2 is entered, then the specified LBA is located in the System
        Area, else it is located in the User Area.
    
          Type:    Unsigned 32-bit value, if Parameter 1 is not entered
                   Unsigned 16-bit value, if Parameter 1 is entered
    
          Range:   0 to 0xffffffff, if Parameter 1 is not entered
                   0 to 0xffff, if Parameter 1 is entered
    
          Default: 0
    
    1 - LBA Low.
    
        This parameter contains the lower 16-bits of the Logical Block Address to be
        translated.
    
        If Parameter 2 is entered, then the specified LBA is located in the System
        Area, else it is located in the User Area.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xffff
    
          Default: None.  If this parameter is not entered, then Parameter 0 is assumed
                   to specify the entire 32-bit Logical Block Address to be translated.
    
    2 - System Area Flag.
    
        If any value is entered for this parameter, then the Logical Block Address
        specified by Parameters 0 and 1 is located in the System Area, else it is located
        in the User Area.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xffff
    
          Default: None
    
    3 - LBA Count.
    
        This value will specify the number of consecutive LBAs to be translated.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xffffffff
    
          Default: 1
    

  <b><i><u>Output Data:</u></i></b>
<a name="TRANSLATE_ADDR_DATA"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
        If no error occurred, the track information will be displayed as follows.
    
<a name="TRACK_INFO"></a>
    
       "Track Info:"
       "Partition PhyCyl   LogCyl   NomCyl   Radius_mils LogHd Zn FirstLba FirstPba LogSecs PhySecs WdgSkw SecPerFrm WdgPerFrm"
       "User      cccccccc dddddddd nnnnnnnn o.ooooooEoo ee    ff gggggggg hhhhhhhh iiii    jjjj    kkkk   llll      mmmm"        or
       "System    cccccccc dddddddd nnnnnnnn o.ooooooEoo ee    ff gggggggg hhhhhhhh iiii    jjjj    kkkk   llll      mmmm"
    
    where
    
       cccccccc          is the Logical Cylinder address where Logical Cylinders do not
                         include the cylinders in other partitions.
    
       dddddddd          is the Physical Cylinder address where Physical Cylinders
                         include User Area Cylinders, System Area Cylinders and Spare
                         Cylinders.
    
       ee                is the Logical Head address where Logical Heads do not
                         include heads that have been depopulated.
    
       ff                is the number of the zone that contains the track.
    
       gggggggg          is the first Logical Block Address (LBA) on the track.
    
       hhhhhhhh          is the first Physical Block Address (PBA) on the track.
    
       iiii              is the number of logical sectors on the track.
    
       jjjj              is the number of physical sectors on the track.
    
       kkkk              is the skew in wedges from index to the wedge that contains
                         physical sector 0.
    
       llll              is the number of physical sectors per frame.
    
       mmmm              is the number of wedges per frame.
    
       nnnnnnnn          is the Nominal Cylinder address where Nominal Cylinders
                         remove the VBAR scaling factor.
    
       o.ooooooEoo       is the Radius in milliinches as measured from the hub.
    
    
        This will be followed by the sector information which will be displayed as follows.
    
<a name="SECTOR_INFO"></a>
    
          "Sector Info:"
          "LBA      PBA      LogSec PhySec Wdg  SFI     "
          "cccccccc dddddddd eeee   ffff   gggg hhhhhhhh"
    
       where
    
          cccccccc          is the Logical Block Address (LBA) of the sector within the
                            User or System Area.  All non-defective, non-spare User Area
                            sectors are numbered consecutively starting with zero.
                            Defective sectors do not have a valid LBA and will be skipped
                            when accessing consecutive LBAs.  System Area sectors are
                            number similarly starting with 0.
    
          dddddddd          is the Physical Block Address (PBA) of the sector within the
                            User or System Area.  All User Area sectors (including spare
                            and defective sectors) are numbered consecutively starting
                            with zero.  System Area sectors are number similarly starting
                            with 0.
    
          eeee              is the Logical Sector address where Logical Sectors do not
                            include defective sectors that have been slipped or unused
                            spares.
    
          ffff              is the Physical Sector address where Physical Sectors include
                            all of the sectors on the track (including those marked as
                            defective).  It should be noted that the Physical Sector address
                            is skewed from index.  This means that the first sector following
                            index is not guaranteed to be Physical Sector 0 and may be the
                            second half of split sector.
    
          gggg              is the number of the Servo Burst preceeding the data wedge
                            that contains the sector.
    
          hhhhhhhh          is the offset in NRZ Symbols from Index.
    
    If the sector is split, the following additional information will be displayed.
    
          " Split ppp:qqq bytes at Burst rrrrrr"
    
       where
    
          ppp               is the number of bytes before the split.
    
          qqq               is the number of bytes after the split.
    
          rrrrrr            is the number of the servo burst that splits the sector.
    
    

  <b><i><u>Revision History:</u></i></b>
<a name="TRANSLATE_LBA_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0002.0000   Added Nominal Cylinder and Radius to the Track Info output.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="TRANSLATE_LLL_CHS_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Translate Logical Cylinder, Logical Head and Logical Sector"></a><hr align=left width="75%"><b> Translate Logical Cylinder, Logical Head and Logical Sector (Level A 'c')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command translates the specified LLL CHS (Logical Cylinder, Logical Head and
    Logical Sector) address to the following:

       - LBA (Logical Block Address)
       - PBA (Physical Block Address)
       - PLP CHS (Physical Cylinder, Logical Head and Physical Sector)
       - Wedge Address
       - Symbols From Index
       - Zone Number

  <b><i><u>Quick Help:</u></i></b>
<a name="TRANSLATE_LLL_CHS_QUICK_HELP"></a>
    "XlateLllChs, c[Cyl],[Hd],[Sec],[SysAreaOpt],[NumSecs]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="TRANSLATE_LLL_CHS_PARM"></a>
    0 - Logical Cylinder Address.
    
        If Parameter 3 was entered, this parameter specifies a System Area Logical
        Cylinder Address to be translated.  If Parameter 3 was not entered, this
        parameter specifies a User Area Logical Cylinder Address to be translated.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: 0
    
    1 - Logical Head Address.
    
        This parameter specifies the Logical Head Address to be translated.
    
          Type:    Unsigned 8-bit value
    
          Range:   0 to 0xFF
    
          Default: 0
    
    2 - Logical Sector Address.
    
        This parameter specifies the Logical Sector Address to be translated.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to maximum logical sector address on specified track
    
          Default: 0
    
    3 - System Area Flag.
    
        If any value is entered for this parameter, then Parameters 0 specifies a
        System Area Logical Cylinder Address, else it specifies a User Area Logical
        Cylinder Address.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: None
    
    4 - Logical Sector Count.
    
        This value will specify the number of consecutive Logical Sectors to be translated.
        (Note: The value entered will be limited to the Logical Sectors remaining on the
        track.)
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xffffffff
    
          Default: 1
    

  <b><i><u>Output Data:</u></i></b>
<a name="TRANSLATE_ADDR_DATA"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
        If no error occurred, the track information will be displayed as follows.
    
<a name="TRACK_INFO"></a>
    
       "Track Info:"
       "Partition PhyCyl   LogCyl   NomCyl   Radius_mils LogHd Zn FirstLba FirstPba LogSecs PhySecs WdgSkw SecPerFrm WdgPerFrm"
       "User      cccccccc dddddddd nnnnnnnn o.ooooooEoo ee    ff gggggggg hhhhhhhh iiii    jjjj    kkkk   llll      mmmm"        or
       "System    cccccccc dddddddd nnnnnnnn o.ooooooEoo ee    ff gggggggg hhhhhhhh iiii    jjjj    kkkk   llll      mmmm"
    
    where
    
       cccccccc          is the Logical Cylinder address where Logical Cylinders do not
                         include the cylinders in other partitions.
    
       dddddddd          is the Physical Cylinder address where Physical Cylinders
                         include User Area Cylinders, System Area Cylinders and Spare
                         Cylinders.
    
       ee                is the Logical Head address where Logical Heads do not
                         include heads that have been depopulated.
    
       ff                is the number of the zone that contains the track.
    
       gggggggg          is the first Logical Block Address (LBA) on the track.
    
       hhhhhhhh          is the first Physical Block Address (PBA) on the track.
    
       iiii              is the number of logical sectors on the track.
    
       jjjj              is the number of physical sectors on the track.
    
       kkkk              is the skew in wedges from index to the wedge that contains
                         physical sector 0.
    
       llll              is the number of physical sectors per frame.
    
       mmmm              is the number of wedges per frame.
    
       nnnnnnnn          is the Nominal Cylinder address where Nominal Cylinders
                         remove the VBAR scaling factor.
    
       o.ooooooEoo       is the Radius in milliinches as measured from the hub.
    
    
        This will be followed by the sector information which will be displayed as follows.
    
<a name="SECTOR_INFO"></a>
    
          "Sector Info:"
          "LBA      PBA      LogSec PhySec Wdg  SFI     "
          "cccccccc dddddddd eeee   ffff   gggg hhhhhhhh"
    
       where
    
          cccccccc          is the Logical Block Address (LBA) of the sector within the
                            User or System Area.  All non-defective, non-spare User Area
                            sectors are numbered consecutively starting with zero.
                            Defective sectors do not have a valid LBA and will be skipped
                            when accessing consecutive LBAs.  System Area sectors are
                            number similarly starting with 0.
    
          dddddddd          is the Physical Block Address (PBA) of the sector within the
                            User or System Area.  All User Area sectors (including spare
                            and defective sectors) are numbered consecutively starting
                            with zero.  System Area sectors are number similarly starting
                            with 0.
    
          eeee              is the Logical Sector address where Logical Sectors do not
                            include defective sectors that have been slipped or unused
                            spares.
    
          ffff              is the Physical Sector address where Physical Sectors include
                            all of the sectors on the track (including those marked as
                            defective).  It should be noted that the Physical Sector address
                            is skewed from index.  This means that the first sector following
                            index is not guaranteed to be Physical Sector 0 and may be the
                            second half of split sector.
    
          gggg              is the number of the Servo Burst preceeding the data wedge
                            that contains the sector.
    
          hhhhhhhh          is the offset in NRZ Symbols from Index.
    
    If the sector is split, the following additional information will be displayed.
    
          " Split ppp:qqq bytes at Burst rrrrrr"
    
       where
    
          ppp               is the number of bytes before the split.
    
          qqq               is the number of bytes after the split.
    
          rrrrrr            is the number of the servo burst that splits the sector.
    
    

  <b><i><u>Revision History:</u></i></b>
<a name="TRANSLATE_LLL_CHS_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0002.0000   Added Nominal Cylinder and Radius to the Track Info output.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="TRANSLATE_LOGICAL_SECTOR_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Translate Logical Sector"></a><hr align=left width="75%"><b> Translate Logical Sector (Level 2 'l', Level 3 'q')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command translates the specified Logical Sector address on the current track to
    the following:

       - LBA (Logical Block Address)
       - PBA (Physical Block Address)
       - PLP CHS (Physical Cylinder, Logical Head and Physical Sector)
       - Wedge Address
       - Symbols From Index
       - Zone Number

  <b><i><u>Quick Help:</u></i></b>
<a name="TRANSLATE_LOGICAL_SECTOR_QUICK_HELP"></a>
       Level 2
    "XlateLogSec, l[Sec],[NumSecs]";
       Level 3
    "XlateLogSec, q[Sec],[NumSecs]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="TRANSLATE_LOGICAL_SECTOR_PARM"></a>
    0 - Logical Sector Address.
    
        This parameter specifies the address of the Logical Sector on the current
        track to be translated.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to maximum logical sector address on current track
    
          Default: 0
    
    1 - Logical Sector Count.
    
        This value will specify the number of consecutive Logical Sectors to be translated.
        (Note: The value entered will be limited to the Logical Sectors remaining on the
        track.)
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xffffffff
    
          Default: 1
    

  <b><i><u>Output Data:</u></i></b>
<a name="TRANSLATE_ADDR_DATA"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
        If no error occurred, the track information will be displayed as follows.
    
<a name="TRACK_INFO"></a>
    
       "Track Info:"
       "Partition PhyCyl   LogCyl   NomCyl   Radius_mils LogHd Zn FirstLba FirstPba LogSecs PhySecs WdgSkw SecPerFrm WdgPerFrm"
       "User      cccccccc dddddddd nnnnnnnn o.ooooooEoo ee    ff gggggggg hhhhhhhh iiii    jjjj    kkkk   llll      mmmm"        or
       "System    cccccccc dddddddd nnnnnnnn o.ooooooEoo ee    ff gggggggg hhhhhhhh iiii    jjjj    kkkk   llll      mmmm"
    
    where
    
       cccccccc          is the Logical Cylinder address where Logical Cylinders do not
                         include the cylinders in other partitions.
    
       dddddddd          is the Physical Cylinder address where Physical Cylinders
                         include User Area Cylinders, System Area Cylinders and Spare
                         Cylinders.
    
       ee                is the Logical Head address where Logical Heads do not
                         include heads that have been depopulated.
    
       ff                is the number of the zone that contains the track.
    
       gggggggg          is the first Logical Block Address (LBA) on the track.
    
       hhhhhhhh          is the first Physical Block Address (PBA) on the track.
    
       iiii              is the number of logical sectors on the track.
    
       jjjj              is the number of physical sectors on the track.
    
       kkkk              is the skew in wedges from index to the wedge that contains
                         physical sector 0.
    
       llll              is the number of physical sectors per frame.
    
       mmmm              is the number of wedges per frame.
    
       nnnnnnnn          is the Nominal Cylinder address where Nominal Cylinders
                         remove the VBAR scaling factor.
    
       o.ooooooEoo       is the Radius in milliinches as measured from the hub.
    
    
        This will be followed by the sector information which will be displayed as follows.
    
<a name="SECTOR_INFO"></a>
    
          "Sector Info:"
          "LBA      PBA      LogSec PhySec Wdg  SFI     "
          "cccccccc dddddddd eeee   ffff   gggg hhhhhhhh"
    
       where
    
          cccccccc          is the Logical Block Address (LBA) of the sector within the
                            User or System Area.  All non-defective, non-spare User Area
                            sectors are numbered consecutively starting with zero.
                            Defective sectors do not have a valid LBA and will be skipped
                            when accessing consecutive LBAs.  System Area sectors are
                            number similarly starting with 0.
    
          dddddddd          is the Physical Block Address (PBA) of the sector within the
                            User or System Area.  All User Area sectors (including spare
                            and defective sectors) are numbered consecutively starting
                            with zero.  System Area sectors are number similarly starting
                            with 0.
    
          eeee              is the Logical Sector address where Logical Sectors do not
                            include defective sectors that have been slipped or unused
                            spares.
    
          ffff              is the Physical Sector address where Physical Sectors include
                            all of the sectors on the track (including those marked as
                            defective).  It should be noted that the Physical Sector address
                            is skewed from index.  This means that the first sector following
                            index is not guaranteed to be Physical Sector 0 and may be the
                            second half of split sector.
    
          gggg              is the number of the Servo Burst preceeding the data wedge
                            that contains the sector.
    
          hhhhhhhh          is the offset in NRZ Symbols from Index.
    
    If the sector is split, the following additional information will be displayed.
    
          " Split ppp:qqq bytes at Burst rrrrrr"
    
       where
    
          ppp               is the number of bytes before the split.
    
          qqq               is the number of bytes after the split.
    
          rrrrrr            is the number of the servo burst that splits the sector.
    
    

  <b><i><u>Revision History:</u></i></b>
<a name="TRANSLATE_LOGICAL_SECTOR_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0002.0000   Added Nominal Cylinder and Radius to the Track Info output.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="TRANSLATE_NOMINAL_CYLINDER_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Translate Nominal Cylinder and Logical Head"></a><hr align=left width="75%"><b> Translate Nominal Cylinder and Logical Head (Level A 'e')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command translates the specified Nominal cylinder and logical head address to the following:

       - LBA (Logical Block Address)
       - PBA (Physical Block Address)
       - LLL CHS (Logical Cylinder, Logical Head and Logical Sector)
       - PLP CHS (Physical Cylinder, Logical Head and Physical Sector)
       - Wedge Address
       - Symbols From Index
       - Zone Number

  <b><i><u>Quick Help:</u></i></b>
<a name="TRANSLATE_NOMINAL_CYLINDER_QUICK_HELP"></a>
    "XlateNominalCyl, e[Cyl],[Hd],[Sec],[SysAreaOpt]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="TRANSLATE_NOMINAL_CYLINDER_PARM"></a>
    0 - Nominal Cylinder Address.
    
        This parameter specifies the Nominal Cylinder Address to be translated.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: 0
    
    1 - Logical Head Address.
    
        This parameter specifies the Logical Head Address to be translated.
    
          Type:    Unsigned 8-bit value
    
          Range:   0 to 0xFF
    
          Default: 0
    
    2 - Logical Sector Address.
    
        This parameter specifies the Logical Sector Address to be translated.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to maximum logical sector address on specified track
    
          Default: 0
    
    3 - System Area Flag.
    
        If any value is entered for this parameter, then Parameter 0 specifies a
        System Area Logical Cylinder Address, else it specifies a User Area Logical
        Cylinder Address.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: None
    

  <b><i><u>Output Data:</u></i></b>
<a name="TRANSLATE_ADDR_DATA"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
        If no error occurred, the track information will be displayed as follows.
    
<a name="TRACK_INFO"></a>
    
       "Track Info:"
       "Partition PhyCyl   LogCyl   NomCyl   Radius_mils LogHd Zn FirstLba FirstPba LogSecs PhySecs WdgSkw SecPerFrm WdgPerFrm"
       "User      cccccccc dddddddd nnnnnnnn o.ooooooEoo ee    ff gggggggg hhhhhhhh iiii    jjjj    kkkk   llll      mmmm"        or
       "System    cccccccc dddddddd nnnnnnnn o.ooooooEoo ee    ff gggggggg hhhhhhhh iiii    jjjj    kkkk   llll      mmmm"
    
    where
    
       cccccccc          is the Logical Cylinder address where Logical Cylinders do not
                         include the cylinders in other partitions.
    
       dddddddd          is the Physical Cylinder address where Physical Cylinders
                         include User Area Cylinders, System Area Cylinders and Spare
                         Cylinders.
    
       ee                is the Logical Head address where Logical Heads do not
                         include heads that have been depopulated.
    
       ff                is the number of the zone that contains the track.
    
       gggggggg          is the first Logical Block Address (LBA) on the track.
    
       hhhhhhhh          is the first Physical Block Address (PBA) on the track.
    
       iiii              is the number of logical sectors on the track.
    
       jjjj              is the number of physical sectors on the track.
    
       kkkk              is the skew in wedges from index to the wedge that contains
                         physical sector 0.
    
       llll              is the number of physical sectors per frame.
    
       mmmm              is the number of wedges per frame.
    
       nnnnnnnn          is the Nominal Cylinder address where Nominal Cylinders
                         remove the VBAR scaling factor.
    
       o.ooooooEoo       is the Radius in milliinches as measured from the hub.
    
    
        This will be followed by the sector information which will be displayed as follows.
    
<a name="SECTOR_INFO"></a>
    
          "Sector Info:"
          "LBA      PBA      LogSec PhySec Wdg  SFI     "
          "cccccccc dddddddd eeee   ffff   gggg hhhhhhhh"
    
       where
    
          cccccccc          is the Logical Block Address (LBA) of the sector within the
                            User or System Area.  All non-defective, non-spare User Area
                            sectors are numbered consecutively starting with zero.
                            Defective sectors do not have a valid LBA and will be skipped
                            when accessing consecutive LBAs.  System Area sectors are
                            number similarly starting with 0.
    
          dddddddd          is the Physical Block Address (PBA) of the sector within the
                            User or System Area.  All User Area sectors (including spare
                            and defective sectors) are numbered consecutively starting
                            with zero.  System Area sectors are number similarly starting
                            with 0.
    
          eeee              is the Logical Sector address where Logical Sectors do not
                            include defective sectors that have been slipped or unused
                            spares.
    
          ffff              is the Physical Sector address where Physical Sectors include
                            all of the sectors on the track (including those marked as
                            defective).  It should be noted that the Physical Sector address
                            is skewed from index.  This means that the first sector following
                            index is not guaranteed to be Physical Sector 0 and may be the
                            second half of split sector.
    
          gggg              is the number of the Servo Burst preceeding the data wedge
                            that contains the sector.
    
          hhhhhhhh          is the offset in NRZ Symbols from Index.
    
    If the sector is split, the following additional information will be displayed.
    
          " Split ppp:qqq bytes at Burst rrrrrr"
    
       where
    
          ppp               is the number of bytes before the split.
    
          qqq               is the number of bytes after the split.
    
          rrrrrr            is the number of the servo burst that splits the sector.
    
    

  <b><i><u>Revision History:</u></i></b>
<a name="TRANSLATE_NOMINAL_CYLINDER_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="TRANSLATE_PBA_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Translate PBA"></a><hr align=left width="75%"><b> Translate PBA (Level A 'C')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command translates the specified Physical Block Address (PBA) to the following:

       - LBA (Logical Block Address)
       - LLL CHS (Logical Cylinder, Logical Head and Logical Sector)
       - PLP CHS (Physical Cylinder, Logical Head and Physical Sector)
       - Wedge Address
       - Symbols From Index
       - Zone Number

    Note: PBA translations are currently only supported for sectors in the User Area.

  <b><i><u>Quick Help:</u></i></b>
<a name="TRANSLATE_PBA_QUICK_HELP"></a>
    "XlatePba, C[PbaHi],[PbaLow],[NumPbas]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="TRANSLATE_PBA_PARM"></a>
    0 - PBA or PBA High.
    
        If Parameter 1 is not entered, then this parameter contains the 32-bit Physical
        Block Address to be translated.  If Parameter 1 is entered, then this parameter
        contains the upper 16-bits of the Physical Block Address to be translated.
    
          Type:    Unsigned 32-bit value, if Parameter 1 is not entered
                   Unsigned 16-bit value, if Parameter 1 is entered
    
          Range:   0 to 0xffffffff, if Parameter 1 is not entered
                   0 to 0xffff, if Parameter 1 is entered
    
          Default: 0
    
    1 - PBA Low.
    
        This parameter contains the lower 16-bits of the Physical Block Address to be
        translated.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xffff
    
          Default: None.  If this parameter is not entered, then Parameter 0 is assumed
                   to specify the entire 32-bit Physical Block Address to be translated.
    
    2 - PBA Count.
    
        This value will specify the number of consecutive PBAs to be translated.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xffffffff
    
          Default: 1
    

  <b><i><u>Output Data:</u></i></b>
<a name="TRANSLATE_ADDR_DATA"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
        If no error occurred, the track information will be displayed as follows.
    
<a name="TRACK_INFO"></a>
    
       "Track Info:"
       "Partition PhyCyl   LogCyl   NomCyl   Radius_mils LogHd Zn FirstLba FirstPba LogSecs PhySecs WdgSkw SecPerFrm WdgPerFrm"
       "User      cccccccc dddddddd nnnnnnnn o.ooooooEoo ee    ff gggggggg hhhhhhhh iiii    jjjj    kkkk   llll      mmmm"        or
       "System    cccccccc dddddddd nnnnnnnn o.ooooooEoo ee    ff gggggggg hhhhhhhh iiii    jjjj    kkkk   llll      mmmm"
    
    where
    
       cccccccc          is the Logical Cylinder address where Logical Cylinders do not
                         include the cylinders in other partitions.
    
       dddddddd          is the Physical Cylinder address where Physical Cylinders
                         include User Area Cylinders, System Area Cylinders and Spare
                         Cylinders.
    
       ee                is the Logical Head address where Logical Heads do not
                         include heads that have been depopulated.
    
       ff                is the number of the zone that contains the track.
    
       gggggggg          is the first Logical Block Address (LBA) on the track.
    
       hhhhhhhh          is the first Physical Block Address (PBA) on the track.
    
       iiii              is the number of logical sectors on the track.
    
       jjjj              is the number of physical sectors on the track.
    
       kkkk              is the skew in wedges from index to the wedge that contains
                         physical sector 0.
    
       llll              is the number of physical sectors per frame.
    
       mmmm              is the number of wedges per frame.
    
       nnnnnnnn          is the Nominal Cylinder address where Nominal Cylinders
                         remove the VBAR scaling factor.
    
       o.ooooooEoo       is the Radius in milliinches as measured from the hub.
    
    
        This will be followed by the sector information which will be displayed as follows.
    
<a name="SECTOR_INFO"></a>
    
          "Sector Info:"
          "LBA      PBA      LogSec PhySec Wdg  SFI     "
          "cccccccc dddddddd eeee   ffff   gggg hhhhhhhh"
    
       where
    
          cccccccc          is the Logical Block Address (LBA) of the sector within the
                            User or System Area.  All non-defective, non-spare User Area
                            sectors are numbered consecutively starting with zero.
                            Defective sectors do not have a valid LBA and will be skipped
                            when accessing consecutive LBAs.  System Area sectors are
                            number similarly starting with 0.
    
          dddddddd          is the Physical Block Address (PBA) of the sector within the
                            User or System Area.  All User Area sectors (including spare
                            and defective sectors) are numbered consecutively starting
                            with zero.  System Area sectors are number similarly starting
                            with 0.
    
          eeee              is the Logical Sector address where Logical Sectors do not
                            include defective sectors that have been slipped or unused
                            spares.
    
          ffff              is the Physical Sector address where Physical Sectors include
                            all of the sectors on the track (including those marked as
                            defective).  It should be noted that the Physical Sector address
                            is skewed from index.  This means that the first sector following
                            index is not guaranteed to be Physical Sector 0 and may be the
                            second half of split sector.
    
          gggg              is the number of the Servo Burst preceeding the data wedge
                            that contains the sector.
    
          hhhhhhhh          is the offset in NRZ Symbols from Index.
    
    If the sector is split, the following additional information will be displayed.
    
          " Split ppp:qqq bytes at Burst rrrrrr"
    
       where
    
          ppp               is the number of bytes before the split.
    
          qqq               is the number of bytes after the split.
    
          rrrrrr            is the number of the servo burst that splits the sector.
    
    

  <b><i><u>Revision History:</u></i></b>
<a name="TRANSLATE_PBA_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0002.0000   Added Nominal Cylinder and Radius to the Track Info output.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="TRANSLATE_PHYSICAL_SECTOR_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Translate Physical Sector"></a><hr align=left width="75%"><b> Translate Physical Sector (Level 2 'h', Level 3 'p')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command translates the specified Physical Sector address on the current track to
    the following:

       - LBA (Logical Block Address)
       - PBA (Physical Block Address)
       - LLL CHS (Logical Cylinder, Logical Head and Logical Sector)
       - Wedge Address
       - Symbols From Index
       - Zone Number

  <b><i><u>Quick Help:</u></i></b>
<a name="TRANSLATE_PHYSICAL_SECTOR_QUICK_HELP"></a>
       Level 2
    "XlatePhySec, h[Sec],[NumSecs]";
       Level 3
    "XlatePhySec, p[Sec],[NumSecs]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="TRANSLATE_PHYSICAL_SECTOR_PARM"></a>
    0 - Physical Sector Address.
    
        This parameter specifies the address of the Physical Sector on the current
        track to be translated.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to maximum physical sector address on current track
    
          Default: 0
    
    1 - Physical Sector Count.
    
        This value will specify the number of consecutive Physical Sectors to be translated.
        (Note: The value entered will be limited to the Physical Sectors remaining on the
        track.)
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xffffffff
    
          Default: 1
    

  <b><i><u>Output Data:</u></i></b>
<a name="TRANSLATE_ADDR_DATA"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
        If no error occurred, the track information will be displayed as follows.
    
<a name="TRACK_INFO"></a>
    
       "Track Info:"
       "Partition PhyCyl   LogCyl   NomCyl   Radius_mils LogHd Zn FirstLba FirstPba LogSecs PhySecs WdgSkw SecPerFrm WdgPerFrm"
       "User      cccccccc dddddddd nnnnnnnn o.ooooooEoo ee    ff gggggggg hhhhhhhh iiii    jjjj    kkkk   llll      mmmm"        or
       "System    cccccccc dddddddd nnnnnnnn o.ooooooEoo ee    ff gggggggg hhhhhhhh iiii    jjjj    kkkk   llll      mmmm"
    
    where
    
       cccccccc          is the Logical Cylinder address where Logical Cylinders do not
                         include the cylinders in other partitions.
    
       dddddddd          is the Physical Cylinder address where Physical Cylinders
                         include User Area Cylinders, System Area Cylinders and Spare
                         Cylinders.
    
       ee                is the Logical Head address where Logical Heads do not
                         include heads that have been depopulated.
    
       ff                is the number of the zone that contains the track.
    
       gggggggg          is the first Logical Block Address (LBA) on the track.
    
       hhhhhhhh          is the first Physical Block Address (PBA) on the track.
    
       iiii              is the number of logical sectors on the track.
    
       jjjj              is the number of physical sectors on the track.
    
       kkkk              is the skew in wedges from index to the wedge that contains
                         physical sector 0.
    
       llll              is the number of physical sectors per frame.
    
       mmmm              is the number of wedges per frame.
    
       nnnnnnnn          is the Nominal Cylinder address where Nominal Cylinders
                         remove the VBAR scaling factor.
    
       o.ooooooEoo       is the Radius in milliinches as measured from the hub.
    
    
        This will be followed by the sector information which will be displayed as follows.
    
<a name="SECTOR_INFO"></a>
    
          "Sector Info:"
          "LBA      PBA      LogSec PhySec Wdg  SFI     "
          "cccccccc dddddddd eeee   ffff   gggg hhhhhhhh"
    
       where
    
          cccccccc          is the Logical Block Address (LBA) of the sector within the
                            User or System Area.  All non-defective, non-spare User Area
                            sectors are numbered consecutively starting with zero.
                            Defective sectors do not have a valid LBA and will be skipped
                            when accessing consecutive LBAs.  System Area sectors are
                            number similarly starting with 0.
    
          dddddddd          is the Physical Block Address (PBA) of the sector within the
                            User or System Area.  All User Area sectors (including spare
                            and defective sectors) are numbered consecutively starting
                            with zero.  System Area sectors are number similarly starting
                            with 0.
    
          eeee              is the Logical Sector address where Logical Sectors do not
                            include defective sectors that have been slipped or unused
                            spares.
    
          ffff              is the Physical Sector address where Physical Sectors include
                            all of the sectors on the track (including those marked as
                            defective).  It should be noted that the Physical Sector address
                            is skewed from index.  This means that the first sector following
                            index is not guaranteed to be Physical Sector 0 and may be the
                            second half of split sector.
    
          gggg              is the number of the Servo Burst preceeding the data wedge
                            that contains the sector.
    
          hhhhhhhh          is the offset in NRZ Symbols from Index.
    
    If the sector is split, the following additional information will be displayed.
    
          " Split ppp:qqq bytes at Burst rrrrrr"
    
       where
    
          ppp               is the number of bytes before the split.
    
          qqq               is the number of bytes after the split.
    
          rrrrrr            is the number of the servo burst that splits the sector.
    
    

  <b><i><u>Revision History:</u></i></b>
<a name="TRANSLATE_PHYSICAL_SECTOR_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0002.0000   Added Nominal Cylinder and Radius to the Track Info output.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="TRANSLATE_PLP_CHS_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Translate Physical Cylinder, Logical Head and Physical Sector"></a><hr align=left width="75%"><b> Translate Physical Cylinder, Logical Head and Physical Sector (Level A 'd')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command translates the specified PLP CHS (Physical Cylinder, Logical Head and
    Physical Sector) address to the following:

       - LBA (Logical Block Address)
       - PBA (Physical Block Address)
       - LLL CHS (Logical Cylinder, Logical Head and Logical Sector)
       - Wedge Address
       - Symbols From Index
       - Zone Number

  <b><i><u>Quick Help:</u></i></b>
<a name="TRANSLATE_PLP_CHS_QUICK_HELP"></a>
    "XlatePlpChs, d[Cyl],[Hd],[Sec],[NumSecs]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="TRANSLATE_PLP_CHS_PARM"></a>
    0 - Physical Cylinder Address.
    
        This parameter specifies the Physical Cylinder Address to be translated.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: 0
    
    1 - Logical Head Address.
    
        This parameter specifies the Logical Head Address to be translated.
    
          Type:    Unsigned 8-bit value
    
          Range:   0 to 0xFF
    
          Default: 0
    
    2 - Physical Sector Address.
    
        This parameter specifies the Physical Sector Address to be translated.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to maximum physical sector address on specified track
    
          Default: 0
    
    3 - Physical Sector Count.
    
        This value will specify the number of consecutive Physical Sectors to be translated.
        (Note: The value entered will be limited to the Physical Sectors remaining on the
        track.)
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xffffffff
    
          Default: 1
    

  <b><i><u>Output Data:</u></i></b>
<a name="TRANSLATE_ADDR_DATA"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
        If no error occurred, the track information will be displayed as follows.
    
<a name="TRACK_INFO"></a>
    
       "Track Info:"
       "Partition PhyCyl   LogCyl   NomCyl   Radius_mils LogHd Zn FirstLba FirstPba LogSecs PhySecs WdgSkw SecPerFrm WdgPerFrm"
       "User      cccccccc dddddddd nnnnnnnn o.ooooooEoo ee    ff gggggggg hhhhhhhh iiii    jjjj    kkkk   llll      mmmm"        or
       "System    cccccccc dddddddd nnnnnnnn o.ooooooEoo ee    ff gggggggg hhhhhhhh iiii    jjjj    kkkk   llll      mmmm"
    
    where
    
       cccccccc          is the Logical Cylinder address where Logical Cylinders do not
                         include the cylinders in other partitions.
    
       dddddddd          is the Physical Cylinder address where Physical Cylinders
                         include User Area Cylinders, System Area Cylinders and Spare
                         Cylinders.
    
       ee                is the Logical Head address where Logical Heads do not
                         include heads that have been depopulated.
    
       ff                is the number of the zone that contains the track.
    
       gggggggg          is the first Logical Block Address (LBA) on the track.
    
       hhhhhhhh          is the first Physical Block Address (PBA) on the track.
    
       iiii              is the number of logical sectors on the track.
    
       jjjj              is the number of physical sectors on the track.
    
       kkkk              is the skew in wedges from index to the wedge that contains
                         physical sector 0.
    
       llll              is the number of physical sectors per frame.
    
       mmmm              is the number of wedges per frame.
    
       nnnnnnnn          is the Nominal Cylinder address where Nominal Cylinders
                         remove the VBAR scaling factor.
    
       o.ooooooEoo       is the Radius in milliinches as measured from the hub.
    
    
        This will be followed by the sector information which will be displayed as follows.
    
<a name="SECTOR_INFO"></a>
    
          "Sector Info:"
          "LBA      PBA      LogSec PhySec Wdg  SFI     "
          "cccccccc dddddddd eeee   ffff   gggg hhhhhhhh"
    
       where
    
          cccccccc          is the Logical Block Address (LBA) of the sector within the
                            User or System Area.  All non-defective, non-spare User Area
                            sectors are numbered consecutively starting with zero.
                            Defective sectors do not have a valid LBA and will be skipped
                            when accessing consecutive LBAs.  System Area sectors are
                            number similarly starting with 0.
    
          dddddddd          is the Physical Block Address (PBA) of the sector within the
                            User or System Area.  All User Area sectors (including spare
                            and defective sectors) are numbered consecutively starting
                            with zero.  System Area sectors are number similarly starting
                            with 0.
    
          eeee              is the Logical Sector address where Logical Sectors do not
                            include defective sectors that have been slipped or unused
                            spares.
    
          ffff              is the Physical Sector address where Physical Sectors include
                            all of the sectors on the track (including those marked as
                            defective).  It should be noted that the Physical Sector address
                            is skewed from index.  This means that the first sector following
                            index is not guaranteed to be Physical Sector 0 and may be the
                            second half of split sector.
    
          gggg              is the number of the Servo Burst preceeding the data wedge
                            that contains the sector.
    
          hhhhhhhh          is the offset in NRZ Symbols from Index.
    
    If the sector is split, the following additional information will be displayed.
    
          " Split ppp:qqq bytes at Burst rrrrrr"
    
       where
    
          ppp               is the number of bytes before the split.
    
          qqq               is the number of bytes after the split.
    
          rrrrrr            is the number of the servo burst that splits the sector.
    
    

  <b><i><u>Revision History:</u></i></b>
<a name="TRANSLATE_PLP_CHS_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0002.0000   Added Nominal Cylinder and Radius to the Track Info output.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="TRANSLATE_PLP_CHW_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Translate Physical Cylinder, Logical Head and Physical Wedge"></a><hr align=left width="75%"><b> Translate Physical Cylinder, Logical Head and Physical Wedge (Level A 'f')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command translates the specified PLP CHW (Physical Cylinder, Logical Head and
    Physical Wedge) address to the following:

       - LBA (Logical Block Address)
       - PBA (Physical Block Address)
       - LLL CHS (Logical Cylinder, Logical Head and Logical Sector)
       - PLP CHS (Physical Cylinder, Logical Head and Physical Sector)
       - Symbols From Index
       - Zone Number

  <b><i><u>Quick Help:</u></i></b>
<a name="TRANSLATE_PLP_CHW_QUICK_HELP"></a>
    "XlatePlpChw, f[Cyl],[Hd],[Wdg],[NumWdgs]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="TRANSLATE_PLP_CHW_PARM"></a>
    0 - Physical Cylinder Address.
    
        This parameter specifies the Physical Cylinder Address to be translated.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: 0
    
    1 - Logical Head Address.
    
        This parameter specifies the Logical Head Address to be translated.
    
          Type:    Unsigned 8-bit value
    
          Range:   0 to 0xFF
    
          Default: 0
    
    2 - Physical Wedge Address.
    
        This parameter specifies the Physical Wedge Address to be translated.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to maximum physical wedge address on specified track
    
          Default: 0
    
    3 - Wedge Count.
    
        This value will specify the number of consecutive Wedges to be translated.  (Note:
        The value entered will be limited to the Wedges remaining on the track.)
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xffffffff
    
          Default: 1
    

  <b><i><u>Output Data:</u></i></b>
<a name="TRANSLATE_ADDR_DATA"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
        If no error occurred, the track information will be displayed as follows.
    
<a name="TRACK_INFO"></a>
    
       "Track Info:"
       "Partition PhyCyl   LogCyl   NomCyl   Radius_mils LogHd Zn FirstLba FirstPba LogSecs PhySecs WdgSkw SecPerFrm WdgPerFrm"
       "User      cccccccc dddddddd nnnnnnnn o.ooooooEoo ee    ff gggggggg hhhhhhhh iiii    jjjj    kkkk   llll      mmmm"        or
       "System    cccccccc dddddddd nnnnnnnn o.ooooooEoo ee    ff gggggggg hhhhhhhh iiii    jjjj    kkkk   llll      mmmm"
    
    where
    
       cccccccc          is the Logical Cylinder address where Logical Cylinders do not
                         include the cylinders in other partitions.
    
       dddddddd          is the Physical Cylinder address where Physical Cylinders
                         include User Area Cylinders, System Area Cylinders and Spare
                         Cylinders.
    
       ee                is the Logical Head address where Logical Heads do not
                         include heads that have been depopulated.
    
       ff                is the number of the zone that contains the track.
    
       gggggggg          is the first Logical Block Address (LBA) on the track.
    
       hhhhhhhh          is the first Physical Block Address (PBA) on the track.
    
       iiii              is the number of logical sectors on the track.
    
       jjjj              is the number of physical sectors on the track.
    
       kkkk              is the skew in wedges from index to the wedge that contains
                         physical sector 0.
    
       llll              is the number of physical sectors per frame.
    
       mmmm              is the number of wedges per frame.
    
       nnnnnnnn          is the Nominal Cylinder address where Nominal Cylinders
                         remove the VBAR scaling factor.
    
       o.ooooooEoo       is the Radius in milliinches as measured from the hub.
    
    
        This will be followed by the sector information which will be displayed as follows.
    
<a name="SECTOR_INFO"></a>
    
          "Sector Info:"
          "LBA      PBA      LogSec PhySec Wdg  SFI     "
          "cccccccc dddddddd eeee   ffff   gggg hhhhhhhh"
    
       where
    
          cccccccc          is the Logical Block Address (LBA) of the sector within the
                            User or System Area.  All non-defective, non-spare User Area
                            sectors are numbered consecutively starting with zero.
                            Defective sectors do not have a valid LBA and will be skipped
                            when accessing consecutive LBAs.  System Area sectors are
                            number similarly starting with 0.
    
          dddddddd          is the Physical Block Address (PBA) of the sector within the
                            User or System Area.  All User Area sectors (including spare
                            and defective sectors) are numbered consecutively starting
                            with zero.  System Area sectors are number similarly starting
                            with 0.
    
          eeee              is the Logical Sector address where Logical Sectors do not
                            include defective sectors that have been slipped or unused
                            spares.
    
          ffff              is the Physical Sector address where Physical Sectors include
                            all of the sectors on the track (including those marked as
                            defective).  It should be noted that the Physical Sector address
                            is skewed from index.  This means that the first sector following
                            index is not guaranteed to be Physical Sector 0 and may be the
                            second half of split sector.
    
          gggg              is the number of the Servo Burst preceeding the data wedge
                            that contains the sector.
    
          hhhhhhhh          is the offset in NRZ Symbols from Index.
    
    If the sector is split, the following additional information will be displayed.
    
          " Split ppp:qqq bytes at Burst rrrrrr"
    
       where
    
          ppp               is the number of bytes before the split.
    
          qqq               is the number of bytes after the split.
    
          rrrrrr            is the number of the servo burst that splits the sector.
    
    

  <b><i><u>Revision History:</u></i></b>
<a name="TRANSLATE_PLP_CHW_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0002.0000   Added Nominal Cylinder and Radius to the Track Info output.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="TRANSLATE_SYMBOLS_FROM_INDEX_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Translate Symbols From Index"></a><hr align=left width="75%"><b> Translate Symbols From Index (Level A 'D')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This function translates the specified Physical Cylinder, Logical Head, Starting Symbol
    Offset from Index and Symbol Length to the following:

       - LBA (Logical Block Address)
       - PBA (Physical Block Address)
       - LLL CHS (Logical Cylinder, Logical Head and Logical Sector)
       - PLP CHS (Physical Cylinder, Logical Head and Physical Sector)
       - Sector Span
       - Wedge Address
       - Wedge Span
       - Zone Number

  <b><i><u>Quick Help:</u></i></b>
<a name="TRANSLATE_SYMBOLS_FROM_INDEX_QUICK_HELP"></a>
    "XlateSfi, D[PhyCyl],[Hd],[Sfi],[NumSfis]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="TRANSLATE_SYMBOLS_FROM_INDEX_PARM"></a>
    0 - Physical Cylinder Address.
    
        This parameter specifies the Physical Cylinder Address to be translated.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: 0
    
    1 - Logical Head Address.
    
        This parameter specifies the Logical Head Address to be translated.
    
          Type:    Unsigned 8-bit value
    
          Range:   0 to 0xFF
    
          Default: 0
    
    2 - Symbol From Index.
    
        This parameter specifies the Symbol From Index to be translated.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: 0
    
    2 - Length In Symbols.
    
        This parameter specifies the length in symbols to be translated.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: 1
    

  <b><i><u>Output Data:</u></i></b>
<a name="TRANSLATE_EXTENT_ADDR_DATA"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
        If no error occurred, the track information will be displayed as follows.
    
<a name="TRACK_INFO"></a>
    
       "Track Info:"
       "Partition PhyCyl   LogCyl   NomCyl   Radius_mils LogHd Zn FirstLba FirstPba LogSecs PhySecs WdgSkw SecPerFrm WdgPerFrm"
       "User      cccccccc dddddddd nnnnnnnn o.ooooooEoo ee    ff gggggggg hhhhhhhh iiii    jjjj    kkkk   llll      mmmm"        or
       "System    cccccccc dddddddd nnnnnnnn o.ooooooEoo ee    ff gggggggg hhhhhhhh iiii    jjjj    kkkk   llll      mmmm"
    
    where
    
       cccccccc          is the Logical Cylinder address where Logical Cylinders do not
                         include the cylinders in other partitions.
    
       dddddddd          is the Physical Cylinder address where Physical Cylinders
                         include User Area Cylinders, System Area Cylinders and Spare
                         Cylinders.
    
       ee                is the Logical Head address where Logical Heads do not
                         include heads that have been depopulated.
    
       ff                is the number of the zone that contains the track.
    
       gggggggg          is the first Logical Block Address (LBA) on the track.
    
       hhhhhhhh          is the first Physical Block Address (PBA) on the track.
    
       iiii              is the number of logical sectors on the track.
    
       jjjj              is the number of physical sectors on the track.
    
       kkkk              is the skew in wedges from index to the wedge that contains
                         physical sector 0.
    
       llll              is the number of physical sectors per frame.
    
       mmmm              is the number of wedges per frame.
    
       nnnnnnnn          is the Nominal Cylinder address where Nominal Cylinders
                         remove the VBAR scaling factor.
    
       o.ooooooEoo       is the Radius in milliinches as measured from the hub.
    
    
        This will be followed by the sector information which will be displayed as follows.
    
<a name="SECTOR_EXTENT_INFO"></a>
    
          "Sector Info:"
          "LBA      PBA      LogSec PhySec Wdg  SFI      SymLen   SecLen WdgLen"
          "cccccccc dddddddd eeee   ffff   gggg hhhhhhhh iiiiiiii jjjjjj kkkkkk"
    
       where
    
          cccccccc          is the Logical Block Address (LBA) of the sector within the
                            User or System Area.  All non-defective, non-spare User Area
                            sectors are numbered consecutively starting with zero.
                            Defective sectors do not have a valid LBA and will be skipped
                            when accessing consecutive LBAs.  System Area sectors are
                            number similarly starting with 0.
    
          dddddddd          is the Physical Block Address (PBA) of the sector within the
                            User or System Area.  All User Area sectors (including spare
                            and defective sectors) are numbered consecutively starting
                            with zero.  System Area sectors are number similarly starting
                            with 0.
    
          eeee              is the Logical Sector address where Logical Sectors do not
                            include defective sectors that have been slipped or unused
                            spares.
    
          ffff              is the Physical Sector address where Physical Sectors include
                            all of the sectors on the track (including those marked as
                            defective).  It should be noted that the Physical Sector address
                            is skewed from index.  This means that the first sector following
                            index is not guaranteed to be Physical Sector 0 and may be the
                            second half of split sector.
    
          gggg              is the number of the Servo Burst preceeding the data wedge
                            that contains the sector.
    
          hhhhhhhh          is the offset in NRZ Symbols from Index.
    
          iiiiiiii          is the length in NRZ Symbols.
    
          jjjjjj            is the number of consecutive Physical Sectors that contain one
                            or more of the specified Symbols.
    
          kkkkkk            is the number of consecutive data wedges that contain one or more
                            of the specified symbols.
    
    If the sector is split, the following additional information will be displayed.
    
          " Split ppp:qqq bytes at Burst rrrrrr"
    
       where
    
          ppp               is the number of bytes before the split.
    
          qqq               is the number of bytes after the split.
    
          rrrrrr            is the number of the servo burst that splits the sector.
    
    

  <b><i><u>Revision History:</u></i></b>
<a name="TRANSLATE_SYMBOLS_FROM_INDEX_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="TRANSLATE_WEDGE_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Translate Wedge"></a><hr align=left width="75%"><b> Translate Wedge (Level 2 't')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command translates the specified Physical Wedge address on the current track to
    the following:

       - LBA (Logical Block Address)
       - PBA (Physical Block Address)
       - LLL CHS (Logical Cylinder, Logical Head and Logical Sector)
       - PLP CHS (Physical Cylinder, Logical Head and Physical Sector)
       - Symbols From Index
       - Zone Number

  <b><i><u>Quick Help:</u></i></b>
<a name="TRANSLATE_WEDGE_QUICK_HELP"></a>
    "XlateWedge, t[Wdg],[NumWdgs]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="TRANSLATE_WEDGE_PARM"></a>
    0 - Physical Wedge Address.
    
        This parameter specifies the Physical Wedge Address to be translated.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to maximum physical wedge address on specified track
    
          Default: 0
    
    1 - Wedge Count.
    
        This value will specify the number of consecutive Wedges to be translated.  (Note:
        The value entered will be limited to the Wedges remaining on the track.)
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xffffffff
    
          Default: 1
    

  <b><i><u>Output Data:</u></i></b>
<a name="TRANSLATE_ADDR_DATA"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
        If no error occurred, the track information will be displayed as follows.
    
<a name="TRACK_INFO"></a>
    
       "Track Info:"
       "Partition PhyCyl   LogCyl   NomCyl   Radius_mils LogHd Zn FirstLba FirstPba LogSecs PhySecs WdgSkw SecPerFrm WdgPerFrm"
       "User      cccccccc dddddddd nnnnnnnn o.ooooooEoo ee    ff gggggggg hhhhhhhh iiii    jjjj    kkkk   llll      mmmm"        or
       "System    cccccccc dddddddd nnnnnnnn o.ooooooEoo ee    ff gggggggg hhhhhhhh iiii    jjjj    kkkk   llll      mmmm"
    
    where
    
       cccccccc          is the Logical Cylinder address where Logical Cylinders do not
                         include the cylinders in other partitions.
    
       dddddddd          is the Physical Cylinder address where Physical Cylinders
                         include User Area Cylinders, System Area Cylinders and Spare
                         Cylinders.
    
       ee                is the Logical Head address where Logical Heads do not
                         include heads that have been depopulated.
    
       ff                is the number of the zone that contains the track.
    
       gggggggg          is the first Logical Block Address (LBA) on the track.
    
       hhhhhhhh          is the first Physical Block Address (PBA) on the track.
    
       iiii              is the number of logical sectors on the track.
    
       jjjj              is the number of physical sectors on the track.
    
       kkkk              is the skew in wedges from index to the wedge that contains
                         physical sector 0.
    
       llll              is the number of physical sectors per frame.
    
       mmmm              is the number of wedges per frame.
    
       nnnnnnnn          is the Nominal Cylinder address where Nominal Cylinders
                         remove the VBAR scaling factor.
    
       o.ooooooEoo       is the Radius in milliinches as measured from the hub.
    
    
        This will be followed by the sector information which will be displayed as follows.
    
<a name="SECTOR_INFO"></a>
    
          "Sector Info:"
          "LBA      PBA      LogSec PhySec Wdg  SFI     "
          "cccccccc dddddddd eeee   ffff   gggg hhhhhhhh"
    
       where
    
          cccccccc          is the Logical Block Address (LBA) of the sector within the
                            User or System Area.  All non-defective, non-spare User Area
                            sectors are numbered consecutively starting with zero.
                            Defective sectors do not have a valid LBA and will be skipped
                            when accessing consecutive LBAs.  System Area sectors are
                            number similarly starting with 0.
    
          dddddddd          is the Physical Block Address (PBA) of the sector within the
                            User or System Area.  All User Area sectors (including spare
                            and defective sectors) are numbered consecutively starting
                            with zero.  System Area sectors are number similarly starting
                            with 0.
    
          eeee              is the Logical Sector address where Logical Sectors do not
                            include defective sectors that have been slipped or unused
                            spares.
    
          ffff              is the Physical Sector address where Physical Sectors include
                            all of the sectors on the track (including those marked as
                            defective).  It should be noted that the Physical Sector address
                            is skewed from index.  This means that the first sector following
                            index is not guaranteed to be Physical Sector 0 and may be the
                            second half of split sector.
    
          gggg              is the number of the Servo Burst preceeding the data wedge
                            that contains the sector.
    
          hhhhhhhh          is the offset in NRZ Symbols from Index.
    
    If the sector is split, the following additional information will be displayed.
    
          " Split ppp:qqq bytes at Burst rrrrrr"
    
       where
    
          ppp               is the number of bytes before the split.
    
          qqq               is the number of bytes after the split.
    
          rrrrrr            is the number of the servo burst that splits the sector.
    
    

  <b><i><u>Revision History:</u></i></b>
<a name="TRANSLATE_WEDGE_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0002.0000   Added Nominal Cylinder and Radius to the Track Info output.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="WRITE_CHS_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Write CHS"></a><hr align=left width="75%"><b> Write CHS (Levels 2, 7 'W')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command writes data to the disk starting at the specified sector on the target
    track for the specified number of sectors.  The sectors are written with the data
    contained in the Diagnostic Write Buffer.

  <b><i><u>Quick Help:</u></i></b>
<a name="WRITE_CHS_QUICK_HELP"></a>
    "WrChs, W[Sec],[NumSecs],,[PhyOpt],[Opts]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="WRITE_CHS_PARM"></a>
     0 - Logical or Physical Sector Address.
    
         If any value is entered for Parameter 3, this parameter contains the physical
         sector address of the first sector to write, else this parameter contains the
         User Area logical sector address of the first sector to write.
    
           Type:    Unsigned 16-bit value
    
           Range:   0 to maximum logical or physical sector address on the target track
    
           Default: 0
    
     1 - Transfer Length.
    
         This parameter specifies the number of consecutive sectors to write.
    
           Type:    Unsigned 32-bit value
    
           Range:   0 to 0xFFFFFFFF
    
           Default: If the Sector Address was entered and the Transfer Length was not entered,
                    then only the specified sector will be written.
    
                    If both the Sector Address and Transfer Length are not entered, then the
                    Transfer Length will be set based on the Test Space that is selected.
                    If the Random Transfer Length option is selected, a random value will be
                    used that is less than or equal to the number of sectors remaining on the
                    track.  If the Random Transfer Length option is not selected, the number
                    of sectors remaining on the track will be written.
    
                    If a Transfer Length is entered, it will be limited to the number of
                    sectors remaining on the track.
    
    <font color=red>
     2 - not used.
    
           Type:    None
    
           Range:   None
    
           Default: None
    
    </font>
     3 - Physical Sector Address Flag.
       
         If any value is entered for this parameter, then Parameter 0 specifies a physical
         sector address, else Parameter 0 specifies a User Area logical sector address.
    
           Type:    Unsigned 16-bit value
    
           Range:   0 to 0xFFFF
    
           Default: None
    
     4 - Options.
    
         This parameter is a bit-significant value that allows the user to select the
         following options.
    
           Bits 15-5:  not used.
    
           Bit 4:      Write All Test Space Sectors.
    
                       If this bit is set, all of the sectors in the Test Space will be
                       written, else only the sectors specified by Parameters 0 and 1 will
                       be written.
    
           Bit 3:      not used.
     
           Bit 2:      Rotate Buffer Sector Offset.
     
                       If this bit is set, the Target Buffer Sector Offset will be rotated
                       by 1 prior to the execution of this diagnostic command.
                       This bit was originally added to help writing random data pattern
                       reduce execution time by not having to re-fill the diagnostic buffer
                       with new random data pattern, which takes great amount of time,
                       but just rotating the Target Buffer Sector Offset at every time this
                       diagnostic command is executed with this option set.
                       To see or change the current Targer Buffer Sector Offset, please refer
                       all Level 'A', Set Test Space, diagnostic command for detail how-to.
    
    <font color=red>
           Bit 1:      Enable Dynamic Sparing.
    
                       If this bit is set, sectors containing media defects that meet
                       the failure criteria will be spared.
    </font>
    
           Bit 0:      Continue On Error.
     
                       If this bit is set and an error occurs, the write operation will
                       continue and attempt to write all of the requested sectors.  Each
                       error encountered will be displayed.
    
           Type:    Unsigned 16-bit value
    
           Range:   0 to 0xFFFF
    
           Default: 0    (Write the requested sectors,
                          Stop On Error)
    

  <b><i><u>Output Data:</u></i></b>
<a name="RW_OP_STATUS_OUTPUT_DATA"></a>
        If an error occurred, the following information will be displayed.
    
              "DiagError aaaaaaaa R/W Status c R/W Error dddddddd"
    
           and
    
              "Next User LBA eeeeeeee LLL CHS ffffff.g.hhhh PLP CHS iiiiii.j.kkkk"
              "Remaining Transfer Length llllllll"
    
           or
    
              "Next System LBA eeeeeeee LLL CHS ffffff.g.hhhh PLP CHS iiiiii.j.kkkk"
              "Remaining Transfer Length llllllll"
    
           where
    
              aaaaaaaa is the Diagnostic Error Code
    
              c is the status returned by the R/W subsystem
    
                    0 = R/W request completed successfully with error recovery
                    1 = R/W request completed successfully (no error recovery performed)
                    2 = R/W request failed
    
              dddddddd is the error code returned by the R/W subsystem
    
              eeeeeeee is the Disk Logical Block Address of the sector in error
    
              ffffff is the Logical Cylinder Address of the sector in error
    
              g is the Logical Head Address of the sector in error
    
              hhhh is the Logical Sector Address of the sector in error
    
              iiiiii is the Physical Cylinder Address of the sector in error
    
              j is the Logical Head Address of the sector in error
    
              kkkk is the Physical Sector Address of the sector in error
    
              llllllll is the number of sectors remaining to be read or written
    
        If the Verbose Formatted ASCII Data Output Mode is selected, the Verbose Mode option
        bits will enable the following data to be output when set.
    
           Bit 0:      Enables the R/W Status and R/W Error to be displayed
           Bit 1:      Enable the Next Address to be displayed
           Bit 2:      Enables the Track Position and Track Follow Offset to be displayed
           Bit 3:      Enables the Target Address to be displayed
           Bit 4:      Enables the Recovery Status to be displayed
           Bit 5:      Enables the Fault Status to be displayed
           Bit 6:      Enables the Elapsed Time to be displayed
           Bits 31-7:  NA
    
        If Bit 0 is set, the R/W Status and R/W Error will be displayed even if no error
        occurred.  The data displayed will be formatted as shown above.
    
        If Bit 1 is set, the Next Address will be displayed even if no error occurred.  The
        data displayed will be formatted as shown above.
    
        If Bit 2 is set, the Track Position and Track Follow Offset will be displayed as
        follows.
    
              "Read Position, Persistent Offset m.m% Total Offset n.n%"          or
              "Write Position, Persistent Offset m.m% Total Offset n.n%"         or
              "Write Header Position, Persistent Offset m.m% Total Offset n.n%"
    
           where
    
              m.m is the Persistent Track Follow Offset in units of percentage of track width
    
              n.n is the Total Track Follow Offset in units of percentage of track width
    
        If Bit 3 is set, the Target Address will be displayed as follows.
    
              "Target User LBA pppppppp LLL CHS qqqqqq.r.ssss PLP CHS tttttt.u.vvvv"
              "Starting Transfer Length wwwwwwww"
    
           or
    
              "Target System LBA pppppppp LLL CHS qqqqqq.r.ssss PLP CHS tttttt.u.vvvv"
              "Starting Transfer Length wwwwwwww"
    
           where
    
              pppppppp is the starting Disk Logical Block Address
    
              qqqqqq is the starting Logical Cylinder Address
    
              r is the starting Logical Head Address
    
              ssss is the starting Logical Sector Address
    
              tttttt is the starting Physical Cylinder Address
    
              u is the starting Logical Head Address
    
              vvvv is the starting Physical Sector Address
    
              wwwwwwww is the starting Transfer Length
    
        If Bit 4 is set, the Recovery Status will be displayed as follows.
    
              "Recovered User LBA AAAAAAAA LLL CHS BBBBBB.C.DDDD PLP CHS EEEEEE.F.GGGG"
              "Recovery Flags HHHH Count II"
    
           or
    
              "Recovered System LBA AAAAAAAA LLL CHS BBBBBB.C.DDDD PLP CHS EEEEEE.F.GGGG"
              "Recovery Flags HHHH Count II"
    
           where
    
              AAAAAAAA is the Disk Logical Block Address of the last recovered sector
    
              BBBBBB is the Logical Cylinder Address of the last recovered sector
    
              C is the Logical Head Address of the last recovered sector
    
              DDDD is the Logical Sector Address of the last recovered sector
    
              EEEEEE is the Physical Cylinder Address of the last recovered sector
    
              F is the Logical Head Address of the last recovered sector
    
              GGGG is the Physical Sector Address of the last recovered sector
    
              HHHH are the Recovery Flags reported by the Read/Write code
    
              II is the Recovery Count reported by the Read/Write code
    
        If Bit 5 is set, the Fault Status will be displayed as follows.
    
              "Drive Fault Status JJJJ Preamp Fault Status KKKK"
    
           where
    
              JJJJ is the Drive Fault Status reported by the Read/Write code
    
              KKKK is the Preamp Fault Status reported by the Read/Write code
    
        If Bit 6 is set, the Elapsed Time for the read/write operation will be displayed.
<a name="ELAPSED_TIME"></a>
    
       "Elapsed Time a mins b secs"  or
       "Elapsed Time b.c secs"       or
       "Elapsed Time c.d msecs"
    
    where
    
       a is minutes
       b is seconds
       c is milliseconds
       d is microseconds
    
    

  <b><i><u>Examples:</u></i></b>
    Example #1:
       To write a single logical sector
       (in this case logical sector 23 on logical cylinder 45 head 1)

          F3 2>A0
          F3 2>S45,1
          F3 2>W23

    Example #2:
       To write multiple logical sectors
       (in this case logical sectors 23 to 26 on logical cylinder 45 head 1)

          F3 2>A0
          F3 2>S45,1
          F3 2>W23,4

    Example #3:
       To write all of the logical sectors on a track
       (in this case all logical sectors on logical cylinder 45 head 1)

          F3 2>A0
          F3 2>S45,1
          F3 2>W

    Example #4:
       To write all of the logical sectors on multiple tracks
       (in this case all logical sectors on logical cylinders 45 to 49 head 0)

       Note: You must seek to the track before the first one to be written.

          F3 2>A3
          F3 2>S44,0
          F3 2>L,5
          F3 2>W

    Example #5:
       To write all of the logical sectors on a track and continue on error
       (in this case all logical sectors on logical cylinder 45 head 0)

       Note: An error message will be displayed for each sector in error.

          F3 2>A0
          F3 2>S45,0
          F3 2>W,,,,1

    Example #6:
       To write all of the logical sectors in the test space and continue on error

       Note: The Test Space is selected by the all level 'A' command.  An error
       message will be displayed for each sector in error.

          F3 2>W,,,,11

    Example #7:
       To write a single physical sector
       (in this case physical sector 32 on physical cylinder 54 head 0)

          F3 2>A0
          F3 2>s54,0,22
          F3 2>W32,,,1

    Example #8:
       To write multiple physical sectors
       (in this case physical sectors 32 to 35 on physical cylinder 54 head 0)

          F3 2>A0
          F3 2>s54,0,22
          F3 2>W32,4,,1

    Example #9:
       To write all of the physical sectors on a track
       (in this case all physical sectors on physical cylinder 54 head 0)

          F3 2>A0
          F3 2>s54,0,22
          F3 2>W,,,1

    Example #10:
       To write a single logical sector with data at a specific sector offset in the
       diagnostic write buffer
       (in this case logical sector 23 on logical cylinder 45 head 1,
        with data at the sector offset of 5 in the diagnostic write buffer)

          F3 2>A0
          F3 2>AF,5
          F3 2>S45,1
          F3 2>W23

    Example #11:
       To rotate the buffer sector offset by 1 and write a single logical sector with data at
       the rotated sector offset in the diagnostic write buffer
       (This example assumes user ran the Example #10 above right before this example,
        in this case logical sector 24 on logical cylinder 45 head 1,
        with data at the sector offset of 6 in the diagnostic write buffer)

          F3 2>W24,,,,4

  <b><i><u>Revision History:</u></i></b>
<a name="WRITE_CHS_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0001.0001   Eliminated the Enable ZAP Updates and Enable Track Skipping option.
    0001.0002   Moved the Enable Dynamic Sparing option from the parameter 2 to the bit 1 of
                the parameter 4.
                Added new Rotate Buffer Sector Offset option to the bit 2 of the parameter 4.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="WRITE_LBA_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Write LBA"></a><hr align=left width="75%"><b> Write LBA (Level A 'W')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command writes data to the disk starting at the specified LBA (Logical Block
    Address) for the specified number of LBAs.  The data is written from the Diagnostic
    Write Buffer.

  <b><i><u>Quick Help:</u></i></b>
<a name="WRITE_LBA_QUICK_HELP"></a>
    "WrLba, W[Lba],[NumLbas],,[Opts]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="WRITE_LBA_PARM"></a>
     0 - LBA.
    
         If Parameter 3 bit 5 is set, then this parameter specifies the address of the first
         System Area LBA to be written, else it specifies the address of the first User Area
         LBA to be written.
    
           Type:    Unsigned 32-bit value
    
           Range:   0 to maximum User Area LBA, if parameter 3 bit 5 is set
                    0 to maximum System Area LBA, if parameter 3 bit 5 is cleared
    
           Default: Current Target Address
    
     1 - Transfer Length.
    
         This parameter specifies the number of consecutive LBAs to written.
    
           Type:    Unsigned 32-bit value
    
           Range:   0 to 0xFFFFFFFF
    
           Default: If the LBA (Parameter 0) was entered and the Transfer Length (Parameter 1)
                    was not entered, then only the specified LBA will be written.
    
                    If both the LBA (Parameter 0) and Transfer Length (Parameter 1) are not
                    entered, then the Transfer Length will be set based on the Test Space
                    that is selected.  If the Random Transfer Length option is selected, a
                    random value will be used that is less than or equal to the number of LBAs
                    remaining in the Test Space.  If the Random Transfer Length option is not
                    selected, the number of LBAs remaining on the track containing the current
                    Target LBA will be written.
    
                    If a Transfer Length is entered, it will be limited to the number of
                    LBAs remaining in the Test Space.
    
    <font color=red>
     2 - not used.
    
         In the ST-10 code, entering this parameter enables a 512-byte block to be
         written even if it is marked as alternated or pending.  This feature was added
         as part of the support for block sizes greater than 512-bytes.  This feature is
         not currently supported by the platform architecture.
    
           Type:    None
    
           Range:   None
    
           Default: None
    
    </font>
     3 - Options.
    
         This parameter is a bit-significant value that allows the user to select the
         following options.
    
           Bits 15-6:  not used.
    
           Bit 5:      Write System Area LBAs.
    
                       If this bit is set, then parameter 0 specifies a System Area LBA,
                       else parameter 0 specifies a User Area LBA.
    
           Bit 4:      Write All Test Space LBAs.
    
                       If this bit is set, all of the LBAs in the Test Space will be
                       written, else only the LBAs specified by Parameters 0 and 1 will
                       be written.
    
           Bits 3-2:   not used.
    
    <font color=red>
           Bit 1:      Enable Dynamic Sparing.
    
                       If this bit is set, sectors containing media defects that meet
                       the failure criteria will be spared.
    </font>
    
           Bit 0:      Continue On Error.
     
                       If this bit is set and an error occurs, the write operation will
                       continue and attempt to write all of the requested LBA.  Each error
                       encountered will be displayed.
    
           Type:    Unsigned 16-bit value
    
           Range:   0 to 0xFFFF
    
           Default: 0    (Write User Area LBAs,
                          Write the requested sectors,
                          Disable Dynamic Sparing,
                          Stop On Error)
    

  <b><i><u>Output Data:</u></i></b>
<a name="RW_OP_STATUS_OUTPUT_DATA"></a>
        If an error occurred, the following information will be displayed.
    
              "DiagError aaaaaaaa R/W Status c R/W Error dddddddd"
    
           and
    
              "Next User LBA eeeeeeee LLL CHS ffffff.g.hhhh PLP CHS iiiiii.j.kkkk"
              "Remaining Transfer Length llllllll"
    
           or
    
              "Next System LBA eeeeeeee LLL CHS ffffff.g.hhhh PLP CHS iiiiii.j.kkkk"
              "Remaining Transfer Length llllllll"
    
           where
    
              aaaaaaaa is the Diagnostic Error Code
    
              c is the status returned by the R/W subsystem
    
                    0 = R/W request completed successfully with error recovery
                    1 = R/W request completed successfully (no error recovery performed)
                    2 = R/W request failed
    
              dddddddd is the error code returned by the R/W subsystem
    
              eeeeeeee is the Disk Logical Block Address of the sector in error
    
              ffffff is the Logical Cylinder Address of the sector in error
    
              g is the Logical Head Address of the sector in error
    
              hhhh is the Logical Sector Address of the sector in error
    
              iiiiii is the Physical Cylinder Address of the sector in error
    
              j is the Logical Head Address of the sector in error
    
              kkkk is the Physical Sector Address of the sector in error
    
              llllllll is the number of sectors remaining to be read or written
    
        If the Verbose Formatted ASCII Data Output Mode is selected, the Verbose Mode option
        bits will enable the following data to be output when set.
    
           Bit 0:      Enables the R/W Status and R/W Error to be displayed
           Bit 1:      Enable the Next Address to be displayed
           Bit 2:      Enables the Track Position and Track Follow Offset to be displayed
           Bit 3:      Enables the Target Address to be displayed
           Bit 4:      Enables the Recovery Status to be displayed
           Bit 5:      Enables the Fault Status to be displayed
           Bit 6:      Enables the Elapsed Time to be displayed
           Bits 31-7:  NA
    
        If Bit 0 is set, the R/W Status and R/W Error will be displayed even if no error
        occurred.  The data displayed will be formatted as shown above.
    
        If Bit 1 is set, the Next Address will be displayed even if no error occurred.  The
        data displayed will be formatted as shown above.
    
        If Bit 2 is set, the Track Position and Track Follow Offset will be displayed as
        follows.
    
              "Read Position, Persistent Offset m.m% Total Offset n.n%"          or
              "Write Position, Persistent Offset m.m% Total Offset n.n%"         or
              "Write Header Position, Persistent Offset m.m% Total Offset n.n%"
    
           where
    
              m.m is the Persistent Track Follow Offset in units of percentage of track width
    
              n.n is the Total Track Follow Offset in units of percentage of track width
    
        If Bit 3 is set, the Target Address will be displayed as follows.
    
              "Target User LBA pppppppp LLL CHS qqqqqq.r.ssss PLP CHS tttttt.u.vvvv"
              "Starting Transfer Length wwwwwwww"
    
           or
    
              "Target System LBA pppppppp LLL CHS qqqqqq.r.ssss PLP CHS tttttt.u.vvvv"
              "Starting Transfer Length wwwwwwww"
    
           where
    
              pppppppp is the starting Disk Logical Block Address
    
              qqqqqq is the starting Logical Cylinder Address
    
              r is the starting Logical Head Address
    
              ssss is the starting Logical Sector Address
    
              tttttt is the starting Physical Cylinder Address
    
              u is the starting Logical Head Address
    
              vvvv is the starting Physical Sector Address
    
              wwwwwwww is the starting Transfer Length
    
        If Bit 4 is set, the Recovery Status will be displayed as follows.
    
              "Recovered User LBA AAAAAAAA LLL CHS BBBBBB.C.DDDD PLP CHS EEEEEE.F.GGGG"
              "Recovery Flags HHHH Count II"
    
           or
    
              "Recovered System LBA AAAAAAAA LLL CHS BBBBBB.C.DDDD PLP CHS EEEEEE.F.GGGG"
              "Recovery Flags HHHH Count II"
    
           where
    
              AAAAAAAA is the Disk Logical Block Address of the last recovered sector
    
              BBBBBB is the Logical Cylinder Address of the last recovered sector
    
              C is the Logical Head Address of the last recovered sector
    
              DDDD is the Logical Sector Address of the last recovered sector
    
              EEEEEE is the Physical Cylinder Address of the last recovered sector
    
              F is the Logical Head Address of the last recovered sector
    
              GGGG is the Physical Sector Address of the last recovered sector
    
              HHHH are the Recovery Flags reported by the Read/Write code
    
              II is the Recovery Count reported by the Read/Write code
    
        If Bit 5 is set, the Fault Status will be displayed as follows.
    
              "Drive Fault Status JJJJ Preamp Fault Status KKKK"
    
           where
    
              JJJJ is the Drive Fault Status reported by the Read/Write code
    
              KKKK is the Preamp Fault Status reported by the Read/Write code
    
        If Bit 6 is set, the Elapsed Time for the read/write operation will be displayed.
<a name="ELAPSED_TIME"></a>
    
       "Elapsed Time a mins b secs"  or
       "Elapsed Time b.c secs"       or
       "Elapsed Time c.d msecs"
    
    where
    
       a is minutes
       b is seconds
       c is milliseconds
       d is microseconds
    
    

  <b><i><u>Examples:</u></i></b>
    Example #1:
       To write a single LBA
       (in this case LBA 51237)

          F3 A>W51237

    Example #2:
       To write multiple LBAs
       (in this case LBAs 51237 to 51247)

          F3 A>W51237,11

    Example #3:
       To write all of the LBAs remaining on the track containing the target LBA
       (in this case all LBAs remaining on the cylinder that contains LBA 51237)

          F3 A>S51237
          F3 A>W

    Example #4:
       To write all of the LBAs remaining on the track containing the target LBA
       and continue on error
       (in this case all LBAs remaining on the cylinder that contains LBA 51237)

       Note: An error message will be displayed for each LBA in error.

          F3 A>S51237
          F3 A>W,,,1

    Example #5:
       To write all of the LBAs in the test space and continue on error

       Note: The Test Space is selected by the all level 'A' command.  An error
       message will be displayed for each LBA in error.

          F3 A>W,,,11

    Example #6:
       To write a single system LBA
       (in this case system LBA 1237)

          F3 A>W1237,,,20

    Example #7:
       To write multiple system LBAs
       (in this case system LBAs 1237 to 1247)

          F3 A>W1237,11,,20

    Example #8:
       To write all of the LBAs remaining on the track containing the target system LBA
       (in this case all LBAs remaining on the cylinder that contains LBA 1237)

          F3 A>S1237,,,,,1
          F3 A>W,,,20

  <b><i><u>Revision History:</u></i></b>
<a name="WRITE_LBA_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0001.0001   Eliminated the Enable ZAP Updates and Enable Track Skipping option.
    0001.0002   Modified to write only the LBAs remaining on the track containing the
                target LBA, if the LBA and Transfer Length are not entered by the user.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="WRITE_LONG_OR_SYSTEM_CHS_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Write Long CHS or Write System CHS"></a><hr align=left width="75%"><b> Write Long CHS or Write System CHS (Level 2 'w')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command performs either a write long of the specified sectors or a System Area
    write starting at the specified sector on the target track for the specified number
    of sectors.  For a write long operation, the data and ECC bytes will be written from
    the <b>Diagnostic Read Buffer</b>.  For a System Area write, the data will be written from
    the Diagnostic Write Buffer.

  <b><i><u>Quick Help:</u></i></b>
<a name="WRITE_LONG_OR_SYSTEM_CHS_QUICK_HELP"></a>
    "WrLongOrSystemChs, w[LongSec],[LongSecsOrSysSec],[SysSecs],[LongPhySecOpt],,[SysOpts]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="WRITE_LONG_OR_SYSTEM_CHS_PARM"></a>
     0 - Write Long Starting Logical or Physical Sector Address.
    
         If this parameter is entered, a Write Long operation will be performed starting
         at the sector address specified by this parameter.  If any value is entered for
         Parameter 3, this parameter contains a physical sector address, else it contains
         a User Area logical sector address.
    
         If this parameter is not entered, a System Area Write operation will be performed.
    
           Type:    Unsigned 16-bit value
    
           Range:   0 to maximum logical or physical sector address on the target track
    
           Default: none
    
     1 - Write Long Transfer Length / System Area Write Starting Logical Sector Address.
    
         If Parameter 0 is entered, this parameter is the number of consecutive sectors
         to write long.
    
         If Parameter 0 is not entered, then this parameter contains the address of the
         first logical sector to be write on the System Area target track.
    
           Type:    Unsigned 32-bit value
    
           Range:   0 to 0xFFFFFFFF
    
           Default: For a Write Long operation, the default Transfer Length is 1.
    
                    For a System Area Write operation, the default starting Logical
                    Sector Address is 0.
    
     2 - System Area Write Transfer Length.
    
         If Parameter 0 is entered, this parameter is not used.
    
         If Parameter 0 is not entered, this parameter is the number of consecutive
         System Area sectors to write.
    
           Type:    Unsigned 32-bit value
    
           Range:   0 to 0xFFFFFFFF
    
           Default: If the System Area Logical Sector Address was entered and the Transfer
                    Length was not entered, then only the specified sector will be written.
    
                    If both the System Area Logical Sector Address and Transfer Length are
                    not entered, then the Transfer Length will be set based on the Test
                    Space that is selected.  If the Random Transfer Length option is
                    selected, a random value will be used that is less than or equal to
                    the number of sectors remaining on the track.  If the Random Transfer
                    Length option is not selected, the number of sectors remaining on the
                    track will be written.
    
                    If a Transfer Length is entered, it will be limited to the number of
                    sectors remaining on the track.
    
     3 - Write Long Physical Sector Address Flag.
    
         If Parameter 0 is entered and any value is entered for this parameter, then
         Parameter 0 specifies a physical sector address.  If Parameter 0 is entered
         and this parameter is not entered, then Parameter 0 specifies a User Area
         logical sector address.
    
         If Parameter 0 is not entered, then this parameter is not used.
    
           Type:    Unsigned 16-bit value
    
           Range:   0 to 0xFFFF
    
           Default: None
    
     4 - not used.
    
           Type:    None
    
           Range:   None
    
           Default: None
    
     5 - System Area Write Options.
    
         If Parameter 0 is entered, this parameter is not used.
    
         If Parameter 0 is not entered, this parameter is a bit-significant value that
         allows the user to select the following options for a System Area Write operation.
    
           Bits 15-5:  not used.
    
           Bit 4:      Write All Test Space Sectors.
    
                       If this bit is set, all of the System Area Sectors in the Test
                       Space will be written, else only the System Area Sectors specified
                       by Parameters 1 and 2 will be written.
    
           Bit 3:      not used.
     
           Bit 2:      Rotate Buffer Sector Offset.
     
                       If this bit is set, the Target Buffer Sector Offset will be rotated
                       by 1 prior to the execution of this diagnostic command.
                       This bit was originally added to help writing random data pattern
                       reduce execution time by not having to re-fill the diagnostic buffer
                       with new random data pattern, which takes great amount of time,
                       but just rotating the Target Buffer Sector Offset at every time this
                       diagnostic command is executed with this option set.
                       To see or change the current Targer Buffer Sector Offset, please refer
                       all Level 'A', Set Test Space, diagnostic command for detail how-to.
    
    <font color=red>
           Bit 1:      Enable Dynamic Sparing.
    
                       If this bit is set, sectors containing media defects that meet
                       the failure criteria will be spared.
    </font>
    
           Bit 0:      Continue On Error.
    
                       If this bit is set and an error occurs, the write operation will
                       continue and attempt to write all of the requested sectors.  Each
                       error encountered will be displayed.
    
           Type:    Unsigned 16-bit value
    
           Range:   0 to 0xFFFF
    
           Default: 0    (Write the requested sectors,
                          Disable Dynamic Sparing,
                          Stop On Error)
    

  <b><i><u>Output Data:</u></i></b>
<a name="RW_OP_STATUS_OUTPUT_DATA"></a>
        If an error occurred, the following information will be displayed.
    
              "DiagError aaaaaaaa R/W Status c R/W Error dddddddd"
    
           and
    
              "Next User LBA eeeeeeee LLL CHS ffffff.g.hhhh PLP CHS iiiiii.j.kkkk"
              "Remaining Transfer Length llllllll"
    
           or
    
              "Next System LBA eeeeeeee LLL CHS ffffff.g.hhhh PLP CHS iiiiii.j.kkkk"
              "Remaining Transfer Length llllllll"
    
           where
    
              aaaaaaaa is the Diagnostic Error Code
    
              c is the status returned by the R/W subsystem
    
                    0 = R/W request completed successfully with error recovery
                    1 = R/W request completed successfully (no error recovery performed)
                    2 = R/W request failed
    
              dddddddd is the error code returned by the R/W subsystem
    
              eeeeeeee is the Disk Logical Block Address of the sector in error
    
              ffffff is the Logical Cylinder Address of the sector in error
    
              g is the Logical Head Address of the sector in error
    
              hhhh is the Logical Sector Address of the sector in error
    
              iiiiii is the Physical Cylinder Address of the sector in error
    
              j is the Logical Head Address of the sector in error
    
              kkkk is the Physical Sector Address of the sector in error
    
              llllllll is the number of sectors remaining to be read or written
    
        If the Verbose Formatted ASCII Data Output Mode is selected, the Verbose Mode option
        bits will enable the following data to be output when set.
    
           Bit 0:      Enables the R/W Status and R/W Error to be displayed
           Bit 1:      Enable the Next Address to be displayed
           Bit 2:      Enables the Track Position and Track Follow Offset to be displayed
           Bit 3:      Enables the Target Address to be displayed
           Bit 4:      Enables the Recovery Status to be displayed
           Bit 5:      Enables the Fault Status to be displayed
           Bit 6:      Enables the Elapsed Time to be displayed
           Bits 31-7:  NA
    
        If Bit 0 is set, the R/W Status and R/W Error will be displayed even if no error
        occurred.  The data displayed will be formatted as shown above.
    
        If Bit 1 is set, the Next Address will be displayed even if no error occurred.  The
        data displayed will be formatted as shown above.
    
        If Bit 2 is set, the Track Position and Track Follow Offset will be displayed as
        follows.
    
              "Read Position, Persistent Offset m.m% Total Offset n.n%"          or
              "Write Position, Persistent Offset m.m% Total Offset n.n%"         or
              "Write Header Position, Persistent Offset m.m% Total Offset n.n%"
    
           where
    
              m.m is the Persistent Track Follow Offset in units of percentage of track width
    
              n.n is the Total Track Follow Offset in units of percentage of track width
    
        If Bit 3 is set, the Target Address will be displayed as follows.
    
              "Target User LBA pppppppp LLL CHS qqqqqq.r.ssss PLP CHS tttttt.u.vvvv"
              "Starting Transfer Length wwwwwwww"
    
           or
    
              "Target System LBA pppppppp LLL CHS qqqqqq.r.ssss PLP CHS tttttt.u.vvvv"
              "Starting Transfer Length wwwwwwww"
    
           where
    
              pppppppp is the starting Disk Logical Block Address
    
              qqqqqq is the starting Logical Cylinder Address
    
              r is the starting Logical Head Address
    
              ssss is the starting Logical Sector Address
    
              tttttt is the starting Physical Cylinder Address
    
              u is the starting Logical Head Address
    
              vvvv is the starting Physical Sector Address
    
              wwwwwwww is the starting Transfer Length
    
        If Bit 4 is set, the Recovery Status will be displayed as follows.
    
              "Recovered User LBA AAAAAAAA LLL CHS BBBBBB.C.DDDD PLP CHS EEEEEE.F.GGGG"
              "Recovery Flags HHHH Count II"
    
           or
    
              "Recovered System LBA AAAAAAAA LLL CHS BBBBBB.C.DDDD PLP CHS EEEEEE.F.GGGG"
              "Recovery Flags HHHH Count II"
    
           where
    
              AAAAAAAA is the Disk Logical Block Address of the last recovered sector
    
              BBBBBB is the Logical Cylinder Address of the last recovered sector
    
              C is the Logical Head Address of the last recovered sector
    
              DDDD is the Logical Sector Address of the last recovered sector
    
              EEEEEE is the Physical Cylinder Address of the last recovered sector
    
              F is the Logical Head Address of the last recovered sector
    
              GGGG is the Physical Sector Address of the last recovered sector
    
              HHHH are the Recovery Flags reported by the Read/Write code
    
              II is the Recovery Count reported by the Read/Write code
    
        If Bit 5 is set, the Fault Status will be displayed as follows.
    
              "Drive Fault Status JJJJ Preamp Fault Status KKKK"
    
           where
    
              JJJJ is the Drive Fault Status reported by the Read/Write code
    
              KKKK is the Preamp Fault Status reported by the Read/Write code
    
        If Bit 6 is set, the Elapsed Time for the read/write operation will be displayed.
<a name="ELAPSED_TIME"></a>
    
       "Elapsed Time a mins b secs"  or
       "Elapsed Time b.c secs"       or
       "Elapsed Time c.d msecs"
    
    where
    
       a is minutes
       b is seconds
       c is milliseconds
       d is microseconds
    
    

  <b><i><u>Examples:</u></i></b>
    Example #1:
       To write a single logical system sector
       (in this case logical sector 23 on logical system cylinder 45 head 1)

          F3 2>A0
          F3 2>S45,1,,,,1
          F3 2>w,23

    Example #2:
       To write multiple logical system sectors
       (in this case logical sectors 23 to 26 on logical system cylinder 45 head 1)

          F3 2>A0
          F3 2>S45,1,,,,1
          F3 2>w,23,4

    Example #3:
       To write all of the logical system sectors on a track
       (in this case all logical sectors on logical system cylinder 45 head 1)

          F3 2>A0
          F3 2>S45,1,,,,1
          F3 2>w

    Example #4:
       To write all of the logical system sectors on multiple tracks
       (in this case all logical sectors on logical system cylinders 45 to 49 head 0)

       Note: You must seek to the track before the first one to be written.

          F3 2>A3
          F3 2>S44,0,,,,1
          F3 2>L,5
          F3 2>w

    Example #5:
       To write all of the logical system sectors on a track and continue on error
       (in this case all logical sectors on logical cylinder 45 head 0)

       Note: An error message will be displayed for each sector in error.

          F3 2>A0
          F3 2>S45,0,,,,1
          F3 2>w,,,,,1

    Example #6:
       To write all of the logical system sectors in the test space and continue on error

       Note: The Test Space is selected by the all level 'A' command.  An error
       message will be displayed for each sector in error.

          F3 2>w,,,,,11

    Example #7:
       To write long a single logical sector
       (in this case logical sector 32 on logical cylinder 54 head 0)

          F3 2>A0
          F3 2>S54,0
          F3 2>w32

    Example #8:
       To write long multiple logical sectors
       (in this case logical sectors 32 to 33 on logical cylinder 54 head 0)

          F3 2>A0
          F3 2>S54,0
          F3 2>w32,2

    Example #9:
       To write long a single physical sector
       (in this case physical sector 32 on physical cylinder 54 head 0)

          F3 2>A0
          F3 2>s54,0,22
          F3 2>w32,,,1

    Example #10:
       To write long multiple physical sectors
       (in this case physical sectors 32 to 33 on physical cylinder 54 head 0)

          F3 2>A0
          F3 2>s54,0,22
          F3 2>w32,2,,1

    Example #11:
       To write a single logical system sector with data at a specific sector offset in the
       diagnostic write buffer
       (in this case logical sector 23 on logical system cylinder 45 head 1,
        with data at the sector offset of 5 in the diagnostic write buffer)

          F3 2>A0
          F3 2>AF,5
          F3 2>S45,1,,,,1
          F3 2>w,23

    Example #12:
       To rotate the buffer sector offset by 1 and write a single logical system sector with
       data at the rotated sector offset in the diagnostic write buffer
       (This example assumes user ran the Example #11 above right before this example,
        in this case logical sector 24 on logical system cylinder 45 head 1,
        with data at the sector offset of 6 in the diagnostic write buffer)

          F3 2>w,24,,,,4

  <b><i><u>Revision History:</u></i></b>
<a name="WRITE_LONG_OR_SYSTEM_CHS_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0001.0001   Eliminated the Enable ZAP Updates and Enable Track Skipping option.
    0001.0002   Added new Rotate Buffer Sector Offset option to the bit 2 of the parameter 5.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="WRITE_PERIPHERAL_REG_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Write Peripheral Register - channel or preamp"></a><hr align=left width="75%"><b> Write Peripheral Register - channel or preamp (Level 7 's' and Level F 't')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command writes the specified value to the specified register in the specified
    peripheral device.

  <b><i><u>Quick Help:</u></i></b>
<a name="WRITE_PERIPHERAL_REG_QUICK_HELP"></a>
      Level 7
    "WrPeripheralReg, s[OpType],[RegAddr],[RegValue],[RegMask],[RegPagAddr]";
      Level F
    "WrPeripheralReg, t[OpType],[RegAddr],[RegValue],[RegMask],[RegPagAddr]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="WRITE_PERIPHERAL_REG_PARM"></a>
    0 - Operation Type.
    
        This parameter selects the type of peripheral device operation to be performed.
    
             0 = Write Preamp Register
             1 = Write Read Channel Register
    
             2 = Lock Preamp Registers
             3 = Unlock Preamp Registers
             4 = Toggle Preamp Register Lock
    
             5 = Lock Read Channel Registers
             6 = Unlock Read Channel Registers
             7 = Toggle Read Channel Register Lock
    
          Type:    Unsigned 8-bit value
    
          Range:   0 to 7
    
          Default: 1 (Write Read Channel Register)
    
    1 - Register Address Offset.
    
        This parameter specifies the address offset of the peripheral register to be
        written.  If the peripheral registers has the page address mode, this parameter
        specifies the address offset in the page, which has been specified by the
        parameter 1, Register Page Address. Otherwise, it simply specifies the register
        address offset in the whole range of the register address.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: None
    
    2 - Register Value.
    
        This parameter specifies the value with which the specified register is to be
        written.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: 0
    
    3 - Register Mask.
    
        This parameter specifies the bit mask with which the specified value is to be
        written into the register.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: 0xFFFF
    
    4 - Register Page Address.
    
        This parameter specifies the page address of the peripheral register to be
        written.  If the peripheral registers do not have page address in its address
        mode, this input parameter is not needed and its defaul value does not affect
        the write operation to the peripheral register.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: 0
    

  <b><i><u>Output Data:</u></i></b>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
<a name="READ_CHANNEL_LOCK_STATUS"></a>
    If the Read Channel was locked, the following message will be displayed.
    
          "Channel Locked"
    
    If the Read Channel was unlocked, the following message will be displayed.
    
          "Channel Unlocked"
    
<a name="PREAMP_LOCK_STATUS"></a>
    If no error occurred and the Preamp was locked, the following message will be
    displayed.
    
          "Preamp Locked"
    
    If no error occurred and the Preamp was unlocked, the following message will be
    displayed.
    
          "Preamp Unlocked"
    
<a name="WR_PREAMP_REG_DATA"></a>
    If a Preamp register was written, the following information will be displayed.
    
          "Preamp Reg cc = dd"
    
       where
    
          cc is the address of the register that was written
    
          dd is the data with which the register was written
    
<a name="WR_READ_CHANNEL_REG_DATA"></a>
    If a Read Channel register was written, the following information will be displayed.
    
          "Read Channel Reg cccc = dddd"
    
       where
    
          cccc is the address of the register that was written
    
          dddd is the data with which the register was written
    

  <b><i><u>Revision History:</u></i></b>
<a name="WRITE_PERIPHERAL_REG_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="WRITE_READ_READ_CHS_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Write, Read, Read CHS"></a><hr align=left width="75%"><b> Write, Read, Read CHS (Levels 2, 7 'Q')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command performs a disk write, read, read operation starting at the specified
    sector on the target track for the specified number of sectors.  The sectors are
    written with the data contained in the Diagnostic Write Buffer and they are read into
    the Diagnostic Read Buffer.

  <b><i><u>Quick Help:</u></i></b>
<a name="WRITE_READ_READ_CHS_QUICK_HELP"></a>
    "WrRdRdChs, Q[Sec],[NumSecs],,[PhyOpt],[Opts]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="WRITE_READ_READ_CHS_PARM"></a>
     0 - Logical or Physical Sector Address.
    
         If any value is entered for Parameter 3, this parameter contains the physical
         sector address of the first sector to write and read else this parameter contains
         the User Area logical sector address of the first sector to write and read.
    
           Type:    Unsigned 16-bit value
    
           Range:   0 to maximum logical or physical sector address on the target track
    
           Default: 0
    
     1 - Transfer Length.
    
         This parameter specifies the number of consecutive sectors to write and read.
    
           Type:    Unsigned 32-bit value
    
           Range:   0 to 0xFFFFFFFF
    
           Default: If the Sector Address was entered and the Transfer Length was not entered,
                    then only the specified sector will be written and read.
    
                    If both the Sector Address and Transfer Length are not entered, then the
                    Transfer Length will be set based on the Test Space that is selected.
                    If the Random Transfer Length option is selected, a random value will be
                    used that is less than or equal to the number of sectors remaining on the
                    track.  If the Random Transfer Length option is not selected, the number
                    of sectors remaining on the track will be written and read.
    
                    If a Transfer Length is entered, it will be limited to the number of
                    sectors remaining on the track.
    
    <font color=red>
     2 - not used.
    
           Type:    None
    
           Range:   None
    
           Default: None
    
    </font>
     3 - Physical Sector Address Flag.
       
         If any value is entered for this parameter, then Parameter 0 specifies a physical
         sector address, else Parameter 0 specifies a User Area logical sector address.
    
           Type:    Unsigned 16-bit value
    
           Range:   0 to 0xFFFF
    
           Default: None
    
     4 - Options.
    
         This parameter is a bit-significant value that allows the user to select the
         following options.
    
           Bits 15-5:  not used.
    
           Bit 4:      Write and Read All Test Space Sectors.
    
                       If this bit is set, all of the sectors in the Test Space will be
                       written and read, else only the sectors specified by Parameters 0
                       and 1 will be written and read.
    
           Bit 3:      not used.
     
           Bit 2:      Rotate Buffer Sector Offset.
     
                       If this bit is set, the Target Buffer Sector Offset will be rotated
                       by 1 prior to the execution of this diagnostic command.
                       This bit was originally added to help writing random data pattern
                       reduce execution time by not having to re-fill the diagnostic buffer
                       with new random data pattern, which takes great amount of time,
                       but just rotating the Target Buffer Sector Offset at every time this
                       diagnostic command is executed with this option set.
                       To see or change the current Targer Buffer Sector Offset, please refer
                       all Level 'A', Set Test Space, diagnostic command for detail how-to.
    
    <font color=red>
           Bit 1:      Enable Dynamic Sparing.
    
                       If this bit is set, sectors containing media defects that meet
                       the failure criteria will be spared.
    </font>
    
           Bit 0:      Continue On Error.
     
                       If this bit is set and an error occurs, the write and read operations
                       will continue and attempt to write and read all of the requested
                       sectors.  Each error encountered will be displayed.
    
           Type:    Unsigned 16-bit value
    
           Range:   0 to 0xFFFF
    
           Default: 0    (Write and Read the requested sectors,
                          Stop On Error)
    

  <b><i><u>Output Data:</u></i></b>
<a name="RW_OP_STATUS_OUTPUT_DATA"></a>
        If an error occurred, the following information will be displayed.
    
              "DiagError aaaaaaaa R/W Status c R/W Error dddddddd"
    
           and
    
              "Next User LBA eeeeeeee LLL CHS ffffff.g.hhhh PLP CHS iiiiii.j.kkkk"
              "Remaining Transfer Length llllllll"
    
           or
    
              "Next System LBA eeeeeeee LLL CHS ffffff.g.hhhh PLP CHS iiiiii.j.kkkk"
              "Remaining Transfer Length llllllll"
    
           where
    
              aaaaaaaa is the Diagnostic Error Code
    
              c is the status returned by the R/W subsystem
    
                    0 = R/W request completed successfully with error recovery
                    1 = R/W request completed successfully (no error recovery performed)
                    2 = R/W request failed
    
              dddddddd is the error code returned by the R/W subsystem
    
              eeeeeeee is the Disk Logical Block Address of the sector in error
    
              ffffff is the Logical Cylinder Address of the sector in error
    
              g is the Logical Head Address of the sector in error
    
              hhhh is the Logical Sector Address of the sector in error
    
              iiiiii is the Physical Cylinder Address of the sector in error
    
              j is the Logical Head Address of the sector in error
    
              kkkk is the Physical Sector Address of the sector in error
    
              llllllll is the number of sectors remaining to be read or written
    
        If the Verbose Formatted ASCII Data Output Mode is selected, the Verbose Mode option
        bits will enable the following data to be output when set.
    
           Bit 0:      Enables the R/W Status and R/W Error to be displayed
           Bit 1:      Enable the Next Address to be displayed
           Bit 2:      Enables the Track Position and Track Follow Offset to be displayed
           Bit 3:      Enables the Target Address to be displayed
           Bit 4:      Enables the Recovery Status to be displayed
           Bit 5:      Enables the Fault Status to be displayed
           Bit 6:      Enables the Elapsed Time to be displayed
           Bits 31-7:  NA
    
        If Bit 0 is set, the R/W Status and R/W Error will be displayed even if no error
        occurred.  The data displayed will be formatted as shown above.
    
        If Bit 1 is set, the Next Address will be displayed even if no error occurred.  The
        data displayed will be formatted as shown above.
    
        If Bit 2 is set, the Track Position and Track Follow Offset will be displayed as
        follows.
    
              "Read Position, Persistent Offset m.m% Total Offset n.n%"          or
              "Write Position, Persistent Offset m.m% Total Offset n.n%"         or
              "Write Header Position, Persistent Offset m.m% Total Offset n.n%"
    
           where
    
              m.m is the Persistent Track Follow Offset in units of percentage of track width
    
              n.n is the Total Track Follow Offset in units of percentage of track width
    
        If Bit 3 is set, the Target Address will be displayed as follows.
    
              "Target User LBA pppppppp LLL CHS qqqqqq.r.ssss PLP CHS tttttt.u.vvvv"
              "Starting Transfer Length wwwwwwww"
    
           or
    
              "Target System LBA pppppppp LLL CHS qqqqqq.r.ssss PLP CHS tttttt.u.vvvv"
              "Starting Transfer Length wwwwwwww"
    
           where
    
              pppppppp is the starting Disk Logical Block Address
    
              qqqqqq is the starting Logical Cylinder Address
    
              r is the starting Logical Head Address
    
              ssss is the starting Logical Sector Address
    
              tttttt is the starting Physical Cylinder Address
    
              u is the starting Logical Head Address
    
              vvvv is the starting Physical Sector Address
    
              wwwwwwww is the starting Transfer Length
    
        If Bit 4 is set, the Recovery Status will be displayed as follows.
    
              "Recovered User LBA AAAAAAAA LLL CHS BBBBBB.C.DDDD PLP CHS EEEEEE.F.GGGG"
              "Recovery Flags HHHH Count II"
    
           or
    
              "Recovered System LBA AAAAAAAA LLL CHS BBBBBB.C.DDDD PLP CHS EEEEEE.F.GGGG"
              "Recovery Flags HHHH Count II"
    
           where
    
              AAAAAAAA is the Disk Logical Block Address of the last recovered sector
    
              BBBBBB is the Logical Cylinder Address of the last recovered sector
    
              C is the Logical Head Address of the last recovered sector
    
              DDDD is the Logical Sector Address of the last recovered sector
    
              EEEEEE is the Physical Cylinder Address of the last recovered sector
    
              F is the Logical Head Address of the last recovered sector
    
              GGGG is the Physical Sector Address of the last recovered sector
    
              HHHH are the Recovery Flags reported by the Read/Write code
    
              II is the Recovery Count reported by the Read/Write code
    
        If Bit 5 is set, the Fault Status will be displayed as follows.
    
              "Drive Fault Status JJJJ Preamp Fault Status KKKK"
    
           where
    
              JJJJ is the Drive Fault Status reported by the Read/Write code
    
              KKKK is the Preamp Fault Status reported by the Read/Write code
    
        If Bit 6 is set, the Elapsed Time for the read/write operation will be displayed.
<a name="ELAPSED_TIME"></a>
    
       "Elapsed Time a mins b secs"  or
       "Elapsed Time b.c secs"       or
       "Elapsed Time c.d msecs"
    
    where
    
       a is minutes
       b is seconds
       c is milliseconds
       d is microseconds
    
    

  <b><i><u>Examples:</u></i></b>
    Example #1:
       To write and read a single logical sector
       (in this case logical sector 23 on logical cylinder 45 head 1)

          F3 2>A0
          F3 2>S45,1
          F3 2>Q23

    Example #2:
       To write and read multiple logical sectors
       (in this case logical sectors 23 to 26 on logical cylinder 45 head 1)

          F3 2>A0
          F3 2>S45,1
          F3 2>Q23,4

    Example #3:
       To write and read all of the logical sectors on a track
       (in this case all logical sectors on logical cylinder 45 head 1)

          F3 2>A0
          F3 2>S45,1
          F3 2>Q

    Example #4:
       To write and read all of the logical sectors on multiple tracks
       (in this case all logical sectors on logical cylinders 45 to 49 head 0)

       Note: You must seek to the track before the first one to be written and read.

          F3 2>A3
          F3 2>S44,0
          F3 2>L,5
          F3 2>Q

    Example #5:
       To write and read all of the logical sectors on a track and continue on error
       (in this case all logical sectors on logical cylinder 45 head 0)

       Note: An error message will be displayed for each sector in error.

          F3 2>A0
          F3 2>S45,0
          F3 2>Q,,,,1

    Example #6:
       To write and read all of the logical sectors in the test space and continue on error

       Note: The Test Space is selected by the all level 'A' command.  An error
       message will be displayed for each sector in error.

          F3 2>Q,,,,11

    Example #7:
       To write and read a single physical sector
       (in this case physical sector 32 on physical cylinder 54 head 0)

          F3 2>A0
          F3 2>s54,0,22
          F3 2>Q32,,,1

    Example #8:
       To write and read multiple physical sectors
       (in this case physical sectors 32 to 35 on physical cylinder 54 head 0)

          F3 2>A0
          F3 2>s54,0,22
          F3 2>Q32,4,,1

    Example #9:
       To write and read all of the physical sectors on a track
       (in this case all physical sectors on physical cylinder 54 head 0)

          F3 2>A0
          F3 2>s54,0,22
          F3 2>Q,,,1

    Example #10:
       To write a single logical sector with data at a specific sector offset in the
       diagnostic write buffer and read it to the sector offset in the diagnostic read buffer
       (in this case logical sector 23 on logical cylinder 45 head 1,
        write with data at the sector offset of 5 in the diagnostic write buffer,
        read to the sector offset of 5 in the diagnostic read buffer)

          F3 2>A0
          F3 2>AF,5
          F3 2>S45,1
          F3 2>Q23

    Example #11:
       To rotate the buffer sector offset by 1, write a single logical sector with data at
       the rotated sector offset in the diagnostic write buffer, then read it to the rotated
       sector offset in the diagnostic read buffer
       (This example assumes user ran the Example #10 above right before this example,
        in this case logical sector 24 on logical cylinder 45 head 1,
        write with data at the sector offset of 6 in the diagnostic write buffer,
        read to the sector offset of 6 in the diagnostic read buffer)

          F3 2>Q24,,,,4

  <b><i><u>Revision History:</u></i></b>
<a name="WRITE_READ_READ_CHS_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0001.0001   Eliminated the Enable ZAP Updates and Enable Track Skipping option.
    0001.0002   Moved the Enable Dynamic Sparing option from the parameter 2 to the bit 1 of
                the parameter 4.
                Added new Rotate Buffer Sector Offset option to the bit 2 of the parameter 4.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="WRITE_READ_READ_LBA_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Write, Read, Read LBA"></a><hr align=left width="75%"><b> Write, Read, Read LBA (Level A 'Q')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command performs a write, read, read operation starting at the specified LBA
    (Logical Block Address) for the specified number of LBAs.  The LBAs are written
    with the data contained in the Diagnostic Write Buffer and they are read into the
    Diagnostic Read Buffer.

  <b><i><u>Quick Help:</u></i></b>
<a name="WRITE_READ_READ_LBA_QUICK_HELP"></a>
    "WrRdRdLba, Q[Lba],[NumLbas],[Opts]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="WRITE_READ_READ_LBA_PARM"></a>
     0 - LBA.
    
         If Parameter 2 bit 5 is set, then this parameter specifies the address of the
         first System Area LBA to be written and read, else it specifies the address of
         the first User Area LBA to be written and read.
    
           Type:    Unsigned 32-bit value
    
           Range:   0 to maximum User Area LBA, if parameter 2 bit 5 is cleared
                    0 to maximum System Area LBA, if parameter 2 bit 5 is set
    
           Default: Current Target Address
    
     1 - Transfer Length.
    
         This parameter specifies the number of consecutive LBAs to written.
    
           Type:    Unsigned 32-bit value
    
           Range:   0 to 0xFFFFFFFF
    
           Default: If the LBA (Parameter 0) was entered and the Transfer Length (Parameter 1)
                    was not entered, then only the specified LBA will be written and read.
    
                    If both the LBA (Parameter 0) and Transfer Length (Parameter 1) are not
                    entered, then the Transfer Length will be set based on the Test Space
                    that is selected.  If the Random Transfer Length option is selected, a
                    random value will be used that is less than or equal to the number of LBAs
                    remaining in the Test Space.  If the Random Transfer Length option is not
                    selected, the number of LBAs remaining on the track containing the current
                    Target LBA will be written and read.
    
                    If a Transfer Length is entered, it will be limited to the number of
                    LBAs remaining in the Test Space.
    
     2 - Options.
    
         This parameter is a bit-significant value that allows the user to select the
         following options.
    
           Bits 15-6:  not used.
    
           Bit 5:      Write and Read System Area LBAs.
    
                       If this bit is set, then Parameter 0 specifies a System Area LBA,
                       else Parameter 0 specifies a User Area LBA.
    
           Bit 4:      Write and Read All Test Space LBAs.
    
                       If this bit is set, all of the LBAs in the Test Space will be
                       written and read, else only the LBAs specified by Parameters 0
                       and 1 will be written and read.
    
           Bit 3:      not used.
     
           Bit 2:      Rotate Buffer Sector Offset.
     
                       If this bit is set, the Target Buffer Sector Offset will be rotated
                       by 1 prior to the execution of this diagnostic command.
                       This bit was originally added to help writing random data pattern
                       reduce execution time by not having to re-fill the diagnostic buffer
                       with new random data pattern, which takes great amount of time,
                       but just rotating the Target Buffer Sector Offset at every time this
                       diagnostic command is executed with this option set.
                       To see or change the current Targer Buffer Sector Offset, please refer
                       all Level 'A', Set Test Space, diagnostic command for detail how-to.
    
    <font color=red>
           Bit 1:      Enable Dynamic Sparing.
    
                       If this bit is set, sectors containing media defects that meet the
                       failure criteria will be spared.
    </font>
    
           Bit 0:      Continue On Error.
     
                       If this bit is set and an error occurs, the write and read operations
                       will continue and attempt to write and read all of the requested
                       sectors.  Each error encountered will be displayed.
    
           Type:    Unsigned 16-bit value
    
           Range:   0 to 0xFFFF
    
           Default: 0    (Write and Read User Area LBAs,
                          Write and Read the requested LBAs,
                          Disable Dynamic Sparing,
                          Stop On Error)
    

  <b><i><u>Output Data:</u></i></b>
<a name="RW_OP_STATUS_OUTPUT_DATA"></a>
        If an error occurred, the following information will be displayed.
    
              "DiagError aaaaaaaa R/W Status c R/W Error dddddddd"
    
           and
    
              "Next User LBA eeeeeeee LLL CHS ffffff.g.hhhh PLP CHS iiiiii.j.kkkk"
              "Remaining Transfer Length llllllll"
    
           or
    
              "Next System LBA eeeeeeee LLL CHS ffffff.g.hhhh PLP CHS iiiiii.j.kkkk"
              "Remaining Transfer Length llllllll"
    
           where
    
              aaaaaaaa is the Diagnostic Error Code
    
              c is the status returned by the R/W subsystem
    
                    0 = R/W request completed successfully with error recovery
                    1 = R/W request completed successfully (no error recovery performed)
                    2 = R/W request failed
    
              dddddddd is the error code returned by the R/W subsystem
    
              eeeeeeee is the Disk Logical Block Address of the sector in error
    
              ffffff is the Logical Cylinder Address of the sector in error
    
              g is the Logical Head Address of the sector in error
    
              hhhh is the Logical Sector Address of the sector in error
    
              iiiiii is the Physical Cylinder Address of the sector in error
    
              j is the Logical Head Address of the sector in error
    
              kkkk is the Physical Sector Address of the sector in error
    
              llllllll is the number of sectors remaining to be read or written
    
        If the Verbose Formatted ASCII Data Output Mode is selected, the Verbose Mode option
        bits will enable the following data to be output when set.
    
           Bit 0:      Enables the R/W Status and R/W Error to be displayed
           Bit 1:      Enable the Next Address to be displayed
           Bit 2:      Enables the Track Position and Track Follow Offset to be displayed
           Bit 3:      Enables the Target Address to be displayed
           Bit 4:      Enables the Recovery Status to be displayed
           Bit 5:      Enables the Fault Status to be displayed
           Bit 6:      Enables the Elapsed Time to be displayed
           Bits 31-7:  NA
    
        If Bit 0 is set, the R/W Status and R/W Error will be displayed even if no error
        occurred.  The data displayed will be formatted as shown above.
    
        If Bit 1 is set, the Next Address will be displayed even if no error occurred.  The
        data displayed will be formatted as shown above.
    
        If Bit 2 is set, the Track Position and Track Follow Offset will be displayed as
        follows.
    
              "Read Position, Persistent Offset m.m% Total Offset n.n%"          or
              "Write Position, Persistent Offset m.m% Total Offset n.n%"         or
              "Write Header Position, Persistent Offset m.m% Total Offset n.n%"
    
           where
    
              m.m is the Persistent Track Follow Offset in units of percentage of track width
    
              n.n is the Total Track Follow Offset in units of percentage of track width
    
        If Bit 3 is set, the Target Address will be displayed as follows.
    
              "Target User LBA pppppppp LLL CHS qqqqqq.r.ssss PLP CHS tttttt.u.vvvv"
              "Starting Transfer Length wwwwwwww"
    
           or
    
              "Target System LBA pppppppp LLL CHS qqqqqq.r.ssss PLP CHS tttttt.u.vvvv"
              "Starting Transfer Length wwwwwwww"
    
           where
    
              pppppppp is the starting Disk Logical Block Address
    
              qqqqqq is the starting Logical Cylinder Address
    
              r is the starting Logical Head Address
    
              ssss is the starting Logical Sector Address
    
              tttttt is the starting Physical Cylinder Address
    
              u is the starting Logical Head Address
    
              vvvv is the starting Physical Sector Address
    
              wwwwwwww is the starting Transfer Length
    
        If Bit 4 is set, the Recovery Status will be displayed as follows.
    
              "Recovered User LBA AAAAAAAA LLL CHS BBBBBB.C.DDDD PLP CHS EEEEEE.F.GGGG"
              "Recovery Flags HHHH Count II"
    
           or
    
              "Recovered System LBA AAAAAAAA LLL CHS BBBBBB.C.DDDD PLP CHS EEEEEE.F.GGGG"
              "Recovery Flags HHHH Count II"
    
           where
    
              AAAAAAAA is the Disk Logical Block Address of the last recovered sector
    
              BBBBBB is the Logical Cylinder Address of the last recovered sector
    
              C is the Logical Head Address of the last recovered sector
    
              DDDD is the Logical Sector Address of the last recovered sector
    
              EEEEEE is the Physical Cylinder Address of the last recovered sector
    
              F is the Logical Head Address of the last recovered sector
    
              GGGG is the Physical Sector Address of the last recovered sector
    
              HHHH are the Recovery Flags reported by the Read/Write code
    
              II is the Recovery Count reported by the Read/Write code
    
        If Bit 5 is set, the Fault Status will be displayed as follows.
    
              "Drive Fault Status JJJJ Preamp Fault Status KKKK"
    
           where
    
              JJJJ is the Drive Fault Status reported by the Read/Write code
    
              KKKK is the Preamp Fault Status reported by the Read/Write code
    
        If Bit 6 is set, the Elapsed Time for the read/write operation will be displayed.
<a name="ELAPSED_TIME"></a>
    
       "Elapsed Time a mins b secs"  or
       "Elapsed Time b.c secs"       or
       "Elapsed Time c.d msecs"
    
    where
    
       a is minutes
       b is seconds
       c is milliseconds
       d is microseconds
    
    

  <b><i><u>Examples:</u></i></b>
    Example #1:
       To write and read a single LBA
       (in this case LBA 51237)

          F3 A>Q51237

    Example #2:
       To write and read multiple LBAs
       (in this case LBAs 51237 to 51247)

          F3 A>Q51237,11

    Example #3:
       To write and read all of the LBAs remaining on the track containing the target LBA
       (in this case all LBAs remaining on the cylinder that contains LBA 51237)

          F3 A>S51237
          F3 A>Q

    Example #4:
       To write and read all of the LBAs remaining on the track containing the target LBA
       and continue on error
       (in this case all LBAs remaining on the cylinder that contains LBA 51237)

       Note: An error message will be displayed for each LBA in error.

          F3 A>S51237
          F3 A>Q,,1

    Example #5:
       To write and read all of the LBAs in the test space and continue on error

       Note: The Test Space is selected by the all level 'A' command.  An error
       message will be displayed for each LBA in error.

          F3 A>Q,,11

    Example #6:
       To write and read a single system LBA
       (in this case system LBA 1237)

          F3 A>Q1237,,20

    Example #7:
       To write and read multiple system LBAs
       (in this case system LBAs 1237 to 1247)

          F3 A>Q1237,11,20

    Example #8:
       To write and read all of the LBAs remaining on the track containing the target
       system LBA
       (in this case all LBAs remaining on the cylinder that contains LBA 1237)

          F3 A>S1237,,,,,1
          F3 A>Q,,20

    Example #9:
       To write a single LBA with data at a specific sector offset in the diagnostic write
       buffer and read it to the sector offset in the diagnostic read buffer
       (in this case LBA 51237,
        write with data at the sector offset of 5 in the diagnostic write buffer,
        read to the sector offset of 5 in the diagnostic read buffer)

          F3 A>AF,5
          F3 A>Q51237

    Example #10:
       To rotate the buffer sector offset by 1, write a single LBA with data at the rotated
       sector offset in the diagnostic write buffer, then read it to the rotated sector
       offset in the diagnostic read buffer
       (This example assumes user ran the Example #9 above right before this example,
        in this case LBA 51238,
        write with data at the sector offset of 6 in the diagnostic write buffer,
        read to the sector offset of 6 in the diagnostic read buffer)

          F3 A>Q51238,,4

  <b><i><u>Revision History:</u></i></b>
<a name="WRITE_READ_READ_LBA_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0001.0001   Eliminated the Enable ZAP Updates and Enable Track Skipping option.
    0001.0002   Modified to write and read only the LBAs remaining on the track containing
                the target LBA, if the LBA and Transfer Length are not entered by the user.
    0001.0003   Added new Rotate Buffer Sector Offset option to the bit 2 of the parameter 2.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="WRITE_READ_WRITE_READ_CHS_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Write, Read, Write, Read CHS"></a><hr align=left width="75%"><b> Write, Read, Write, Read CHS (Level 3 'Q')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command performs a write, read, write, read operation starting at the specified
    sector on the target track for the specified number of sectors.  The sectors are
    written with the data contained in the Diagnostic Write Buffer and they are read into
    the Diagnostic Read Buffer.

  <b><i><u>Quick Help:</u></i></b>
<a name="WRITE_READ_WRITE_READ_CHS_QUICK_HELP"></a>
    "WrRdWrRdChs, Q[Sec],[NumSecs],[Opts]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="WRITE_READ_WRITE_READ_CHS_PARM"></a>
     0 - Logical or Physical Sector Address.
    
         If Parameter 2 bit 5 is set, this parameter contains the physical sector address
         of the first sector to write and read else this parameter contains the User Area
         logical sector address of the first sector to write and read.
    
           Type:    Unsigned 16-bit value
    
           Range:   0 to maximum logical or physical sector address on the target track
    
           Default: 0
    
     1 - Transfer Length.
    
         This parameter specifies the number of consecutive sectors to write and read.
    
           Type:    Unsigned 32-bit value
    
           Range:   0 to 0xFFFFFFFF
    
           Default: If the Sector Address was entered and the Transfer Length was not entered,
                    then only the specified sector will be written and read.
    
                    If both the Sector Address and Transfer Length are not entered, then the
                    Transfer Length will be set based on the Test Space that is selected.
                    If the Random Transfer Length option is selected, a random value will be
                    used that is less than or equal to the number of sectors remaining on the
                    track.  If the Random Transfer Length option is not selected, the number
                    of sectors remaining on the track will be written and read.
    
                    If a Transfer Length is entered, it will be limited to the number of
                    sectors remaining on the track.
    
     2 - Options.
    
         This parameter is a bit-significant value that allows the user to select the
         following options.
    
           Bits 15-6:  not used.
    
           Bit 5:      Write and Read Physical Sectors.
    
                       If this bit is set, then Parameter 0 specifies a physical sector
                       address, else Parameter 0 specifies a User Area logical sector
                       address.
    
           Bit 4:      Write and Read All Test Space Sectors.
    
                       If this bit is set, all of the sectors in the Test Space will be
                       written and read, else only the sectors specified by Parameters 0
                       and 1 will be written and read.
    
           Bit 3:      not used.
     
           Bit 2:      Rotate Buffer Sector Offset.
     
                       If this bit is set, the Target Buffer Sector Offset will be rotated
                       by 1 prior to the execution of this diagnostic command.
                       This bit was originally added to help writing random data pattern
                       reduce execution time by not having to re-fill the diagnostic buffer
                       with new random data pattern, which takes great amount of time,
                       but just rotating the Target Buffer Sector Offset at every time this
                       diagnostic command is executed with this option set.
                       To see or change the current Targer Buffer Sector Offset, please refer
                       all Level 'A', Set Test Space, diagnostic command for detail how-to.
    
    <font color=red>
           Bit 1:      Enable Dynamic Sparing.
    
                       If this bit is set, sectors containing media defects that meet the
                       failure criteria will be spared.
    </font>
    
           Bit 0:      Continue On Error.
     
                       If this bit is set and an error occurs, the write and read operations
                       will continue and attempt to write and read all of the requested
                       sectors.  Each error encountered will be displayed.
    
           Type:    Unsigned 16-bit value
    
           Range:   0 to 0xFFFF
    
           Default: 0    (Write and Read Logical sectors,
                          Write the requested sectors,
                          Disable Dynamic Sparing,
                          Stop On Error)
    

  <b><i><u>Output Data:</u></i></b>
<a name="RW_OP_STATUS_OUTPUT_DATA"></a>
        If an error occurred, the following information will be displayed.
    
              "DiagError aaaaaaaa R/W Status c R/W Error dddddddd"
    
           and
    
              "Next User LBA eeeeeeee LLL CHS ffffff.g.hhhh PLP CHS iiiiii.j.kkkk"
              "Remaining Transfer Length llllllll"
    
           or
    
              "Next System LBA eeeeeeee LLL CHS ffffff.g.hhhh PLP CHS iiiiii.j.kkkk"
              "Remaining Transfer Length llllllll"
    
           where
    
              aaaaaaaa is the Diagnostic Error Code
    
              c is the status returned by the R/W subsystem
    
                    0 = R/W request completed successfully with error recovery
                    1 = R/W request completed successfully (no error recovery performed)
                    2 = R/W request failed
    
              dddddddd is the error code returned by the R/W subsystem
    
              eeeeeeee is the Disk Logical Block Address of the sector in error
    
              ffffff is the Logical Cylinder Address of the sector in error
    
              g is the Logical Head Address of the sector in error
    
              hhhh is the Logical Sector Address of the sector in error
    
              iiiiii is the Physical Cylinder Address of the sector in error
    
              j is the Logical Head Address of the sector in error
    
              kkkk is the Physical Sector Address of the sector in error
    
              llllllll is the number of sectors remaining to be read or written
    
        If the Verbose Formatted ASCII Data Output Mode is selected, the Verbose Mode option
        bits will enable the following data to be output when set.
    
           Bit 0:      Enables the R/W Status and R/W Error to be displayed
           Bit 1:      Enable the Next Address to be displayed
           Bit 2:      Enables the Track Position and Track Follow Offset to be displayed
           Bit 3:      Enables the Target Address to be displayed
           Bit 4:      Enables the Recovery Status to be displayed
           Bit 5:      Enables the Fault Status to be displayed
           Bit 6:      Enables the Elapsed Time to be displayed
           Bits 31-7:  NA
    
        If Bit 0 is set, the R/W Status and R/W Error will be displayed even if no error
        occurred.  The data displayed will be formatted as shown above.
    
        If Bit 1 is set, the Next Address will be displayed even if no error occurred.  The
        data displayed will be formatted as shown above.
    
        If Bit 2 is set, the Track Position and Track Follow Offset will be displayed as
        follows.
    
              "Read Position, Persistent Offset m.m% Total Offset n.n%"          or
              "Write Position, Persistent Offset m.m% Total Offset n.n%"         or
              "Write Header Position, Persistent Offset m.m% Total Offset n.n%"
    
           where
    
              m.m is the Persistent Track Follow Offset in units of percentage of track width
    
              n.n is the Total Track Follow Offset in units of percentage of track width
    
        If Bit 3 is set, the Target Address will be displayed as follows.
    
              "Target User LBA pppppppp LLL CHS qqqqqq.r.ssss PLP CHS tttttt.u.vvvv"
              "Starting Transfer Length wwwwwwww"
    
           or
    
              "Target System LBA pppppppp LLL CHS qqqqqq.r.ssss PLP CHS tttttt.u.vvvv"
              "Starting Transfer Length wwwwwwww"
    
           where
    
              pppppppp is the starting Disk Logical Block Address
    
              qqqqqq is the starting Logical Cylinder Address
    
              r is the starting Logical Head Address
    
              ssss is the starting Logical Sector Address
    
              tttttt is the starting Physical Cylinder Address
    
              u is the starting Logical Head Address
    
              vvvv is the starting Physical Sector Address
    
              wwwwwwww is the starting Transfer Length
    
        If Bit 4 is set, the Recovery Status will be displayed as follows.
    
              "Recovered User LBA AAAAAAAA LLL CHS BBBBBB.C.DDDD PLP CHS EEEEEE.F.GGGG"
              "Recovery Flags HHHH Count II"
    
           or
    
              "Recovered System LBA AAAAAAAA LLL CHS BBBBBB.C.DDDD PLP CHS EEEEEE.F.GGGG"
              "Recovery Flags HHHH Count II"
    
           where
    
              AAAAAAAA is the Disk Logical Block Address of the last recovered sector
    
              BBBBBB is the Logical Cylinder Address of the last recovered sector
    
              C is the Logical Head Address of the last recovered sector
    
              DDDD is the Logical Sector Address of the last recovered sector
    
              EEEEEE is the Physical Cylinder Address of the last recovered sector
    
              F is the Logical Head Address of the last recovered sector
    
              GGGG is the Physical Sector Address of the last recovered sector
    
              HHHH are the Recovery Flags reported by the Read/Write code
    
              II is the Recovery Count reported by the Read/Write code
    
        If Bit 5 is set, the Fault Status will be displayed as follows.
    
              "Drive Fault Status JJJJ Preamp Fault Status KKKK"
    
           where
    
              JJJJ is the Drive Fault Status reported by the Read/Write code
    
              KKKK is the Preamp Fault Status reported by the Read/Write code
    
        If Bit 6 is set, the Elapsed Time for the read/write operation will be displayed.
<a name="ELAPSED_TIME"></a>
    
       "Elapsed Time a mins b secs"  or
       "Elapsed Time b.c secs"       or
       "Elapsed Time c.d msecs"
    
    where
    
       a is minutes
       b is seconds
       c is milliseconds
       d is microseconds
    
    

  <b><i><u>Examples:</u></i></b>
    Example #1:
       To write, read, write, read a single logical sector
       (in this case logical sector 23 on logical cylinder 45 head 1)

          F3 2>A0
          F3 2>S45,1
          F3 2>/3
          F3 3>Q23

    Example #2:
       To write, read, write, read multiple logical sectors
       (in this case logical sectors 23 to 26 on logical cylinder 45 head 1)

          F3 2>A0
          F3 2>S45,1
          F3 2>/3
          F3 3>Q23,4

    Example #3:
       To write, read, write, read all of the logical sectors on a track
       (in this case all logical sectors on logical cylinder 45 head 1)

          F3 2>A0
          F3 2>S45,1
          F3 2>/3
          F3 3>Q

    Example #4:
       To write, read, write, read all of the logical sectors on multiple tracks
       (in this case all logical sectors on logical cylinders 45 to 49 head 0)

       Note: You must seek to the track before the first one to be written and read.

          F3 2>A3
          F3 2>S44,0
          F3 2>/3
          F3 3>L,5
          F3 3>Q

    Example #5:
       To write, read, write, read all of the logical sectors on a track and continue
       on error (in this case all logical sectors on logical cylinder 45 head 0)

       Note: An error message will be displayed for each sector in error.

          F3 2>A0
          F3 2>S45,0
          F3 2>/3
          F3 3>Q,,,,1

    Example #6:
       To write, read, write, read all of the logical sectors in the test space and
       continue on error

       Note: The Test Space is selected by the all level 'A' command.  An error
       message will be displayed for each sector in error.

          F3 3>Q,,,,11

    Example #7:
       To write, read, write, read a single physical sector
       (in this case physical sector 32 on physical cylinder 54 head 0)

          F3 2>A0
          F3 2>s54,0,22
          F3 2>/3
          F3 3>Q32,,,1

    Example #8:
       To write, read, write, read multiple physical sectors
       (in this case physical sectors 32 to 35 on physical cylinder 54 head 0)

          F3 2>A0
          F3 2>s54,0,22
          F3 2>/3
          F3 3>Q32,4,,1

    Example #9:
       To write, read, write, read all of the physical sectors on a track
       (in this case all physical sectors on physical cylinder 54 head 0)

          F3 2>A0
          F3 2>s54,0,22
          F3 2>/3
          F3 3>Q,,,1

    Example #10:
       To write a single logical sector with data at a specific sector offset in the
       diagnostic write buffer, read it to the specific sector offset in the diagnostic read
       buffer, then repeat the write and read one more time.
       (in this case logical sector 23 on logical cylinder 45 head 1,
        write with data at the sector offset of 5 in the diagnostic write buffer,
        read to the sector offset of 5 in the diagnostic read buffer,
        write with data at the sector offset of 5 in the diagnostic write buffer,
        read to the sector offset of 5 in the diagnostic read buffer)

          F3 2>A0
          F3 2>AF,5
          F3 2>S45,1
          F3 2>/3
          F3 3>Q23

    Example #11:
       To rotate the buffer sector offset by 1 and write a single logical sector with data at
       the rotated sector offset in the diagnostic write buffer, read it to the rotated
       sector offset in the diagnostic read buffer, then repeat the write and read one more
       time
       (This example assumes user ran the Example #10 above right before this example,
        in this case logical sector 24 on logical cylinder 45 head 1,
        write with data at the sector offset of 6 in the diagnostic write buffer,
        read to the sector offset of 6 in the diagnostic read buffer,
        write with data at the sector offset of 6 in the diagnostic write buffer,
        read to the sector offset of 6 in the diagnostic read buffer)

          F3 3>Q24,,4

  <b><i><u>Revision History:</u></i></b>
<a name="WRITE_READ_WRITE_READ_CHS_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0001.0001   Eliminated the Enable ZAP Updates and Enable Track Skipping option.
    0001.0002   Added new Rotate Buffer Sector Offset option to the bit 2 of the parameter 2.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="WRITE_SERVO_RAM_AT_ADDR_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Write Servo RAM at Address"></a><hr align=left width="75%"><b> Write Servo RAM at Address (Level 5 'W')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    The Write Servo RAM at Address command writes the specified Servo RAM locations
    with the specified data.

  <b><i><u>Quick Help:</u></i></b>
<a name="WRITE_SERVO_RAM_AT_ADDR_QUICK_HELP"></a>
    "WrServoRamAtAddr, W[Addr],[NumBytes],[Data]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="WRITE_SERVO_RAM_AT_ADDR_PARM"></a>
    0 - Servo RAM Address.
      
        This parameter specifies the address of the first servo RAM byte to be written.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: None
    
    1 - Number of Bytes.
    
        This parameter specifies the number of servo RAM bytes to be written.
    
          Type:    Unsigned 8-bit value
    
          Range:   1, 2 and 4 are the allowed values
    
          Default: 2
    
    2 - Servo RAM Data.
    
        This parameter specifies that data with which the specified servo RAM location
        is to be written.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: 0
    

  <b><i><u>Output Data:</u></i></b>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    

  <b><i><u>Revision History:</u></i></b>
<a name="WRITE_SERVO_RAM_AT_ADDR_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="WRITE_SERVO_RAM_AT_INDEX_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Write Servo RAM at Index"></a><hr align=left width="75%"><b> Write Servo RAM at Index (Level 5 'w')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    The Write Servo RAM at Index command writes Servo RAM with the specified data.
    The base address of the Servo RAM location to be written is retrieved from the Servo
    Symbol Table at the specified index and an optional byte offset is added to it.

  <b><i><u>Quick Help:</u></i></b>
<a name="WRITE_SERVO_RAM_AT_INDEX_QUICK_HELP"></a>
    "WrServoRamAtIndex, w[Index],[NumBytes],[Data],[ByteOffset]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="WRITE_SERVO_RAM_AT_INDEX_PARM"></a>
    0 - Servo Symbol Table Index.
    
        This parameter specifies the index of the Servo Symbol Table entry that contains
        the base address of the Servo RAM location to be written.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: None
    
    1 - Number of Bytes.
    
        This parameter specifies the number of servo RAM bytes to be written.
    
          Type:    Unsigned 8-bit value
    
          Range:   1, 2 and 4 are the allowed values
    
          Default: 2
    
    2 - Servo RAM Data.
    
        This parameter specifies that data with which the servo RAM is to be written.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: 0
    
    3 - Byte offset from base address.
    
        This parameter is an optional byte offset which will be added to the address of the
        servo RAM location to be written.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: 0
    

  <b><i><u>Output Data:</u></i></b>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    

  <b><i><u>Revision History:</u></i></b>
<a name="WRITE_SERVO_RAM_AT_INDEX_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="WRITE_VERIFY_CHS_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Write Verify CHS"></a><hr align=left width="75%"><b> Write Verify CHS (Level 2 '7')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command writes data to the disk starting at the specified sector on the target
    track for the specified number of sectors.  The specified sectors are then read and
    the data is compared to the data that was written.  The sectors are written with the
    data contained in the specified buffer and they are read into the the Diagnostic
    Read Buffer.

  <b><i><u>Quick Help:</u></i></b>
<a name="WRITE_VERIFY_CHS_QUICK_HELP"></a>
    "WrVerifyChs, 7[Sec],[NumSecs],[WrBufBlk],[Opts]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="WRITE_VERIFY_CHS_PARM"></a>
     0 - Logical or Physical Sector Address.
    
         If Parameter 3 bit 5 is set, this parameter contains the physical sector address
         of the first sector to be written and verified, else this parameter contains the
         User Area logical sector address of the first sector to be written and verified.
    
           Type:    Unsigned 16-bit value
    
           Range:   0 to maximum logical or physical sector address on the target track
    
           Default: 0
    
     1 - Transfer Length.
    
         This parameter specifies the number of consecutive sectors to be written and
         verified.
    
           Type:    Unsigned 32-bit value
    
           Range:   0 to 0xFFFFFFFF
    
           Default: If the Sector Address was entered and the Transfer Length was not entered,
                    then only the specified sector will be written and verified.
    
                    If both the Sector Address and Transfer Length are not entered, then the
                    Transfer Length will be set based on the Test Space that is selected.
                    If the Random Transfer Length option is selected, a random value will be
                    used that is less than or equal to the number of sectors remaining on the
                    track.  If the Random Transfer Length option is not selected, the number
                    of sectors remaining on the track will be written and verified.
    
                    If a Transfer Length is entered, it will be limited to the number of
                    sectors remaining on the track.
    
    <font color=red>
     2 - Write Data Buffer Block Number.
    
         This parameter specifies the number of the buffer block that contains the data
         with which the specified sectors are to be written.  The data contained in this
         buffer block will also be compared to the data that is read.
    
           Type:    Unsigned 16-bit value
    
           Range:   0 to 0xFFFF
    
           Default: If a Write Data Buffer Block Number is not specified, the Diagnostic
                    Write Buffer will be used as the write data source and the read compare
                    reference data.
    
    </font>
     3 - Options.
    
         This parameter is a bit-significant value that allows the user to select the
         following options.
    
           Bits 15-6:  not used.
    
           Bit 5:      Write and Verify Physical Sectors.
    
                       If this bit is set, Parameter 0 specifies a physical sector address,
                       else it specifies a User Area logical sector address.
    
           Bit 4:      Write and Verify All Test Space Sectors.
    
                       If this bit is set, all of the sectors in the Test Space will be
                       written and verified, else only the System Area Sectors specified
                       by Parameters 0 and 1 will be written and verified.
    
           Bit 3:      not used.
     
           Bit 2:      Rotate Buffer Sector Offset.
     
                       If this bit is set, the Target Buffer Sector Offset will be rotated
                       by 1 prior to the execution of this diagnostic command.
                       This bit was originally added to help writing random data pattern
                       reduce execution time by not having to re-fill the diagnostic buffer
                       with new random data pattern, which takes great amount of time,
                       but just rotating the Target Buffer Sector Offset at every time this
                       diagnostic command is executed with this option set.
                       To see or change the current Targer Buffer Sector Offset, please refer
                       all Level 'A', Set Test Space, diagnostic command for detail how-to.
    
    <font color=red>
           Bit 1:      Enable Dynamic Sparing.
    
                       If this bit is set, sectors containing media defects that meet
                       the failure criteria will be spared.
    </font>
    
           Bit 0:      Continue On Error.
     
                       If this bit is set and an error occurs, the write and verify
                       operations will continue and attempt to write and verify all of
                       the requested sectors.  Each error encountered will be displayed.
    
           Type:    Unsigned 16-bit value
    
           Range:   0 to 0xFFFF
    
           Default: 0    (Write and Verify Logical User Area Sectors,
                          Write and Verify the requested sectors,
                          Disable Dynamic Sparing,
                          Stop On Error)
    

  <b><i><u>Output Data:</u></i></b>
<a name="RW_OP_STATUS_OUTPUT_DATA"></a>
        If an error occurred, the following information will be displayed.
    
              "DiagError aaaaaaaa R/W Status c R/W Error dddddddd"
    
           and
    
              "Next User LBA eeeeeeee LLL CHS ffffff.g.hhhh PLP CHS iiiiii.j.kkkk"
              "Remaining Transfer Length llllllll"
    
           or
    
              "Next System LBA eeeeeeee LLL CHS ffffff.g.hhhh PLP CHS iiiiii.j.kkkk"
              "Remaining Transfer Length llllllll"
    
           where
    
              aaaaaaaa is the Diagnostic Error Code
    
              c is the status returned by the R/W subsystem
    
                    0 = R/W request completed successfully with error recovery
                    1 = R/W request completed successfully (no error recovery performed)
                    2 = R/W request failed
    
              dddddddd is the error code returned by the R/W subsystem
    
              eeeeeeee is the Disk Logical Block Address of the sector in error
    
              ffffff is the Logical Cylinder Address of the sector in error
    
              g is the Logical Head Address of the sector in error
    
              hhhh is the Logical Sector Address of the sector in error
    
              iiiiii is the Physical Cylinder Address of the sector in error
    
              j is the Logical Head Address of the sector in error
    
              kkkk is the Physical Sector Address of the sector in error
    
              llllllll is the number of sectors remaining to be read or written
    
        If the Verbose Formatted ASCII Data Output Mode is selected, the Verbose Mode option
        bits will enable the following data to be output when set.
    
           Bit 0:      Enables the R/W Status and R/W Error to be displayed
           Bit 1:      Enable the Next Address to be displayed
           Bit 2:      Enables the Track Position and Track Follow Offset to be displayed
           Bit 3:      Enables the Target Address to be displayed
           Bit 4:      Enables the Recovery Status to be displayed
           Bit 5:      Enables the Fault Status to be displayed
           Bit 6:      Enables the Elapsed Time to be displayed
           Bits 31-7:  NA
    
        If Bit 0 is set, the R/W Status and R/W Error will be displayed even if no error
        occurred.  The data displayed will be formatted as shown above.
    
        If Bit 1 is set, the Next Address will be displayed even if no error occurred.  The
        data displayed will be formatted as shown above.
    
        If Bit 2 is set, the Track Position and Track Follow Offset will be displayed as
        follows.
    
              "Read Position, Persistent Offset m.m% Total Offset n.n%"          or
              "Write Position, Persistent Offset m.m% Total Offset n.n%"         or
              "Write Header Position, Persistent Offset m.m% Total Offset n.n%"
    
           where
    
              m.m is the Persistent Track Follow Offset in units of percentage of track width
    
              n.n is the Total Track Follow Offset in units of percentage of track width
    
        If Bit 3 is set, the Target Address will be displayed as follows.
    
              "Target User LBA pppppppp LLL CHS qqqqqq.r.ssss PLP CHS tttttt.u.vvvv"
              "Starting Transfer Length wwwwwwww"
    
           or
    
              "Target System LBA pppppppp LLL CHS qqqqqq.r.ssss PLP CHS tttttt.u.vvvv"
              "Starting Transfer Length wwwwwwww"
    
           where
    
              pppppppp is the starting Disk Logical Block Address
    
              qqqqqq is the starting Logical Cylinder Address
    
              r is the starting Logical Head Address
    
              ssss is the starting Logical Sector Address
    
              tttttt is the starting Physical Cylinder Address
    
              u is the starting Logical Head Address
    
              vvvv is the starting Physical Sector Address
    
              wwwwwwww is the starting Transfer Length
    
        If Bit 4 is set, the Recovery Status will be displayed as follows.
    
              "Recovered User LBA AAAAAAAA LLL CHS BBBBBB.C.DDDD PLP CHS EEEEEE.F.GGGG"
              "Recovery Flags HHHH Count II"
    
           or
    
              "Recovered System LBA AAAAAAAA LLL CHS BBBBBB.C.DDDD PLP CHS EEEEEE.F.GGGG"
              "Recovery Flags HHHH Count II"
    
           where
    
              AAAAAAAA is the Disk Logical Block Address of the last recovered sector
    
              BBBBBB is the Logical Cylinder Address of the last recovered sector
    
              C is the Logical Head Address of the last recovered sector
    
              DDDD is the Logical Sector Address of the last recovered sector
    
              EEEEEE is the Physical Cylinder Address of the last recovered sector
    
              F is the Logical Head Address of the last recovered sector
    
              GGGG is the Physical Sector Address of the last recovered sector
    
              HHHH are the Recovery Flags reported by the Read/Write code
    
              II is the Recovery Count reported by the Read/Write code
    
        If Bit 5 is set, the Fault Status will be displayed as follows.
    
              "Drive Fault Status JJJJ Preamp Fault Status KKKK"
    
           where
    
              JJJJ is the Drive Fault Status reported by the Read/Write code
    
              KKKK is the Preamp Fault Status reported by the Read/Write code
    
        If Bit 6 is set, the Elapsed Time for the read/write operation will be displayed.
<a name="ELAPSED_TIME"></a>
    
       "Elapsed Time a mins b secs"  or
       "Elapsed Time b.c secs"       or
       "Elapsed Time c.d msecs"
    
    where
    
       a is minutes
       b is seconds
       c is milliseconds
       d is microseconds
    
    

    or

<a name="RD_MISCOMPARE_DATA"></a>
<a name="GENERIC_ERROR"></a>
    If an error occurred, the following information will be displayed.
    
          "DiagError aaaaaaaa "
    
       where
    
          aaaaaaaa is the Diagnostic Error Code
    
           If a data miscompare was detected during a read compare operation, the followed
           information will be displayed.
    
              "DiagError aaaaaaaa"
    
           followed by
    
              "User LBA cccccccc LLL CHS dddddd.e.ffff PLP CHS gggggg.h.iiii"
              "Byte Offset = jjjj Expected = kk Actual = ll"
    
           or
    
              "System LBA cccccccc LLL CHS dddddd.e.ffff PLP CHS gggggg.h.iiii"
              "Byte Offset = jjjj Expected = kk Actual = ll"
    
           where
    
              aaaaaaaa is the Diagnostic Error Code
    
              cccccccc is the Disk Logical Block Address of the sector that miscompared
    
              dddddd is the Logical Cylinder Address of the sector that miscompared
    
              e is the Logical Head Address of the sector that miscompared
    
              ffff is the Logical Sector Address of the sector that miscompared
    
              gggggg is the Physical Cylinder Address of the sector that miscompared
    
              h is the Logical Head Address of the sector that miscompared
    
              iiii is the Physical Sector Address of the sector that miscompared
    
              jjjj is the byte offset from the start of the sector to the byte that miscompared
    
              kk is the expected byte value
    
              ll is the actual byte value
    

  <b><i><u>Examples:</u></i></b>
    Example #1:
       To write and verify a single logical sector
       (in this case logical sector 23 on logical cylinder 45 head 1)

          F3 2>A0
          F3 2>S45,1
          F3 2>723

    Example #2:
       To write and verify multiple logical sectors
       (in this case logical sectors 23 to 26 on logical cylinder 45 head 1)

          F3 2>A0
          F3 2>S45,1
          F3 2>723,4

    Example #3:
       To write and verify all of the logical sectors on a track
       (in this case all logical sectors on logical cylinder 45 head 1)

          F3 2>A0
          F3 2>S45,1
          F3 2>7

    Example #4:
       To write and verify all of the logical sectors on multiple tracks
       (in this case all logical sectors on logical cylinders 45 to 49 head 0)

       Note: You must seek to the track before the first one to be written.

          F3 2>A3
          F3 2>S44,0
          F3 2>L,5
          F3 2>7

    Example #5:
       To write and verify all of the logical sectors on a track and continue on error
       (in this case all logical sectors on logical cylinder 45 head 0)

       Note: An error message will be displayed for each sector in error.

          F3 2>A0
          F3 2>S45,0
          F3 2>7,,,1

    Example #6:
       To write and verify all of the logical sectors in the test space and continue on error

       Note: The Test Space is selected by the all level 'A' command.  An error
       message will be displayed for each sector in error.

          F3 2>7,,,11

    Example #7:
       To write and verify a single physical sector
       (in this case physical sector 32 on physical cylinder 54 head 0)

          F3 2>A0
          F3 2>s54,0,22
          F3 2>732,,,2

    Example #8:
       To write and verify multiple physical sectors
       (in this case physical sectors 32 to 35 on physical cylinder 54 head 0)

          F3 2>A0
          F3 2>s54,0,22
          F3 2>732,4,,2

    Example #9:
       To write and verify all of the physical sectors on a track
       (in this case all physical sectors on physical cylinder 54 head 0)

          F3 2>A0
          F3 2>s54,0,22
          F3 2>7,,,2

    Example #10:
       To write a single logical sector with data at a specific sector offset in the
       diagnostic write buffer, read it to the sector offset in the diagnostic read buffer,
       then compare the data at the sector offset in the diagnostic read buffer against the
       data at the same sector offset in the diagnostic write buffer to verity the data
       (in this case logical sector 23 on logical cylinder 45 head 1,
        write with data at the sector offset of 5 in the diagnostic write buffer,
        read to the sector offset of 5 in the diagnostic read buffer and verify the data)

          F3 2>A0
          F3 2>AF,5
          F3 2>S45,1
          F3 2>723

    Example #11:
       To rotate the buffer sector offset by 1 and write a single logical sector with data at
       the rotated sector offset in the diagnostic write buffer, read it to the rotated
       sector offset in the diagnostic read buffer, then compare the data at the sector
       offset in the diagnostic read buffer against the data at the same sector offset in the
       diagnostic write buffer to verity the data
       (This example assumes user ran the Example #10 above right before this example,
        in this case logical sector 24 on logical cylinder 45 head 1,
        write with data at the sector offset of 6 in the diagnostic write buffer,
        read to the sector offset of 6 in the diagnostic read buffer and verify the data)

          F3 2>724,,,4

  <b><i><u>Revision History:</u></i></b>
<a name="WRITE_VERIFY_CHS_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0001.0001   Eliminated the Enable ZAP Updates and Enable Track Skipping option.
    0001.0002   Added new Rotate Buffer Sector Offset option to the bit 2 of the parameter 3.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<a name="WRITE_WEDGE_CMD_DESCRIPTION"></a>
<!--SUBSECTION--><a name="Write Wedge"></a><hr align=left width="75%"><b> Write Wedge (Level 2 'z' or Level E 'B')</b><hr align=left width="75%">

  <b><i><u>Description:</u></i></b>
    This command writes data to the disk starting at the specified data wedge on the
    target track for the specified number of data wedges.  The wedges are written with
    the data contained in the Diagnostic Write Buffer.  At meanwhile the channel
    registers are sampled, if the register address are specified.

  <b><i><u>Quick Help:</u></i></b>
<a name="WRITE_WEDGE_QUICK_HELP"></a>
       Level 2
    "WrWedge, z[WedgeAddr],[NumWedges],[NumSkipedWedges],[TranSize],[Opt],[RegAddr0],...,[RegAddr13]";
       Level E
    "WrWedge, B[WedgeAddr],[NumWedges],[NumSkipedWedges],[TranSize],[Opt],[RegAddr0],...,[RegAddr13]";

  <b><i><u>Input Parameters:</u></i></b>
<a name="WRITE_WEDGE_PARM"></a>
     0 - Wedge Address.
    
         This parameter specifies the address of the first wedge to be written.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: 0
    
     1 - Transfer Length.
    
         This parameter specifies the number of wedges to be written.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: If the Wedge Address is entered and the Transfer Length is not
                   entered, then only the specified wedge will be written.
    
                   If both the Wedge Address and Transfer Length are not entered,
                   then the Transfer Length will be set based on the Test Space
                   that is selected.  If the Random Transfer Length option is
                   selected, a random value will be used that is less than or
                   equal to the number of wedges remaining on the track.  If the
                   Random Transfer Length option is not selected, the number of
                   wedges remaining on the track will be written.
    
                   If a Transfer Length is entered and not equal to zero, it will
                   be limited to the number of wedges remaining on the track.
    
     2 - Skipped Wedges.
    
         This parameter specifies the number of wedges to skip after each wedge written.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: 0 (Disable wedge skipping)
    
     3 - Wedge Size in NRZ Symbols.
    
         This parameter specifies the number of NRZ symbols to be transfered
         for each wedge.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: 0 (Use native (max) wedge size)
    
     4 - Options.
    
         This parameter is a bit significant value that selects the following options:
    
             Bit 0 - Formatted Wedge Write.
    
                     If this bit is equal to 1, a formatted wedge write operation will
                     be performed.  If this bit is equal to 0, an unformatted wedge write
                     operation will be performed.  A formatted wedge write will write a
                     PLO field and sync mark preceeding the wedge data.  An unfomatted
                     wedge read will not write a PLO field and sync mark preceeding the
                     wedge data.
    
          Type:    Unsigned 32-bit value
    
          Range:   0 to 0xFFFFFFFF
    
          Default: 0x00000001 (Formatted Wedge Write)
    
     5 - Channel Register Address.
    
         This parameter specifies the address of the 1st Read Channel register
         to be read for data collection.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: None
    
     6 - Channel Register Address.
    
         This parameter specifies the address of the 2nd Read Channel register
         to be read for data collection.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: None
    
     7 - Channel Register Address.
    
         This parameter specifies the address of the 3rd Read Channel register
         to be read for data collection.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: None
    
     8 - Channel Register Address.
    
         This parameter specifies the address of the 4th Read Channel register
         to be read for data collection.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: None
    
     9 - Channel Register Address.
    
         This parameter specifies the address of the 5th Read Channel register
         to be read for data collection.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: None
    
    10 - Channel Register Address.
    
         This parameter specifies the address of the 6th Read Channel register
         to be read for data collection.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: None
    
    11 - Channel Register Address.
    
         This parameter specifies the address of the 7th Read Channel register
         to be read for data collection.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: None
    
    12 - Channel Register Address.
    
         This parameter specifies the address of the 8th Read Channel register
         to be read for data collection.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: None
    
    13 - Channel Register Address.
    
         This parameter specifies the address of the 9th Read Channel register
         to be read for data collection.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: None
    
    14 - Channel Register Address.
    
         This parameter specifies the address of the 10th Read Channel register
         to be read for data collection.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: None
    
    15 - Channel Register Address.
    
         This parameter specifies the address of the 11th Read Channel register
         to be read for data collection.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: None
    
    16 - Channel Register Address.
    
         This parameter specifies the address of the 12th Read Channel register
         to be read for data collection.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: None
    
    17 - Channel Register Address.
    
         This parameter specifies the address of the 13th Read Channel register
         to be read for data collection.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: None
    
    18 - Channel Register Address.
    
         This parameter specifies the address of the 14th Read Channel register
         to be read for data collection.
    
          Type:    Unsigned 16-bit value
    
          Range:   0 to 0xFFFF
    
          Default: None
    

  <b><i><u>Output Data:</u></i></b>
<a name="RW_WEDGE_DATA"></a>
    
       If no error occurred and one or more read channel register was specified for data
       collection, the following information will be displayed.
    
             "  RegAddr      aaaa      aaaa      aaaa      ... aaaa"
             "  Min          bbbbbbbb  bbbbbbbb  bbbbbbbb  ... bbbbbbbb"
             "  Max          cccccccc  cccccccc  cccccccc  ... cccccccc"
             "  Mean         dddddddd  dddddddd  dddddddd  ... ddddddddd"
             "  StdDev       eeeeee.ee eeeeee.ee eeeeee.ee ... eeeeee.ee"
    
          where
    
             aaaa is the address of the channel register that was read
    
             bbbbbbbb is the minimum value that was read from the channel register
    
             cccccccc is the maximum value that was read from the channel register
    
             dddddddd is the mean of the values read from the channel register
    
             eeeeee.ee is the standard deviation of the values read from the channel register
    
    
       If no error occurred, one or more read channel register was specified for data
       collection and Raw ASCII output mode is selected, the following additional
       information will be displayed for each wedge and channel register for which data
       was collected.
    
             "Wedge ffff  RegAddr gggg  RegData hhhhhhhh  Error ii"
    
          where
    
             ffff is the wedge address
    
             gggg is the address of the channel register that was read
    
             hhhhhhhh is the value read from the channel register
    
             ii is the error that was logged for the wedge
    
                   00 = No Error
                   04 = Sync Error
    
    
       If no error occurred, no read channel registers were specified for data collection
       and the Continue On Sync Error option was selected, the following additional
       information will be displayed.
    
             "Wedges with Sync Errors: jjjj jjjj jjjj ... jjjj"
    
          where
    
             jjjj is the address of a wedge with a sync error
    
    
<a name="RW_OP_STATUS_OUTPUT_DATA"></a>
        If an error occurred, the following information will be displayed.
    
              "DiagError aaaaaaaa R/W Status c R/W Error dddddddd"
    
           and
    
              "Next User LBA eeeeeeee LLL CHS ffffff.g.hhhh PLP CHS iiiiii.j.kkkk"
              "Remaining Transfer Length llllllll"
    
           or
    
              "Next System LBA eeeeeeee LLL CHS ffffff.g.hhhh PLP CHS iiiiii.j.kkkk"
              "Remaining Transfer Length llllllll"
    
           where
    
              aaaaaaaa is the Diagnostic Error Code
    
              c is the status returned by the R/W subsystem
    
                    0 = R/W request completed successfully with error recovery
                    1 = R/W request completed successfully (no error recovery performed)
                    2 = R/W request failed
    
              dddddddd is the error code returned by the R/W subsystem
    
              eeeeeeee is the Disk Logical Block Address of the sector in error
    
              ffffff is the Logical Cylinder Address of the sector in error
    
              g is the Logical Head Address of the sector in error
    
              hhhh is the Logical Sector Address of the sector in error
    
              iiiiii is the Physical Cylinder Address of the sector in error
    
              j is the Logical Head Address of the sector in error
    
              kkkk is the Physical Sector Address of the sector in error
    
              llllllll is the number of sectors remaining to be read or written
    
        If the Verbose Formatted ASCII Data Output Mode is selected, the Verbose Mode option
        bits will enable the following data to be output when set.
    
           Bit 0:      Enables the R/W Status and R/W Error to be displayed
           Bit 1:      Enable the Next Address to be displayed
           Bit 2:      Enables the Track Position and Track Follow Offset to be displayed
           Bit 3:      Enables the Target Address to be displayed
           Bit 4:      Enables the Recovery Status to be displayed
           Bit 5:      Enables the Fault Status to be displayed
           Bit 6:      Enables the Elapsed Time to be displayed
           Bits 31-7:  NA
    
        If Bit 0 is set, the R/W Status and R/W Error will be displayed even if no error
        occurred.  The data displayed will be formatted as shown above.
    
        If Bit 1 is set, the Next Address will be displayed even if no error occurred.  The
        data displayed will be formatted as shown above.
    
        If Bit 2 is set, the Track Position and Track Follow Offset will be displayed as
        follows.
    
              "Read Position, Persistent Offset m.m% Total Offset n.n%"          or
              "Write Position, Persistent Offset m.m% Total Offset n.n%"         or
              "Write Header Position, Persistent Offset m.m% Total Offset n.n%"
    
           where
    
              m.m is the Persistent Track Follow Offset in units of percentage of track width
    
              n.n is the Total Track Follow Offset in units of percentage of track width
    
        If Bit 3 is set, the Target Address will be displayed as follows.
    
              "Target User LBA pppppppp LLL CHS qqqqqq.r.ssss PLP CHS tttttt.u.vvvv"
              "Starting Transfer Length wwwwwwww"
    
           or
    
              "Target System LBA pppppppp LLL CHS qqqqqq.r.ssss PLP CHS tttttt.u.vvvv"
              "Starting Transfer Length wwwwwwww"
    
           where
    
              pppppppp is the starting Disk Logical Block Address
    
              qqqqqq is the starting Logical Cylinder Address
    
              r is the starting Logical Head Address
    
              ssss is the starting Logical Sector Address
    
              tttttt is the starting Physical Cylinder Address
    
              u is the starting Logical Head Address
    
              vvvv is the starting Physical Sector Address
    
              wwwwwwww is the starting Transfer Length
    
        If Bit 4 is set, the Recovery Status will be displayed as follows.
    
              "Recovered User LBA AAAAAAAA LLL CHS BBBBBB.C.DDDD PLP CHS EEEEEE.F.GGGG"
              "Recovery Flags HHHH Count II"
    
           or
    
              "Recovered System LBA AAAAAAAA LLL CHS BBBBBB.C.DDDD PLP CHS EEEEEE.F.GGGG"
              "Recovery Flags HHHH Count II"
    
           where
    
              AAAAAAAA is the Disk Logical Block Address of the last recovered sector
    
              BBBBBB is the Logical Cylinder Address of the last recovered sector
    
              C is the Logical Head Address of the last recovered sector
    
              DDDD is the Logical Sector Address of the last recovered sector
    
              EEEEEE is the Physical Cylinder Address of the last recovered sector
    
              F is the Logical Head Address of the last recovered sector
    
              GGGG is the Physical Sector Address of the last recovered sector
    
              HHHH are the Recovery Flags reported by the Read/Write code
    
              II is the Recovery Count reported by the Read/Write code
    
        If Bit 5 is set, the Fault Status will be displayed as follows.
    
              "Drive Fault Status JJJJ Preamp Fault Status KKKK"
    
           where
    
              JJJJ is the Drive Fault Status reported by the Read/Write code
    
              KKKK is the Preamp Fault Status reported by the Read/Write code
    
        If Bit 6 is set, the Elapsed Time for the read/write operation will be displayed.
<a name="ELAPSED_TIME"></a>
    
       "Elapsed Time a mins b secs"  or
       "Elapsed Time b.c secs"       or
       "Elapsed Time c.d msecs"
    
    where
    
       a is minutes
       b is seconds
       c is milliseconds
       d is microseconds
    
    
    

  <b><i><u>Examples:</u></i></b>
    Example #1:
       To write a single wedge
       (in this case wedge 23 on logical cylinder 45 head 1)

          F3 2>A0
          F3 2>S45,1
          F3 2>z23

    Example #2:
       To write multiple wedges
       (in this case wedges 23 to 26 on logical cylinder 45 head 1)

          F3 2>A0
          F3 2>S45,1
          F3 2>z23,4

    Example #3:
       To write all of the wedges on a track
       (in this case all wedges on logical cylinder 45 head 1)

          F3 2>A0
          F3 2>S45,1
          F3 2>z

    Example #4:
       To write all of the wedges on multiple tracks
       (in this case all wedges on logical cylinders 45 to 49 head 0)

       Note: You must seek to the track before the first one to be written.

          F3 2>A3
          F3 2>S44,0
          F3 2>L,5
          F3 2>z

  <b><i><u>Revision History:</u></i></b>
<a name="WRITE_WEDGE_REVISION_HISTORY"></a>
    0001.0000   Initial revision.
    0001.0001   Increase the number of channel registers for the data collection.
    0002.0000   Added Formatted Wedge Write option.
    0011.0000   Combined the PSG Diagnostic Error Codes (PSGDEC) and the Diagnostic External
                Test Service Error Codes (DETSEC) into a single set of Diagnostic Error Codes
                (DiagError).

<!--SECTION--><a name="Error Codes/Tracing Information"></a><hr color=black><b><big>  Error Codes/Tracing Information</big></b><hr color=black>
<a name="DIAG_ERROR"></a>
<!--SUBSECTION--><a name="DiagError - Diagnostic Error Codes"></a><hr align=left width="75%"><b> DiagError - Diagnostic Error Codes</b><hr align=left width="75%">
   ******************************************************************************************
    0x0000 - 0x0FFF: Diagnostic Infrastructure Errors
   ******************************************************************************************
    0x0000: No Error
    0x0001: Unsupported Diagnostic Feature
    0x0002: Online Extrinsic Requests are disabled
    0x0003: Diagnostic Mode Extrinsic Requests are disabled
    0x0004: Diagnostic External Test Service Busy
    0x0005: Invalid Diagnostic External Test Service Request
    0x0006: Extrinsic Diagnostic Aborted
    0x0007: File Creation Error
    0x0008: Memory Allocation Error
    0x0009: Unsupported Diagnostic Parameter Revision
    0x000A: Invalid Diagnostic Parameter
    0x000B: Singular Matrix Error
    0x000C: Congen Read Error (Drive Has Probably Never Been "Congened")
    0x000D: Congen Write Error: Error Occurred Saving Mode Packet Header
    0x000E: File Copy Error
    0x000F: Unable to load Diagnostic Overlay
    0x0010: Congen Write Error: Mode Page Length Does Not Match Specified Length
    0x0011: Congen Write Error: Mode Page Check Member Function Returned Failure
    0x0012: Congen Write Error: Attempt To Change Unchangeable Parameter
    0x0013: Incoming SDBP is too small for DSB
    0x0014: Congen Write Error: Writing Mode Data To Disc Failed
    0x0015: Congen Write Error: Writing Partial Mode Data To Disc Failed
    0x0016: Congen Write Error: Writing Complete Mode Data To Disc Failed
    0x0017: Congen Write Error: Unknown Congen Write Error
    0x0018: Congen Reset Error: Reset Congen Failed
    0x0019: Drive must be power cycled
    0x0020: Invalid ASCII Diag Command
    0x0021: Unable to Load Diag Command Processor Overlay
    0x0022: Data Received from Unsupported Test Service
    0x0023: Unsupported Diag Data Type
   
   ******************************************************************************************
    0x1000 - 0x1FFF: Memory Errors
   ******************************************************************************************
    0x1000: Invalid Memory Address
    0x1001: Bad Servo RAM Read
    0x1002: Memory Miscompare Error
    0x1003: Buffer Miscompare Error
   
   ******************************************************************************************
    0x2000 - 0x2FFF: Hardware Errors
   ******************************************************************************************
    0x2000: Unsupported Hardware Feature
    0x2001: Unable to Lock Read Channel
    0x2002: Unable to Unlock Read Channel
    0x2003: Invalid Read Channel Register Address
    0x2004: Read Channel Register Access Error
    0x2005: Unable to Lock Preamp
    0x2006: Unable to Unlock Preamp
    0x2007: Invalid Preamp Register Address
    0x2008: Invalid Read or Write Power ASIC Register Request
    0x2009: Invalid Controller Register Address
    0x200A: Unable to set Preamp Mode
    0x200B: Unable to get Preamp Head Resistance
    0x200C: Controller Register Target Value Out Of Range
    0x200D: Unsupported Controller Register Group
   
   ******************************************************************************************
    0x3000 - 0x3FFF: Drive Geometry Errors
   ******************************************************************************************
    0x3000: Invalid Target Address
    0x3001: Invalid Read/Write Address
    0x3002: Invalid User LBA
    0x3003: Invalid User Logical Cylinder, Logical Head and Logical Sector
    0x3004: Invalid User Logical Cylinder, Logical Head and Physical Wedge
    0x3005: Invalid User Logical Cylinder
    0x3006: Invalid System LBA
    0x3007: Invalid System Logical Cylinder, Logical Head and Logical Sector
    0x3008: Invalid System Logical Cylinder, Logical Head and Physical Wedge
    0x3009: Invalid System Logical Cylinder
    0x300A: Invalid Physical Cylinder, Logical Head and Physical Sector
    0x300B: Invalid Physical Cylinder, Logical Head and Physical Wedge
    0x300C: Invalid Drive Geometry Information
    0x300D: Invalid NRZ Symbol Extent Address
    0x300E: Invalid PBA
    0x300F: Unsupported Media Partition
    0x3010: No Valid Sectors to Transfer on Target Track
    0x3011: Invalid Head
    0x3012: Invalid Logical Mode Access
    0x3013: Invalid Logical Cylinder entered for Particle Sweep
   
   ******************************************************************************************
    0x4000 - 0x4FFF: Native Interface Errors
   ******************************************************************************************
    0x4000: Unsupported Native Interface Feature
    0x4001: Invalid Read Cache Segment Information
    0x4002: Invalid Read Cache Search Engine Information
    0x4003: Invalid Read Cache Most/Least Valuable Indices/Linked List Information
    0x4004: Invalid Read Cache Free Segments Information
    0x4005: Invalid Read Cache Miscellaneous Information
   
   ******************************************************************************************
    0x5000 - 0x5FFF: Read/Write Errors
   ******************************************************************************************
    0x5000: Unsupported Read/Write Feature
    0x5001: Invalid Read/Write Sequence
    0x5002: Read/Write Request Failed
    0x5003: Read Failed
    0x5004: Write Failed
    0x5005: Wedge Read Failed
    0x5006: Wedge Write Failed
    0x5007: Track Erase Failed
    0x5008: Read Miscompare
    0x5009: Pending Block Error
    0x500A: Erase Failed
    0x500B: Diagnostic R/W Buffer too small
    0x500C: Invalid Error Recovery Mode
    0x500D: Format Failed
    0x500E: Process Defect Lists Error
    0x500F: I/F User Table Save Error
    0x5010: R/W Subsysten not Ready to Accept Commands
    0x5011: No Valid Error Recovery Configuration Given Commanded Mode
    0x5012: Drive Free Fall Protection Failed
    0x5013: Particle Sweep Request Failed
   
   ******************************************************************************************
    0x6000 - 0x6FFF: Servo Errors
   ******************************************************************************************
    0x6000: Unsupported Servo Feature
    0x6001: Servo Failure
    0x6002: Servo Command Error
    0x6003: Read past the end of the Servo Symbol Table
    0x6004: Invalid Servo Symbol Table Entry
    0x6005: Missed Fast I/O Sample
    0x6006: No Fast I/O Response
    0x6007: Spin Up request received when spun up
    0x6008: Spin Up Failed
    0x6009: Spin Down request received when spun down
    0x600A: Spin Down Failed
    0x600B: Seek Failed
    0x600D: Micro Jog Table error
   
   ******************************************************************************************
    0x7000 - 0x7FFF: Adaptive Parameter Errors
   ******************************************************************************************
    0x7000: Unsupported Adaptive Feature
    0x7001: Unable to open RAP file
   
    0x7010: Unable to find left side of VGAR vs Track Follow Offset bathtub curve
    0x7011: Unable to find right side of VGAR vs Track Follow Offset bathtub curve
   
   ******************************************************************************************
    0x8000 - 0x8FFF: Logging Errors
   ******************************************************************************************
    0x8000: Invalid Log File
    0x8001: Log Full
    0x8002: Log File Read or Write Failed
   
   ******************************************************************************************
    0x9000 - 0x9FFF: Defect Management Errors
   ******************************************************************************************
    0x9000: Primary Defect List System Disc File Write Error
    0x9001: TA PSFT Defect List System Disc File Write Error
    0x9002: Could not open Format Client Defect List
   
   ******************************************************************************************
    0xA000 - 0xAFFF: Shared Test API Errors
   ******************************************************************************************
    0xA000: Fast IO Initialization Error
    0xA001: Baseline PES collection Error
    0xA002: Delta PES collection Error
   
<a name="RW_REQUEST_TYPE_CODES"></a>
<!--SUBSECTION--><a name="Read/Write Request Type Codes"></a><hr align=left width="75%"><b> Read/Write Request(Command) Type Codes</b><hr align=left width="75%">
<a name="RW_REQUEST_TYPE"></a>
 0x00     SEEK        Seek request
 0x01     XFR_ALT     Read/Write transfer alternate sector request
 0x02     XFR         Read/Write transfer request
 0x03     RD_CHNL     Access Read Channel request
 0x04     SRV_MEM     Access Servo Memory request
 0x05     SRV_FLW     Add Primary Servo Flaw request
 0x06     DITH        Dithering request
 0x07     DITH_WR     Dithering write enhance request
 0x08     CAL         Drive Calibration request
 0x09     ERA_TRK     Erase Track request
 0x0A     FDB         Execute FDB Motor Leakage Detection test request
 0x0B     FMT_TRK     Format Track request
 0x0C     FMT_SYS     Format System Partition request
 0x0D     FMT_UNT     Format Unit request
 0x0E     HD_RES      Get Head Resistance request
 0x0F     HTR_RES     Get Heater Resistance request
 0x10     GET_RVFF    Get Servo RVFF sensor status
 0x11     ACFF_RECAL  ACFF Recalibrate status
 0x12     TEMP        Get Temperature request
 0x13     TWK_FH      Tweak fly height values request
 0x14     VOLT        Get Voltage Levels request
 0x15     HD_DIAG     Head diagnostics test request
 0x16     HD_SPK      Head Spike Screen request
 0x17     REALLOC     Immediate Reallocation request
 0x18     MRK_PND     Mark Block for Pending Reallocation request
 0x19     HD_FH       Measure Head Fly Heights request
 0x1A     VCM_TEMP    Measure VCM Temperature and Resistance request
 0x1B     MEM_DBG     Memory mapped debug capture request
 0x1C     PROC_DL     Process defect lists request
 0x1D     SCRB_DL     Scrub the defect lists request
 0x1E     PROC_GDL    Process growth defect lists request
 0x1F     REF_SRV_MEM Refresh servo memory request
 0x20     RELD_RAP    Reload RAP parameters request
 0x21     ERR_RATE    Measure error rate
 0x22     DL          Retrieve defect list request
 0x23     SRV_EC      Retrieve the servo error code FIFO request
 0x24     SCN_DFCT    Scan defect adjacent sectors request
 0x25     SELF_SK     Self seek request
 0x26     SK_TUNE     Seek profile tuning request
 0x27     SND_SRV     Send servo request
 0x28     FIX_RAP     Fixup RAP for depop request
 0x29     DEPOP       Send Servo Electrical Depop request
 0x2A     INIT_DITH   Initialize Dithering parameters
 0x2B     PES         Servo PES FIFO access request
 0x2C     PREAMP      Set Preamp mode request
 0x2D     SET_VOLT    Configure voltage margin level request
 0x2E     ZAP         Configure the ZAP correction mode request
 0x2F     SPN_UP      Spinup request
 0x30     SPN_DN      Spindown request
 0x31     ZLR         Track ZLR request
 0x32     UNKNOWN     Unsupported request
 0x33     UNMRK       Unmark Block for Pending Reallocation request
 0x34     TCC         Update TCC Manager request
 0x35     ALT_TONE    Write SMART Alternating Tones Request
 0x36     XFR_TRK     Read/Write transfer track request
 0x37     XFR_WDG     Read/Write transfer wedge request
 0x38     PWR         Set R/W Power Management request
 0x39     CLR_ALT     Clear R/W User Alt List request
 0x3A     LATCH       Put heads on the latch request
 0x3B     SV_ALT      Save R/W User Alt List to Media request
 0x3C     MATLAB      Enter Servo Matlab Shell request
 0x3D     SWEEP       Perform sweep of media to knock off particles request
 0x3E     CLR_SLIP    Clear R/W Slip List request
 0x3F     FA_AFH      Field Adjust AFH request
 0x40     TWK_WR_PWR  Tweak write power request
 0x41     SEC2RLL     Convert sector data to RLL data
 0x42     SWD         SWD(Skip Write Detect) Enable/Disable request
 0x43     CLR_ALT_ENT Clear User Alt List Entry request
 0x44     ADJ_CLR     Adjust Target Clearance request
 0x45     FALL        Control drive free-fall protection request
 0x46     XFR_SEC     Read/Write transfer sector request
 0x47     DISC_SLIP   Update servo disc slip parameters request
 0x48     RE_ALT      Restore R/W User Alt List from Media request
 0x49     RST_RVFF    Reset Servo RVFF sensor status request
 0x4A     HST         Head Stability Test
<a name="RW_STATUS_CODES"></a>
<!--SUBSECTION--><a name="Read/Write Status Codes"></a><hr align=left width="75%"><b> Read/Write Status Codes</b><hr align=left width="75%">
<a name="RW_SENSE_STATUS"></a>
 0x0 RW_REQUEST_SATISFIED_WITH_RECOVERY - Request was satisfied with error recovery performed
 0x1 RW_REQUEST_SATISFIED - Request was satisfied (no error recovery performed)
 0x2 RW_REQUEST_FAILED -Request was not satisfied
<a name="RW_SENSE_ERROR_CODES"></a>
<!--SUBSECTION--><a name="Read/Write Sense Error Codes"></a><hr align=left width="75%"><b> Read/Write Sense Error Codes</b><hr align=left width="75%">

 R/W Sense Error Codes are error codes that R/W reports to its clients.  Although they are
 very similar to traditional SCSI sense codes, there is not a one-to-one correspondence with
 traditional SCSI sense codes.  These R/W Sense Error Codes should be treated and interpreted
 independently from them.

 R/W Sense Error Codes may be reported with one or more bits of their most significant nybble
 set.  These bits are described below:

 Bit 31: Move FRU Flag.

         If this bit is set, it indicates that the least significant byte of the sense code
         should be copied into the additional sense code qualifier when it is translated into
         a SCSI sense code.

 Bit 30: Read/Write Retryable Error Type.

         If this bit is set, it indicates that the condition that caused R/W to report the
         R/W Sense Error Code is retryable.  This gives R/W clients an opportunity perform
         higher level retries.  IMPORTANT!  Please note that R/W Sense Error Codes that are
         reported in a diagnostic environment (e.g. serial port debug statements) should
         never be considered hard errors when this bit is set.

   ***************************************************************************
    Internal x0/00 Errors.
   ***************************************************************************
    0x00000080: RW_NO_ERRORS - No R/W Errors encountered.
    0x00000081: RW_REQUEST_ABORTED - Request failed due to abort of request.
    0x00000082: RW_REQUEST_SOFT_ABORTED - Request failed due to soft abort of request.
    0x00000083: RW_DATA_SCRUB_SUCCESSFUL - Reallocate Block - Data scrub of the original sector was successful.
    0x00000084: RW_FILE_ERROR - R/W file error encountered.
    0x00000085: RW_XFR_PARTITION_OVERFLOWED - Disc Xfr - Partition overflowed.
    0x40000087: RW_BLOCK_REALLOCATED_01 - Disc Xfr - Reallocated block encountered.
    0x40000088: RW_BLOCK_REALLOCATED_02 - Disc Xfr - Reallocated block encountered.
    0x40000089: RW_BLOCK_REALLOCATED_03 - Disc Xfr - Reallocated block encountered.
    0x0000008A: RW_FBA_OBTAINED - This is not an error type. Used for HW_ZERO_LATENCY_RW.
    0x0000008B: RW_REQUEST_ABORTED_DUE_TO_INVALID_INPUT - Inputs for the FDB leakage detection test were invalid
    0x0000008C: RW_SERVO_OP_ABORTED - Servo operation was aborted.
    0x0000008D: RW_SUPER_SECTOR_EARLY_DISC_HALT - Super Sector - Early disc halt.
    0x0000008E: RW_POWER_SAVE_INVALID_REQUEST_01 - Power Save - Invalid request.
    0x0000008F: RW_READ_AFTER_WRITE_REQ - Read After Write mode requested
    0x00000090: RW_SWD_DVGAS_FAULT_RAW_REQ - Read After Write mode due to SWD Dvgas fault requested
    0x00000091: RW_SWD_RVGAS_FAULT_RAW_REQ - Read After Write mode due to SWD Rvgas fault requested
    0x00000092: RW_SWD_FVGAS_FAULT_RAW_REQ - Read After Write mode due to SWD Fvgas fault requested
    0x00000093: RW_SWD_DVGAS_SUM_FAULT_RAW_REQ - RAW mode due to SWD Sum fault, last SWD fault was a Dvgas fault, requested
    0x00000094: RW_SWD_RVGAS_SUM_FAULT_RAW_REQ - RAW mode due to SWD Sum fault, last SWD fault was a Rvgas fault, requested
    0x00000095: RW_SWD_FVGAS_SUM_FAULT_RAW_REQ - RAW mode due to SWD Sum fault, last SWD fault was a Fvgas fault, requested
    0x00000096: RW_SERVICE_DRIVE_FREE_FALL_CONDITION_ABORTED - Servicing of free-fall condition was aborted.
    0x00000097: RW_FORMAT_MAX_NUM_SWD_ERRORS_PER_TRACK_EXCEEDED - Format - Number of SWD errors per track exceeded.
    0x00000098: RW_SERVO_DISC_SLIP_RECAL_NOT_ALLOWED - Servo Disc Slip recalibration not allowed.
   
   ***************************************************************************
    Internal x2/04 Errors.
   ***************************************************************************
    0x02040080: RW_NOT_READY - Initialization - R/W system not ready for client requests.
   
   ***************************************************************************
    Internal x3/0C Errors.
   ***************************************************************************
    0x430C0080: RW_UPDATE_BVD_FAILED - Disc Xfr - BVD update error.
    0x430C0081: RW_WRITE_HALT_CORRECTABLE_IOECC_ERR - Disc Xfr - IOECC error (correctable)
   
   ***************************************************************************
    Internal x3/11 Errors.
   ***************************************************************************
    0x43110080: RW_READ_PREAMP_UNSAFE_FAULT - Disc Xfr - Read during preamp unsafe fault.
    0x43110081: RW_EDAC_HW_UNCORR_ERR - Disc Xfr - EDAC HW uncorrectable error.
    0x43110082: RW_EDAC_OVERRUN_ERR - Disc Xfr - EDAC overrun error.
    0x031100A0: RW_READ_PREAMP_HTR_OPEN_SHORT_FAULT
    0x03110480: RW_WRITE_ALTERNATE_FAILED_NO_SERVO_DEFECTS - Reallocate Block - Write alternate block failed, no servo defects.
    0x03110481: RW_ALTERNATE_BLK_COMPARE_TEST_FAILED - Reallocate Block - Alternate block compare test failed.
    0x03110482: RW_ALTERNATE_BLK_SYNC_MARK_ERR - Reallocate Block - Alternate block sync mark error.
    0x03110483: RW_ALTERNATE_BLOCK_SELECTION_EXHAUSTED - Reallocate Block - Maximum allowed alternate selection exhausted.
    0x03110484: RW_REPETITIVE_REALLOCATION_NOT_ALLOWED - Reallocate Block - Resource is not available for a repetitive reallocation.
   
   ***************************************************************************
    Internal x4/09 Errors.
   ***************************************************************************
    0xC4090080: RW_SERVO_FAULT - Servo fault.
    0xC4090081: RW_WRITE_SERVO_UNSAFE_FAULT - Disc Xfr - Write during servo unsafe fault.
    0xC4090082: RW_EDAC_BLK_ADDR_ERR - Disc Xfr - EDAC block address error.
    0xC4090083: RW_SERVO_MDW_INFO_MISSING - Disc Xfr - Missing MDW information reported by servo detected.
    0xC4090084: RW_SERVO_CMD_TIMED_OUT - Servo command timed out.
    0xC4090085: RW_SEEK_TIMED_OUT - Seek operation timed out.
    0xC4090086: RW_SEEK_EXCEED_TIME_LIMIT - Seek operation has exceeded the recovery time limit
    0xC4090087: RW_SERVICE_DRIVE_FREE_FALL_CONDITION_TIMED_OUT - Servicing of free-fall condition timed out.
   
   ***************************************************************************
    Internal x5/24 Errors.
   ***************************************************************************
    0x0524F380: RW_G_TO_P_WHILE_FORMATTED_WITHOUT_PLIST - G->P operation requested while drive was formatted w/o PLIST.
    0x0524F381: RW_SERVO_FLAW_ALREADY_EXISTS - Add Primary Servo Flaw - Servo Flaw already exists in ASFT or PSFT.
   
   ***************************************************************************
    Internal x5/26 Errors.
   ***************************************************************************
    0x05260080: RW_INVALID_CYLINDER_ERR - Validate Sector Position - Invalid input cylinder.
    0x05260081: RW_INVALID_HEAD_ERR - Validate Sector Position - Invalid input head.
    0x05260082: RW_INVALID_SECTOR_ERR - Validate Sector Position - Invalid input sector.
    0x05260083: RW_INVALID_USER_LBA_01 - Perform Address Translation - Input LBA is invalid.
    0x05260084: RW_INVALID_USER_LBA_02 - Perform Address Translation - Input LBA is invalid.
    0x05260085: RW_INVALID_USER_LBA_03 - Perform Address Translation - Input LBA is invalid.
    0x05260086: RW_INVALID_SYSTEM_LBA - Perform Address Translation - Input LBA is invalid.
    0x05260087: RW_CLIENT_DEFECT_LIST_INVALID_SIZE - Format - Client defect list size is invalid.
    0x05260088: RW_CLIENT_DEFECT_LIST_INVALID_OFFSET_SORT - Process Defect Lists - Sort error due to invalid offset.
    0x05260089: RW_CLIENT_DEFECT_LIST_INVALID_HEAD_SORT - Process Defect Lists - Sort error due to invalid head.
    0x0526008A: RW_CLIENT_DEFECT_LIST_INVALID_CYL_SORT - Process Defect Lists - Sort error due to invalid cylinder.
    0x0526008B: RW_CLIENT_DEFECT_LIST_SYMBOL_EXTENT_INFO_ERR - Process Defect Lists - Failed to validate a client specified symbol extent info.
    0x0526008C: RW_CLIENT_DEFECT_LIST_SEC_EXTENT_INFO_ERR - Process Defect Lists - Failed to validate a client specified sector extent info.
    0x0526008D: RW_CLIENT_DEFECT_LIST_INVALID_TRACK - Process Defect Lists - Invalid track in client defect list entry.
    0x0526008E: RW_FTRK_INVALID_TRACK - Track Format - Input track is invalid.
    0x0526008F: RW_FTRK_INVALID_LBA - Track Format - First LBA of input track is invalid.
    0x05260090: RW_INVALID_READ_SERVO_DATA_BLOCK_COUNT - Read Servo Data Block Memory - Invalid length.
    0x05260091: RW_INVALID_READ_SERVO_PROGRAM_BLOCK_COUNT - Read Servo Program Block Memory - Invalid length.
    0x05260092: RW_INVALID_USER_PBA_01 - Perform Address Translation - Input PBA is invalid.
    0x05260093: RW_INVALID_SYMBOL_EXTENT_INFO - Perform Address Translation - Input symbol extent is invalid.
    0x05260094: RW_SUPER_SECTOR_INVALID_WEDGE_XFR_SIZE - Super Sector Transfer - Invalid wedge transfer size.
    0x05260095: RW_TRACK_ZLR_INVALID_PARTITION - Track ZLR Transfer - Invalid partition.
    0x05260096: RW_TRACK_ZLR_INVALID_LBA_RANGE - Track ZLR Transfer - Invalid LBA range on target track.
    0x05260097: RW_TRACK_ZLR_REALLOCATED_LBA_FOUND - Track ZLR Transfer - Reallocated LBA found on target track.
    0x05260098: RW_INVALID_USER_LBA_04 - Perform Address Translation - Input LBA is invalid.
    0x05260099: RW_INVALID_USER_LBA_05 - Perform Address Translation - Input LBA is invalid.
    0x0526009A: RW_CONVERT_SECTOR_TO_RLL_UNSUPPORTED_SECTOR_SIZE - Convert Sector to RLL Data - Unsupported sector size.
    0x0526009B: RW_ADD_SERVO_FLAW_INVALID_INPUT_ENTRY - Add Servo Flaw - Invalid input specified.
    0x0526009C: RW_ENABLE_SERVO_FREE_FALL_PROTECTION_FAILED_DRIVE_NOT_SPINNING - Invalid condition for enabling servo free fall protection (drive not spinning).
    0x0526009D: RW_DISABLE_SERVO_FREE_FALL_PROTECTION_FAILED_DRIVE_NOT_SPINNING - Invalid condition for disabling servo free fall protection (drive not spinning).
    0x0526009E: RW_DISABLE_SERVO_FREE_FALL_PROTECTION_FAILED_PROTECTION_ALREADY_DISABLED - Invalid condition for disabling servo free fall protection (protection already disabled).
    0x0526009F: RW_DISABLE_SERVO_FREE_FALL_PROTECTION_FAILED_PROTECTION_DEACTIVATED - Invalid condition for disabling servo free fall protection (protection already de-activated).
    0x052600A0: RW_DISABLE_SERVO_FREE_FALL_PROTECTION_FAILED_FREE_FALL_ACTIVE - Invalid condition for disabling servo free fall protection (free-fall condition is currently active).
    0x052600A1: RW_INVALID_DRIVE_FREE_FALL_CONTROL_OPTION - Invalid drive free-fall control option specified.
    0x052600A2: RW_CHECK_FREE_FALL_EVENT_FAILED_PROTECTION_NOT_FUNCTIONAL - Check free-fall event failed - protection not functional.
    0x052600A3: RW_SECTOR_XFR_INVALID_SECTOR_RANGE - Invalid sector range specified.
   
   ***************************************************************************
    Internal x3/14 Errors.
   ***************************************************************************
    0x83140180: RW_SEARCH_EXHAUSTED - Disc Xfr - Search exhaust error.
    0x83140181: RW_REALLOCATED_LBA_WRITE_DISALLOWED - Disc Xfr - Reallocated LBA is restricted from write access.
    0x83140182: RW_REALLOCATED_LBA_READ_DISALLOWED - Disc Xfr - Reallocated LBA is restricted from read access.
    0x03140183: RW_RESERVE_ZONE_LOGPAGE_READ_WRITE_FAILURE - Disc Xfr - Reserved zone Read/Write for logpage data is failed.
   
   ***************************************************************************
    Internal x3/16 Errors.
   ***************************************************************************
    0xC3160080: RW_DATA_SYNC_TIMEOUT - Disc Xfr - Data sync timeout error.
    0xC3160081: RW_DISC_FIFO_PARITY_ERR_01 - Disc Xfr - Formatter FIFO parity error.
    0xC3160082: RW_DISC_FIFO_PARITY_ERR_02 - Disc Xfr - Formatter FIFO parity error.
    0xC3160083: RW_SUPER_SECTOR_DATA_SYNC_TIMEOUT - Super Sector - Data sync timeout error.
    0xC3160084: RW_DATA_SPLIT_SYNC_TIMEOUT - Disc Xfr - Data sync timeout error on sector splits.
   
   ***************************************************************************
    Internal x3/32/01 Errors.
   ***************************************************************************
    0x83320180: RW_SAVE_DEFECT_FILES_FAILED - Reallocate Block - Failed to save defect files.
   
   ***************************************************************************
    Internal x4/01 Errors.
   ***************************************************************************
    0x84010080: RW_MEDIA_MGR_SPINUP_ERR - Spinup - Media Manager error encountered.
    0xC4010081: RW_SEQ_DATA_FIELD_TIMEOUT - Disc Xfr - Data field timeout error.
    0xC4010082: RW_MM_TDT_FIFO_CTR_ERR - Disc Xfr - Media Manager's TDT FIFO Counter error.
    0xC4010083: RW_MM_SERVO_CTR_ERR - Disc Xfr - Media Manager's Servo Counter error.
    0xC4010084: RW_MM_LATENCY_ERR - Disc Xfr - Media Manager's Latency error.
    0xC4010085: RW_MM_INDEX_ERR - Disc Xfr - Media Manager's Index error.
    0xC4010086: RW_MM_SERVO_ERR - Disc Xfr - Media Manager's Servo error.
    0x84010087: RW_CLEAR_MM_ERRORS_FAILED - Disc Xfr - Media Manager errors could not be cleared successfully.
    0x84010088: RW_CLEAR_SERVO_INDUCED_MM_ERRORS_FAILED - Disc Xfr - Clearing of MM errors due to a servo error failed.
    0x84010089: RW_SECTOR_WORD_COUNT_ENABLED_ON_SERVO - Disc Xfr - SWCE/SGate overlap error.
    0x8401008A: RW_SEQ_SERVO_GATE_TIMEOUT_01 - Disc Xfr - Servo gate timeout error.
    0x8401008B: RW_SEQ_SERVO_GATE_TIMEOUT_02 - Disc Xfr - Servo gate timeout error.
    0x8401008C: RW_SEQ_SERVO_GATE_TIMEOUT_03 - Disc Xfr - Servo gate timeout error.
    0x8401008D: RW_SEQ_SERVO_GATE_TIMEOUT_04 - Disc Xfr - Servo gate timeout error.
    0x8401008E: RW_SEQ_SERVO_GATE_TIMEOUT_05 - Disc Xfr - Servo gate timeout error.
    0x8401008F: RW_SMART_HANDSHAKE_ERR - Super Sector - Handshake error.
    0x84010090: RW_SMART_SEQ_SGATE_TIMEOUT_01 - Super Sector - Servo gate timeout error.
    0x84010091: RW_SMART_SEQ_SGATE_TIMEOUT_02 - Super Sector - Servo gate timeout error.
    0x84010092: RW_SMART_SEQ_SGATE_TIMEOUT_03 - Super Sector - Servo gate timeout error.
    0x84010093: RW_SMART_SEQ_SGATE_TIMEOUT_04 - Super Sector - Servo gate timeout error.
    0x84010094: RW_ASEEK_REQ_PULSE_SGATE_TIMEOUT - Disc Xfr - Servo gate timeout error during generation of Aseek Req.
    0x84010095: RW_SEQ_BVD_CHECK_TIMEOUT - Disc Xfr - BVD check timeout error.
    0x84010096: RW_SEQ_NRZ_XFR_DONE_TIMEOUT - Disc Xfr - NRZ sequencer completion timeout error.
    0xC4010097: RW_SEQ_MEDIA_MGR_TIMEOUT - Disc Xfr - Sequencer timeout on Media Manager event.
    0xC4010098: RW_NRZ_XFR_MEDIA_MGR_ERR - Disc Xfr - NRZ xfr error on Media Manager event.
    0x84010099: RW_DISC_SEQ_HANDSHAKE_ERR - Disc Xfr - Handshake error.
    0x8401009A: RW_MEDIUM_LATENCY_SYNC_ERR - Disc Xfr - Medium latency sync error.
    0x8401009B: RW_FAST_PES_MISSED_SAMPLE_ERR - Fast IO - Missed servo sample.
    0xC401009C: RW_MM_AASEEK_SYNC_ERR - Disc Xfr - Media Manager's Anticipatory autoseek error.
   
   ***************************************************************************
    Internal x4/03 Errors.
   ***************************************************************************
    0x84030080: RW_DETECT_NEW_SERVO_FLAWS_FAILED - Detect of new servo flaws failed.
    0xC4030081: RW_PSG_FAULT - Disc Xfr - PSG environment fault.
    0xC4030082: RW_SHOCK_DETECT_FAULT - Disc Xfr - Shock event occurred.
    0xC4030083: RW_UEWG_FAULT - Disc Xfr - Unexpected Extended WGATE fault.
    0x84030084: RW_GATED_CHANNEL_FAULT - Disc Xfr - Channel detected fault during write.
    0x84030085: RW_DISC_LOCKED_CLOCK_FAULT - Disc Xfr - Disc Locked Clock fault detected.
    0xC4030086: RW_SWD_DVGAS_FAULT - Disc Xfr - Skip Write Detect Dvgas fault.
    0xC4030087: RW_SWD_RVGAS_FAULT - Disc Xfr - Skip Write Detect Rvgas fault.
    0xC4030088: RW_SWD_FVGAS_FAULT - Disc Xfr - Skip Write Detect Fvgas fault.
   
    The following indicate that the  Sum Threshold was exceeded and the
    name indicates what the last SWD fault that occured was...
   
    0xC4030089: RW_SWD_DVGAS_SUM_FAULT - Disc Xfr - Skip Write Detect Dvgas fault.
    0xC403008A: RW_SWD_RVGAS_SUM_FAULT - Disc Xfr - Skip Write Detect Rvgas fault.
    0xC403008B: RW_SWD_FVGAS_SUM_FAULT - Disc Xfr - Skip Write Detect Fvgas fault.
    0xC403008C: RW_DRIVE_FREE_FALL_EVENT_FAULT - Disc Xfr - Drive free-fall event occurred.
    0xC403008D: RW_LARGE_SHOCK_EVENT_FAULT - Disc Xfer - Large Shock event occured.
   
   ***************************************************************************
    Internal x4/15 Errors.
   ***************************************************************************
    0x84150180: RW_SERVO_SPINUP_FAILED - Spinup - Servo error encountered during drive spin-up.
    0x84150181: RW_SERVO_SPINDOWN_FAILED - Spindown - Servo error encountered during drive spin-up.
    0x84150182: RW_SPINDLE_FAILED - Spindle failed error.
    0x84150183: RW_UNRECOVERED_SEEK - Seek - Unrecovered seek error encountered.
    0x84150184: RW_SERVO_CMD_FAILED - Servo command failed.
    0xC4150185: RW_HEATER_CONTROL_FAILED - Servo heater timing failed.
    0x84150186: RW_SERVO_FREE_FALL_PROTECTION_CMD_FAILED - Servo Free-Fall Protection command failed.
    0x84150187: RW_SERVO_DISC_SLIP_FULL_TMFF_RECAL_FAILED - Servo Disc Slip Full TMFF recalibration failed.
    0x84150188: RW_SERVO_DISC_SLIP_HDSWITCH_TIMING_RECAL_FAILED - Servo Disc Slip Head Switch Timing recalibration failed.
    0x84150189: RW_SERVO_DISC_SLIP_HDSWITCH_TRACK_RECAL_FAILED - Servo Disc Slip Head Switch Track recalibration failed.
   
   ***************************************************************************
    Internal x4/19 Errors.
   ***************************************************************************
    0x84190080: RW_FORMAT_RECOVER_SAVED_GROWN_DST_FAILED - Format - Recover of saved Grown DST file failed.
    0x84190081: RW_DEFECT_SCAN_INIT_DEFECT_LISTS_FAILED - Scan Defect - Recovery of saved Non-Resident DST failed.
    0x84190082: RW_CLEAR_SLIP_LIST_SAVE_RW_OPERATING_PARMS_FILE_FAILED - Clear R/W Slip List - Save of R/W Operating Parmaters file failed.
    0x84190083: RW_RESTORE_ALT_LIST_FILE_FROM_MEDIA_FAILED - Restore Alt List File From media - Failed restoration from media file.
    0x84190084: RW_SERVO_DISC_SLIP_PARMS_MEDIA_UPDATE_FAILED - Save of Servo Disc Slip Parms to media failed.
    0x84190085: RW_SERVO_DISC_SLIP_PARMS_MEDIA_READ_FAILED_01 - Read of Servo Disc Slip Parms from media failed.
    0x84190086: RW_SERVO_DISC_SLIP_PARMS_MEDIA_READ_FAILED_02 - Read of Servo Disc Slip Parms from media failed.
    0x84190087: RW_SERVO_DISC_SLIP_FILE_INVALID_FORMAT_REVISION - Servo Disc Slip file - invalid format revision.
   
   ***************************************************************************
    Internal x4/1C Errors.
   ***************************************************************************
    0x841C0081: RW_READ_PRIMARY_DEFECT_LISTS_SUPER_FILE_FOR_REPORTING - Format - Failure to read Primary Defect Lists Super file for reporting.
    0x841C0082: RW_PLIST_FILE_INVALID_ENTRY_CNT_01 - Format - Invalid entry count in Plist file.
    0x841C0083: RW_PLIST_ENTRY_INVALID_SYMBOL_EXTENT - Format - Invalid symbol extent value in Plist entry.
    0x841C0084: RW_PRIMARY_DEFECT_LIST_INVALID_OFFSET_SORT - Process Defect Lists - Sort error due to invalid offset.
    0x841C0085: RW_PRIMARY_DEFECT_LIST_INVALID_HEAD_SORT - Process Defect Lists - Sort error due to invalid head.
    0x841C0086: RW_PRIMARY_DEFECT_LIST_INVALID_CYL_SORT - Process Defect Lists - Sort error due to invalid cylinder.
    0x841C0087: RW_PRIMARY_DEFECT_FILES_UNRECOVERABLE - Process Defect Lists - Unable to recover the Primary Defect files.
    0x841C0088: RW_REASSIGN_SEEK_TO_DEFECT_FILES_FAILED - Reallocate Block - Failed to seek to defect files for reassign.
    0x841C0089: RW_UNDO_REASSIGN_SEEK_TO_DEFECT_FILES_FAILED - Reallocate Block - Failed to seek to defect files for undo-reassign.
    0x841C008A: RW_WRITE_SAVED_DEFECTS_REPORT_LISTS_FILE_FAILED - Format - Failure to write defects report lists file to media.
    0x841C008B: RW_READ_SAVED_DEFECTS_REPORT_LISTS_FILE_FAILED - Retrieve Defects Report List - Read of defects report file from media failed.
    0x841C008C: RW_SAVED_DEFECTS_REPORT_LISTS_DISC_FILE_INVALID_01 - Retrieve Defects Report List - An invalid defects report file is encountered.
    0x841C008D: RW_SAVED_DEFECTS_REPORT_LISTS_DISC_FILE_INVALID_02 - Retrieve Defects Report List - An invalid defects report file is encountered.
    0x841C008E: RW_FORMAT_RESTORE_RW_OPERATING_PARMS_FILE_FAILED - Format - Restore of R/W User Operating Parameters file failed.
    0x841C008F: RW_FORMAT_INVALID_PRIMARY_SERVO_FLAWS_DATA - Format - Invalid Primary Servo Flaws data encountered.
    0x841C0090: RW_SAVE_DEFECT_FILES_FAILED_DUE_TO_DATA_MISCOMPARE_ERR - Reallocate Block - Failed to save defect files due to miscompare error.
    0x841C0092: RW_PRIMARY_DEFECT_LIST_FILE_OVERFLOW_01 - Format - PList overflow error while merging PSFT and PList for reporting.
    0x841C0093: RW_FORMAT_MAX_ZONE_RECERTIFY_PASSES_EXCEEDED - Format - maximum certify passes of a zone exceeded.
    0x841C0094: RW_FORMAT_MAX_ZONE_REWRITE_PASSES_EXCEEDED - Format - maximum write passes of a zone exceeded.
    0x841C0095: RW_PRIMARY_SERVO_FLAWS_LIST_UNRECOVERABLE - Primary Servo Flaws data retrieval - Unable to read file on disc.
    0x841C0096: RW_PRIMARY_FLAWS_FILE_INVALID_ENTRY_CNT - Primary Servo Flaws data retrieval - Invalid entry count in file.
    0x841C0097: RW_DEFECTIVE_SECTORS_LIST_UNRECOVERABLE - Defective Sectors List data retrieval - Unable to read file on disc.
    0x841C0098: RW_DEFECTIVE_SECTORS_LIST_INVALID_FILE_HEADER - Defective Sectors List data retrieval - Invalid file header data.
    0x841C0099: RW_PLIST_FILE_INVALID_ENTRY_CNT_02 - PList data retrieval - Invalid entry count in Plist file.
    0x841C009A: RW_PRIMARY_DEFECTS_LIST_UNRECOVERABLE - PList data retrieval - Unable to read Plist file on disc.
    0x841C009B: RW_SYSTEM_FORMAT_CLIENT_LIST_INVALID_ENTRY_CNT - System Format - invalid entry count.
   
   ***************************************************************************
    Internal x4/32/00 Errors.
   ***************************************************************************
    0x84320080: RW_PROCESS_FORMAT_PENDING_REALLOCATION_FAILED - Format - Processing of pending reallocation failed.
    0x84320081: RW_INSERT_DST_FAILED - Format - Failed to insert defect to DST.
    0x84320082: RW_DST_INSERT_PLIST_DEFECTS_FAILED - Format - Failed to insert PList defect to DST.
    0x84320083: RW_GROWN_DST_FULL_01 - Format - Grown DST file full.
    0x84320084: RW_GROWN_DST_FULL_02 - Format - Grown DST file full.
    0x84320085: RW_RESIDENT_DST_FULL - Format - Resident DST file full.
    0x84320086: RW_INSERT_FORMAT_GROWN_FLAW_DEFECTS_FAILED - Format - Failed to insert defective sectors assoicated w/grown servo flaw.
    0x84320088: RW_INSERT_SYSTEM_FLAW_DEFECTS_FAILED - Format System Partition - Failed to insert defective system sectors associated w/ grown servo flaw.
    0x8432008A: RW_SYSTEM_DEFECTS_FILE_FULL - Format System Parition - System Defects file full.
    0x8432008B: RW_CLIENT_DEFECT_INSERT_IN_DEFECT_LIST_ERR - Process Defect Lists - Failed to insert a client specified defect in the defect file.
    0x8432008C: RW_ASFT_MAX_FLAWS_PER_TRK_EXCEEDED_01 - ASFT - Max # of servo flaws per track exceeded (path #1).
    0x8432008D: RW_ASFT_MAX_FLAWS_PER_TRK_EXCEEDED_02 - ASFT - Max # of servo flaws per track exceeded (path #2).
    0x8432008E: RW_ASFT_FULL_01 - Defect Management - ASFT full (path #1).
    0x8432008F: RW_ASFT_FULL_02 - Defect Management - ASFT full (path #2).
    0x84320090: RW_ADD_PENDING_REAS_LBA_FAILED - Defect Management - Addition to Reassign Pending List failed.
    0x84320091: RW_INITIAL_REALLOCATION_NOT_ALLOWED - Reallocate Block - Resource is not available for a new reallocation.
    0x84320092: RW_ALTERNATE_NOT_AVAILABLE - Reallocate Block - No alternates available.
    0x84320093: RW_INSERT_POST_FORMAT_GROWN_FLAW_DEFECTS_FAILED - Reallocate Block - Failed to insert defective sectors associated w/grown servo flaw.
    0x84320094: RW_INSERT_COMPROMISED_DEFECTS_FAILED - Format - Failed to deallocate compromised defects.
    0x84320095: RW_INSERT_SYSTEM_COMPROMISED_DEFECTS_FAILED - Format System Partition - Failed to deallocate compromised.
    0x84320096: RW_DDT_INSERT_ENTRY_FAILED - Insertion of DDT entry failed.
    0x84320097: RW_CDDT_FILE_FULL - Compressed DDT file full.
    0x84320098: RW_INSERT_FORMAT_PRIMARY_FLAW_DEFECTS_FAILED - Format - Failed to insert defective sectors associated w/primary servo flaw.
    0x84320099: RW_DEFECTIVE_TRACKS_INSERT_GROWN_DEFECTS_FAILED - Defective Tracks List - Failed to insert grown defective sectors associated w/defective track.
    0x8432009A: RW_DEFECTIVE_TRACKS_INSERT_PRIMARY_DEFECTS_FAILED - Defective Tracks List - Failed to insert primary defective sectors associated w/defective track.
    0x8432009B: RW_DEFECTIVE_TRACKS_LIST_FULL - Defective Tracks List - Failed to add new entry to list.
    0x8432009D: RW_PARTIAL_REALLOCATION_NOT_ALLOWED - Reallocate Block - Resource is not available for a partial reallocation.
    0x8432009E: RW_BIPS_ALLOCATION_NOT_ALLOWED - BIPS - Not enough non-defective sectors to allocate for BIPS parity Sectors.
    0x8432009F: RW_BIPS_DDT_OPERATION_FAILED_01 - BIPS - BIPS defect DDT table operation failed.
    0x843200A0: RW_BIPS_DDT_OPERATION_FAILED_02 - BIPS - BIPS defect DDT table operation failed.
    0x843200A1: RW_SWD_ERRS_TRACK_DEFECTS_INSERT_DST_FAILED - Format - Failed to add defective track to DST.
    0x843200A2: RW_ALTERNATE_NOT_AVAILABLE_02 - Format - Failed to allocate spare sectors.
   
   ***************************************************************************
    Internal x4/32/01 Errors.
   ***************************************************************************
    0x04320181: RW_PRIMARY_DEFECT_LIST_FILE_OVERFLOW_02 - Process Growth Defect List - PList file overflow error.
    0x84320182: RW_PRIMARY_SERVO_FLAW_TABLE_OVERFLOW - Process Defect Lists - PSFT file overflow error.
    0x84320183: RW_PRIMARY_DEFECT_FILES_UNWRITABLE - Process Defect Lists - Unable to write defect files.
    0x84320184: RW_OPERATING_PARAMETERS_FILE_UPDATE_ERROR - Process Defect Lists - Unable to update operating parms file.
    0x04320185: RW_PRIMARY_DEFECT_LIST_FILE_OVERFLOW_03 - Pad/Fill Defects - PList file overflow error.
    0x04320186: RW_PRIMARY_DEFECT_LIST_FILE_OVERFLOW_04 - Pad/Fill Defects - PList file overflow error.
   
   ***************************************************************************
    Internal x4/40 Errors.
   ***************************************************************************
    0x84400080: RW_MAX_TRK_REWRITE_DURING_CERT_RETRIES_EXCEEDED - Format - Exceeded maximum number of track rewrite during certify retries.
   
   ***************************************************************************
    Internal x4/44 Errors.
   ***************************************************************************
    0xC4440080: RW_WRITE_PREAMP_UNSAFE_FAULT - Disc Xfr - Write during preamp unsafe fault.
    0x84440081: RW_READ_WRITE_CHANNEL_FAULT - Disc Xfr - Read channel fault.
    0x84440082: RW_SFF_FAULT - Disc Xfr - Small form factor fault.
    0xC4440083: RW_WRITE_SERVO_FIELD_FAULT - Disc Xfr - Write during servo field fault.
    0xC4440084: RW_MM_TPBA_FIFO_CTR_ERR - Disc Xfr - Media Manager's TPBA FIFO Counter error.
    0xC4440085: RW_MM_TPBA_FIFO_UNDRN_ERR - Disc Xfr - Media Manager's TPBA FIFO Underrun error.
    0xC4440086: RW_MM_DDT_FIFO_CTR_ERR - Disc Xfr - Media Manager's DDT FIFO Counter error.
    0x84440087: RW_MM_DDT_FIFO_UNDRN_ERR - Disc Xfr - Media Manager's DDT FIFO Underrun error.
    0x84440088: RW_MM_PARITY_ERR - Disc Xfr - Media Manager's Parity error.
    0x84440089: RW_MM_TDT_FIFO_UNDRN_ERR - Disc Xfr - Media Manager's TDT FIFO Underrun error.
    0xC444008A: RW_MM_SKIP_MASK_UNDRN_ERR - Disc Xfr - Media Manager's Skip Mask Underrun error.
    0x8444008B: RW_TEMPERATURE_INVALID - Get Temperature request resulted in invalid temperature.
    0x8444008C: RW_VOLTAGE_MARGIN_HW_NOT_SUPPORTED - Detected unsupported H/W in a Set Voltage Margin request.
    0x8444008E: RW_SMART_SEQ_INIT_BUFFER_NOT_READY - Super Sector - Initial buffer ready timeout error.
    0x8444008F: RW_CORR_BUFR_PARITY_ERR - Disc Xfr - Correction Buffer parity error.
    0x84440090: RW_NX_RLL1_ERR - Disc Xfr - NX - RLL1 error.
    0x84440091: RW_DISC_BUFR_PARITY_ERR - Disc Xfr - Disc Buffer parity error.
    0x84440092: RW_SEQ_EXE_SGATE_OVERLAP_ERR - Disc Xfr - Sequencer encountered an EXE/SGATE overlap error.
    0x84440093: RW_NRZ_INTF_FIFO_UNDRN - Disc Xfr - FIFO underrun error detected at the NRZ interface.
    0x84440094: RW_NRZ_INTF_FIFO_OVRN - Disc Xfr - FIFO overrun error detected at the NRZ interface.
    0x84440095: RW_NRZ_INTF_WRT_PARITY - Disc Xfr - Write data parity error detected at the NRZ interface.
    0x84440096: RW_MM_MX_OVERRUN_ERR - Disc Xfr - Media Manager's MX Overrun error.
    0x84440097: RW_MM_NX_OVERRUN_ERR - Disc Xfr - Media Manager's NX Overrun error.
    0x84440098: RW_MM_TDT_REQUEST_ERR - Disc Xfr - Meida Manager's TDT Request error.
    0x84440099: RW_MM_SST_OVERRUN_ERR - Disc Xfr - Media Manager's SST Overrun error.
    0x8444009A: RW_PZT_CALIBRATION_FAILED - Servo PZT calibration failed.
    0x8444009B: RW_SERVO_FAST_IO_DATA_UPDATE_TIMEOUT - Fast I/O - Servo data update timeout error.
    0x8444009C: RW_SERVO_FAST_IO_FIRST_WEDGE_DATA_AVAILABLE_TIMEOUT - Fast I/O - First wedge servo data timeout error.
    0x844400A0: RW_WRITE_PREAMP_HTR_OPEN_SHORT_FAULT
   
   ***************************************************************************
    Internal x4/41/87 Errors.
   ***************************************************************************
    0x04418780: RW_IOEDC_ERROR_WITHOUT_IOECC_ERROR_ON_WRITE - Disc Xfr - IOEDC parity error on write.
    0x04418701: RW_IOEDC_ERROR_ON_WRITE_FDE - 04/8087, FRU 01 - FDE IOEDC Error on Write detected by the FDE logic
    0x04418781: RW_IOEDC_IOECC_PARITY_ERR_ON_WRITE - Disc Xfr - IOExC parity error on write.
    0x04418782: RW_IOECC_PARITY_ERROR_ON_WRITE - Disc Xfr - IOECC parity error on write.
   ***************************************************************************
    Internal x4/80/89 Errors.
   ***************************************************************************
    0x84418980: RW_IOEDC_PARITY_ERR_ON_READ - Disc Xfr - IOEDC parity error on read.
   
   ***************************************************************************
    Internal x4/80/87 Errors.
   ***************************************************************************
    0x04808780: RW_IOEDC_ERROR_WITHOUT_IOECC_ERROR_ON_WRITE - Disc Xfr - IOEDC parity error on write.
    0x04808701: RW_IOEDC_ERROR_ON_WRITE_FDE - 04/8087, FRU 01 - FDE IOEDC Error on Write detected by the FDE logic
    0x04808781: RW_IOEDC_IOECC_PARITY_ERR_ON_WRITE - Disc Xfr - IOExC parity error on write.
    0x04808782: RW_IOECC_PARITY_ERROR_ON_WRITE - Disc Xfr - IOECC parity error on write.
   
   ***************************************************************************
    Internal x4/80/89 Errors.
   ***************************************************************************
    0x84808980: RW_IOEDC_PARITY_ERR_ON_READ - Disc Xfr - IOEDC parity error on read.
   
   ***************************************************************************
    Internal x9/80 Errors.
   ***************************************************************************
    0x89800082: RW_UNSUPPORTED_FAULT - Unsupported fault.
    0x89800083: RW_TRACK_ADDR_FAULT - Track address fault.
    0x89800084: RW_SERVO_DISC_SYNC_ERR - Disc Xfr - Servo-Disc synchronization error.
    0x89800085: RW_UNKNOWN_ENDING_BLK_ADDR - Disc Xfr - End of transfer reached prematurely.
    0x89800086: RW_UNKNOWN_SEQ_TIMEOUT_ERR - Disc Xfr - Unexpected sequencer timeout error.
    0x89800087: RW_UNKNOWN_NRZ_XFR_ERR - Disc Xfr - Unknown error in the NRZ Transfer logic.
    0x89800088: RW_UNKNOWN_EDAC_ERR - Disc Xfr - Unknown EDAC error.
    0x89800089: RW_UNKNOWN_MM_ERR - Disc Xfr - Unknown Media Manager's error.
    0x8980008A: RW_INVALID_DISC_HALT - Disc Xfr - Invalid disc halt.
    0x8980008B: RW_UNEXPECTED_SEQ_HALT - Disc Xfr - Unexpected sequencer halt condition.
    0x8980008C: RW_UNEXPECTED_SMART_SEQ_HALT - Super Sector - Unexpected sequencer halt.
    0x8980008D: RW_UNKNOWN_SMART_SEQ_TIMEOUT_ERR - Super Sector - Unknown sequencer timeout error.
    0x8980008E: RW_UNKNOWN_NRZ_INTF_ERR - Disc Xfr - Unknown NRZ interface error.
    0x8980008F: RW_XFR_SOFT_HALTED - Disc Xfr - Disc was soft halted.
    0x89800090: RW_XFR_FAULT - Disc Xfr - Fault condition error.
    0x89800091: RW_CORR_BFR_COMPLETION_TIMEOUT - Disc Xfr - Correct Buffer Completion timeout error.
    0x89800094: RW_RECOVERED_SEEK - Seek - Recovered seek error encountered.
    0xC9800095: RW_FORCED_ER_BEFORE_ERROR_ENCOUNTERED - Forced to enter error recvoery before error is encountered.
    0x89800096: RW_RECOVERED_SERVO_CMD - Recovered servo command error.
    0x89800097: RW_PARTIAL_REALLOCATION_PERFORMED - Reallocate Block - Partial reallocation performed.
    0x89800098: RW_XFR_TRUNCATED - Disc Xfr - Transfer was truncated.
    0x89800099: RW_XFR_SATISFIED - Disc Xfr - Transfer completed.
    0x8980009A: RW_XFR_TRACK_SATISFIED - Disc Xfr - Track transfer completed.
    0x8980009B: RW_SCAN_DEFECT_ADJ_SECTORS_TIME_EXCEEDED - Scan Defect - Allocated scan time exceeded.
    0x8980009C: RW_IOEDC_IOECC_PARITY_ERR_ON_WRITE - Disc Xfr - IMPOSSIBLE - IOECC parity error on write
    0x8980009D: RW_IOECC_PARITY_ERROR_ON_WRITE - Disc Xfr - IMPOSSIBLE - IOECC parity error on write
    0x8980009E: RW_WRITE_HALT_CORRECTABLE_IOECC_ERR - Disc Xfr - IMPOSSIBLE - IOECC error (correctable)
    0x8980009F: RW_EDAC_HALTED_FOR_FW_ERASURE
    0x898000A0: RW_INVALID_BLOCK_FOR_UNMARK_PENDING_REALLOCATION - Reallocate Block - Input was not marked for pending reallocation.
    0x898000A1: RW_INPUT_LBA_NOT_FOUND_IN_RST - RST Mgr - Input LBA was not found in the RST.
    0x898000A2: RW_RESIDENT_DST_DOES_NOT_CONTAIN_TARGET_PBA_01 - DST Mgr - Input PBA was not found in the resident DST.
    0x898000A3: RW_RESIDENT_DST_DOES_NOT_CONTAIN_TARGET_PBA_02 - DST Mgr - Input PBA was not found in the resident DST.
    0x898000A4: RW_DST_SKOOTCH_FAILED_01 - DST Mgr - Skootch failed.
    0x898000A5: RW_DST_SKOOTCH_FAILED_02 - DST Mgr - Skootch failed.
    0x898000A6: RW_DST_INSERT_FAILED - DST Mgr - Insert failed.
    0x898000A7: RW_CORRECTION_BUFFER_ERR - Correction Buffer over-run, under-run, or EDC error.
   
   ***************************************************************************
    Internal xE/1D Errors.
   ***************************************************************************
    0x8E1D0080: RW_DATA_MISCOMPARE_01 - Disc Xfr - Data miscompare error.
    0x8E1D0081: RW_DATA_MISCOMPARE_02 - Disc Xfr - Data miscompare error at erasure correction.
   
   ***************************************************************************
    Internal x1/40 Errors.
   ***************************************************************************
    0x81400280: RW_SERVO_SPINUP_RECOVERED_01 - Spinup error recovered with buzz retries.
    0x81400281: RW_SERVO_SPINUP_RECOVERED_02 - Spinup error recovered without buzz retries.
   
<a name="RW_RETRY_CHARACTERS"></a>
<!--SUBSECTION--><a name="Read/Write Retry Characters"></a><hr align=left width="75%"><b> Read/Write Retry Characters</b><hr align=left width="75%">
    '*': PATH_ERROR_CHAR - DERP illegal path
    '#': RESET_FIR_RECOV_CHAR - Reset FIR tweak recovery character
    '~': SM_TOLERANCE_RECOV_CHAR - Sync mark tolerance recovery character
    ')': POST_ACQUIRE_RECOV_CHAR - Post acquire recovery character
    '(': TRACKING_PLO_RECOV_CHAR - Tracking PLO tweak recovery character
    '$': TRACKING_PLO_SLIP_RECOV_CHAR - Tracking PLO SLIP tweak recovery character
    ';': DERP_READ_RECOV_CHAR - Data recovery character
    '"': ZGS_VGA_RECOV_CHAR
    '&': ID_SPLASH_RETRY_CHAR - Splash retry char
    '.': DATA_RECOV_CHAR - Data recovery character
    '%': DATA_SCRUB_FIRST_WRITE_1
    '2': DATA_SCRUB_FIRST_WRITE_2
    '1': DATA_SCRUB_SECOND_WRITE
    '1': DATA_SCRUB_READ
    '@': DATA_SCRUB_ATTEMPTS_EXCEEDED
    'a': ACQUIRE_PLO_RECOV_CHAR - Acquire PLO recovery character
    'B': BURNISH_RETRY_CHAR
    'b': FILTER_RECOV_CHAR - Filter tweak recovery character
    'C': CHANNEL_RELOAD_CHAR - Channel Reload recovery
    'c': ECC_OTF_RECOV_CHAR - ECC on-the-fly correction performed character
    'D': RG_DELAY_CHAR - RG Delay
    'D': SWD_DVGAS_RECOV_CHAR
    'd': CLEARANCE_RETRY_CHAR - Clearance value adjusted during recovery
    'E': EP0_RETRY_CHAR
    'e': EP3_RETRY_CHAR
    'F': CLEARANCE_RETRY_CHAR - Clearance value adjusted during recovery
    'F': AGC_RECOV_CHAR - AGC tweak recovery character
    'f': RESET_FIR_RECOV_CHAR - Reset FIR tweak recovery character
    'G': FORCED_NLFR_RECOV_CHAR - Forced NLFR tweak recovery character
    'g': TRACKING_PLO_RECOV_CHAR - Tracking PLO tweak recovery character
    'H': FILTER_RECOV_CHAR - Filter tweak recovery character
    'h': AGC_RECOV_CHAR - AGC tweak recovery character
    'h': LOW_SYNC_MARK_TOL_RECOV_CHAR - Low sync mark tolerance tweak recovery character
    'i': IOEDC_RECOV_CHAR - IOEDC recovery character
    'j': EP2_RETRY_CHAR
    'k': HEATER_CONTROL_FAULT_RECOV_CHAR
    'L': SERVO_FORCE_COAST_RETRY_CHAR
    'M': MR_BIAS_RETRY_CHAR - MR bias tweak retry character
    'm': SM_TOLERANCE_RECOV_CHAR - Sync mark tolerance recovery character
    'N': SECOND_SYNC_RETRY_CHAR
    'P': POST_ACQUIRE_RECOV_CHAR - Post acquire recovery character
    'n': FORCED_NLFR_RECOV_CHAR - Forced NLFR tweak recovery character
    'N': DERP_NEW_SEQ_CHAR - Shows start of new DERP sequence
    'N': FORCED_NEG_SYNC_RETRY_CHAR - Forced Negitive Sync retry char
    'O': OFFSET_ISSUED_CHAR
    'o': OFFSET_RETRY_CHAR
    'P': FORCED_POS_SYNC_RETRY_CHAR - Forced Positive Sync retry char
    'p': ACQUIRE_PLO_RECOV_CHAR - Acquire PLO recovery character
    'p': PFAST_RETRY_CHAR - Power chop/pfast retry character
    'Q': EP1_RETRY_CHAR
    'q': WRITE_SERVO_UNSAFE_RECOV_CHAR - Servo unsafe error recovery character
    'S': SEEK_AWAY_RETRY_CHAR
    's': LARGE_SHOCK_EVENT_RETRY_CHAR - Retry done to recover form a Large Shock Event
    'T': SOFT_EP_RETRY_CHAR
    't': SETUP_TA_MODE_RECOV_CHAR - Setup TA modes Character
    'u': DERP_CHAN_UNTWEAK_CHAR - Channel Untweak
    'V': REV_POL_RETRY_CHAR - Reverse Polarity retry character
    'v': RW_PRINT_RETRY_VIBRATION_DETECTION_WRITE
    'V': RW_PRINT_RETRY_VIBRATION_WRITE
    'U': SWD_FVGAS_RECOV_CHAR - Skip Write Detect recovery characters
    'V': SWD_RVGAS_RECOV_CHAR
    'W': SLIDING_WINDOW_RETRY_CHAR
    'w': WRITE_RECOV_CHAR - Write recovery character
    'Y': PREAMP_UNSAFE_RECOV_CHAR - Preamp unsafe recovery character
    'Z': TRACK_OFFSET_RETRY_CHAR
    'z': ZAP_ENABLE_DISABLE_CHAR - Indicates zap enabled/disabled
    '|': PZT_RECAL_RETRY_CHAR
   
<a name="FLASH_LED_CODES"></a>
<!--SUBSECTION--><a name="Flash LED Codes"></a><hr align=left width="75%"><b>Flash LED Codes</b><hr align=left width="75%">

Codes marked (++) are duplicated in sys.i for assembly language wrappers.
Codes marked (**) are converted to FRU codes for reporting in sense data.

0x00 INVALID_FLASH_LED_CODE            00000000 (**) Invalid flash code
0x08 MICRO_FAIL                        00001000 (++) ARM failure, Unexpected FIQ interrupt
0x0B BUFFER_FAIL                       00001011 (++) DRAM failed powerup or WRAM fail.
0x0C SCC_FAIL                          00001100 (**) Controller failed power up diagnostics
0x0D CTLR_VERSION_FAIL                 00001101 Controller not compatible with firmware
0x0E UNOPCODE_OCCUR                    00001110 (**) Unimplemented Opcode interrupt

0x10 XOR_FAIL                          00010000 (**) XOR power up test failed (tested even on non-XOR code)
0x12 PROG_ERR_EVEN                     00010010 EEPROM verify error, even byte
0x13 ERASE_ERR_EVEN                    00010011 EEPROM erase error, even byte
0x14 DL_TPM_FAIL_0                     00010100 TPM could not program EEPROMs
0x15 DL_TPM_FAIL_1                     00010101 TPM could not program EEPROMs
0x16 DL_TPM_FAIL_2                     00010110 TPM could not program EEPROMs
0x17 DL_TPM_FAIL_3                     00010111 TPM could not program EEPROMs
0x18 DL_TPM_FAIL_4                     00011000 TPM could not program EEPROMs
0x19 DL_TPM_FAIL_5                     00011001 TPM could not program EEPROMs
0x1A DL_TPM_FAIL_6                     00011010 TPM could not program EEPROMs
0x1B DL_TPM_FAIL_7                     00011011 TPM could not program EEPROMs
0x1C DL_TPM_FAIL_8                     00011100 TPM could not program EEPROMs
0x1D DWNLD_VFLT                        00011101 Download voltage fault

0x40 ALU_BUFPE_FAIL                    01000000 ALU buffer parity error
0x42 ERROR_INJECTION_ASSERT_CODE       01000010 Assert code reported when an assert event is triggered
                                                by error injection and no assert code has been given.
0x44 BUF_CFG_FAIL                      01000100 DRAM configuration process failed
0x45 FDE_BUSPARITY_ERR                 01000101
0x47 PREFETCH_VEC                      01000111 (++) (**) Prefetch abort exception (intvect.a)
0x47 SP_FAIL                           01000111 (**) Stack pointer out of range
0x4C READ_CHIP_ERR                     01001100 (**) Error in writing to read chip
0x4D IER_STACK_OVFL                    01001101 (**) IER stack overflow
0x4E IER_STACK_UNFL                    01001110 (**) IER stack underflow
0x4F IER_STACK_ERR                     01001111 (**) stack not empty on entry to sleep

0x55 IRAW_HAD_IOEDC_ERROR              01010101
0x5f IRAW_HAD_MISCOMPARE               01011111

0x67 UNDEFINED_INSTRUCTION             01100111, (++) Undefined opcode exception (intvect.a)

0x77 LOG_SAVE_FAIL                     01110111, (**) Log save data has exceeded the maximum allowable size

0x80 PORT_FAIL                         10000000, (**) Ports A & B failed power up diags
0x81 NO_BACKPLANE_DATA_RATE            10000001, (**) Can't find back plane data rate
0x81 DATA_RATE_NOT_FOUND               10000001, Can't find back plane data rate

0x90 CITCM_UNRECOVERABLE_ERROR         10010000, Controller I-TCM unrecoverable error
0x91 CDTCM_UNRECOVERABLE_ERROR         10010001, Controller D-TCM unrecoverable error
0x92 SITCM_UNRECOVERABLE_ERROR         10010010, Servo I-TCM unrecoverable error
0x93 SDTCM_UNRECOVERABLE_ERROR         10010011, Servo D-TCM unrecoverable error
0x9D TCM_CRC_FAIL                      10011101, (**) TCM CRC result is non-zero

0xC4 DRAM_INTEGRITY_FAILURE            11000100, (**) DRAM was detected to be corrupt on a write
0xCC ASSERT_FLASH_CODE                 11001100, (++) Assert failure
0xCD ENSURE_FLASH_CODE                 11001101, (++) Ensure failure
0xCE REQUIRE_FLASH_CODE                11001110, (++) Require failure

0xD1 SCSI_UNEXP_INT                    11010001, (**) Unexpected SCSI interrupt
0xD2 SCSI_TIMEOUT_FLASH_CODE           11010010, (++) SCSI timeout
0xD3 ILLEGAL_STATUS_CODE_FLASH_CODE    11010011, (++) Illegal status code
0xD4 SCSI_UNDER_OVER_RUN_OCCURED       11010100, SCSI Hardware was Overrun or Underun by the host
0xD5 UNEXPECTED_STATUS_CODE            11010101, Unexpected status code from the sequencer
0xDD DIVBY0_FAIL                       11011101, (++) (**) Divide by zero interrupt, SWI range error

0xEE ABORT_FAIL                        11101110, (**) Data abort exception (intvect.a)

0xF1 CTLR_NUKED_BY_FDE                 11110001, FDE Nuke the chip bit set, data transfers not allowed
0xF4 FLASH_IOEDC_PARITY_ERROR          11110100, (**) temporarily flash on IOEDC_PARITY_ERROR

</pre>
</body>
</html>